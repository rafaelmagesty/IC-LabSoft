commit_hash,author,message,file_path,commit_url,removed_chunk,added_chunk
88de82cdb45c1e83654b7497e5e07c75541b8cea,Seán de Búrca,Convert index route to async/await,src/server/routes/index.js,https://github.com/metabrainz/bookbrainz-site/commit/88de82cdb45c1e83654b7497e5e07c75541b8cea,"	const latestEntitiesPromise =

		Promise.all(_.map(entityModels, (model, name) =>

			model.query((qb) => {

						`bookbrainz.${_.snakeCase(name)}.revision_id`,

			.fetchAll({

				withRelated: ['defaultAlias', 'revision.revision']

			})

			.then((collection) => collection.toJSON())

		));



	latestEntitiesPromise

		.then((latestEntitiesByType) => {

			const latestEntities = _.orderBy(

				_.flatten(latestEntitiesByType), 'revision.revision.createdAt',

				['desc']

			);

			render(latestEntities);

		})

		.catch(next);
","	try {

		let latestEntities = [];



		for (const modelName in entityModels) {

			const model = entityModels[modelName];



			const collection = await model.query((qb) => {

						`bookbrainz.${_.snakeCase(modelName)}.revision_id`,

				.fetchAll({

					withRelated: ['defaultAlias', 'revision.revision']

				});



			latestEntities = latestEntities.concat(collection.toJSON());

		}



		const orderedEntities = _.orderBy(

			latestEntities, 'revision.revision.createdAt',

			['desc']

		);

		return render(orderedEntities);

	}

	catch (err) {

		return next(err);

	}
"
954dc18e67a4c12d4feec03e6d03d54cdc247f3e,Seán de Búrca,"Convert auth helper to async/await, remove co dependency",src/server/helpers/auth.js,https://github.com/metabrainz/bookbrainz-site/commit/954dc18e67a4c12d4feec03e6d03d54cdc247f3e,"		(req, accessToken, refreshToken, profile, done) => {

			if (req.user) {

				// Logged in, associate

				return linkMBAccount(req.user, profile)

					.then((linkedUser) => done(null, linkedUser.toJSON()));

			}

			// Not logged in, authenticate

			return getAccountByMBUserId(profile)

				.then((fetchedUser) =>

					updateCachedMBName(fetchedUser, profile)

				)

				.then((fetchedUser) => done(null, fetchedUser.toJSON()))

				.catch(() => {

					done(null, false, profile);

				});
","		async (req, accessToken, refreshToken, profile, done) => {

			try {

				if (req.user) {

					const linkedUser = await _linkMBAccount(req.user, profile);



					// Logged in, associate

					return done(null, linkedUser.toJSON());

				}



				// Not logged in, authenticate

				const fetchedUser = await _getAccountByMBUserId(profile);



				await _updateCachedMBName(fetchedUser, profile);

				return done(null, fetchedUser.toJSON());

			}

			catch (err) {

				return done(null, false, profile);

			}
"
7ae31abe46a856b777e65d9e852c654e833efc64,Seán de Búrca,Convert search to async/await and fix indexing,src/server/helpers/search.js,https://github.com/metabrainz/bookbrainz-site/commit/7ae31abe46a856b777e65d9e852c654e833efc64,"	_client.indices.exists({index: _index})

		.then((mainIndexExists) => {

			if (mainIndexExists) {

				return null;

			}

			return search.generateIndex();

		});
","	const mainIndexExists = await _client.indices.exists({index: _index});



	if (mainIndexExists) {

		return null;

	}

	return search.generateIndex();
"
7ae31abe46a856b777e65d9e852c654e833efc64,Seán de Búrca,Convert search to async/await and fix indexing,src/server/helpers/search.js,https://github.com/metabrainz/bookbrainz-site/commit/7ae31abe46a856b777e65d9e852c654e833efc64,"	return _client.indices.delete({index: _index})

		.catch((err) => {

			/**

			 * If the index is missing, don't worry, it probably never existed;

			 * otherwise, rethrow

 			 */

			if (!err.message.startsWith('IndexMissingException')) {

				throw err;

			}

		})

		// GOTCHA: index creation is buggy

		// https://tickets.metabrainz.org/browse/BB-205

		.then(() => _client.indices.create(

			{index: _index, body: indexMappings}

		))

		.then(() => {

			const baseRelations = [

				'annotation',

				'disambiguation',

				'defaultAlias'

			];



			const entityBehaviors = [

				{model: Creator,

					relations:

						['gender', 'creatorType', 'beginArea', 'endArea']},

				{

					model: Edition,

					relations: [

						'publication',

						'editionFormat',

						'editionStatus'

					]

				},

				{model: Publication, relations: ['publicationType']},

				{model: Publisher, relations: ['publisherType', 'area']},

				{model: Work, relations: ['workType']}

			];



			// Update the indexed entries for each entity type

			return Promise.map(entityBehaviors, (behavior) =>

				behavior.model.forge()

					.fetchAll({

						withRelated: baseRelations.concat(behavior.relations)

					})

					.then((collection) => collection.toJSON())

					.map(search.indexEntity)

			);

		})

		.then(() =>

			Area.forge()

				// countries only

				.where({type: 1})

				.fetchAll()

				.then((collection) => collection.toJSON())

				.map(search.indexArea)



		)

		.then(search.refreshIndex);
","	const mainIndexExists = await _client.indices.exists({index: _index});



	if (mainIndexExists) {

		await _client.indices.delete({index: _index});

	}



	await _client.indices.create(

		{index: _index, body: indexMappings}

	);



	const baseRelations = [

		'annotation',

		'disambiguation',

		'defaultAlias'

	];



	const entityBehaviors = [

		{

			model: Creator,

			relations: [

				'gender',

				'creatorType',

				'beginArea',

				'endArea'

			]

		},

		{

			model: Edition,

			relations: [

				'publication',

				'editionFormat',

				'editionStatus'

			]

		},

		{model: Publication, relations: ['publicationType']},

		{model: Publisher, relations: ['publisherType', 'area']},

		{model: Work, relations: ['workType']}

	];



	// Update the indexed entries for each entity type

	for (const behavior of entityBehaviors) {

		const collection = await behavior.model.forge()

			.fetchAll({

				withRelated: baseRelations.concat(behavior.relations)

			});



		const entities = collection.toJSON();



		for (const entity of entities) {

			await search.indexEntity(entity);

		}

	}



	const areaCollection = await Area.forge()

		// countries only

		.where({type: 1})

		.fetchAll();



	const areas = areaCollection.toJSON();



	for (const area of areas) {

		await search.indexArea(area);

	}



	await search.refreshIndex();
"
2dd3a0ff0794b69f49006fc7160e37f2e2e4821d,Ben Ockmore,refactor: use ES6 async/await to simplify entity creation and editing,src/server/routes/entity/entity.js,https://github.com/metabrainz/bookbrainz-site/commit/2dd3a0ff0794b69f49006fc7160e37f2e2e4821d,"		const derivedPropsPromise = processEntitySets(

		)

			.then(

				(derivedSetProps) => _.merge({}, derivedProps, derivedSetProps)

			);

		return Promise.join(

			annotationPromise, disambiguationPromise, derivedPropsPromise,

			editorUpdatePromise, notePromise,

			(

				newRevision,

				aliasSet,

				identSet,

				annotation,

				disambiguation,

				allProps

			) => {

				const propsToSet = _.extend({

					aliasSetId: aliasSet && aliasSet.get('id'),

					annotationId: annotation && annotation.get('id'),

					disambiguationId:

						disambiguation && disambiguation.get('id'),

					identifierSetId: identSet && identSet.get('id'),

					revisionId: newRevision.get('id')

				}, allProps);



				const model = utils.getEntityModelByType(orm, entityType);



				return model.forge(propsToSet)

					.save(null, {

						method: 'insert',

						transacting

					});

			}

		)

			.then(

				(entityModel) =>

					entityModel.refresh({

						transacting,

						withRelated: ['defaultAlias']

					})

			)

			.then((entity) => entity.toJSON());
","		const entitySetIdsPromise = processEntitySets(

		);

		const [

			newRevision, aliasSet, identSet, annotation, disambiguation,

			entitySetIds

		] = await Promise.all([

			annotationPromise, disambiguationPromise, entitySetIdsPromise,

			editorUpdatePromise, notePromise

		]);



		const propsToSet = _.extend({

			aliasSetId: aliasSet && aliasSet.get('id'),

			annotationId: annotation && annotation.get('id'),

			disambiguationId:

				disambiguation && disambiguation.get('id'),

			identifierSetId: identSet && identSet.get('id'),

			revisionId: newRevision.get('id')

		}, derivedProps, entitySetIds);



		const model = utils.getEntityModelByType(orm, entityType);



		const entityModel = await model.forge(propsToSet)

			.save(null, {

				method: 'insert',

				transacting

			});



		const entity = await entityModel.refresh({

			transacting,

			withRelated: ['defaultAlias']

		});



		return entity.toJSON();
"
5825f29657205fe80403e9e38c6bd30bf2fb4c47,Akhilesh Kumar,"feat(statistics-page): add new table to show count of total entities

Add new table with column `Entity Type`, `Total` and
`Added in last 30 days`. In this table shows that total count of
entities in each entity type.",src/server/routes/statistics.js,https://github.com/metabrainz/bookbrainz-site/commit/5825f29657205fe80403e9e38c6bd30bf2fb4c47,"	getTopEditors.then((topEditors) => {

		const props = generateProps(req, res, {

			topEditors

		});

		const markup = ReactDOMServer.renderToString(

			<Layout {...propHelpers.extractLayoutProps(props)}>

				<StatisticsPage

					topEditors={topEditors}

				/>

			</Layout>

		);

		res.send(target({

			markup,

			props: escapeProps(props),

			script: '/js/statistics.js',

			title: 'Statistics'

		}));
","	const topEditors = await getTopEditors;



	const props = generateProps(req, res, {

		allEntities,

		last30DaysEntities,

		topEditors

	const markup = ReactDOMServer.renderToString(

		<Layout {...propHelpers.extractLayoutProps(props)}>

			<StatisticsPage

				allEntities={allEntities}

				last30DaysEntities={last30DaysEntities}

				topEditors={topEditors}

			/>

		</Layout>

	);

	res.send(target({

		markup,

		props: escapeProps(props),

		script: '/js/statistics.js',

		title: 'Statistics'

	}));
"
09242d8519ec9f45b7194129af65783be838dc1e,Monkey Do,"feature: Fetch and display parent's name for deleted entities

In the entity display page. Uses new getEntityParentAlias ORM function.",src/server/helpers/middleware.js,https://github.com/metabrainz/bookbrainz-site/commit/09242d8519ec9f45b7194129af65783be838dc1e,"	return (req, res, next, bbid) => {

		const model = orm.func.entity.getEntityModelByType(orm, modelName);

			return orm.func.entity.getEntity(orm, modelName, bbid, relations)

				.then((entity) => {

					res.locals.entity = entity;

					next();

					return null;

				})

				.catch(model.NotFoundError, () => {

					throw new error.NotFoundError(errMessage, req);

				})

				.catch(next);
","	return async (req, res, next, bbid) => {

			try {

				const entity = await orm.func.entity.getEntity(orm, modelName, bbid, relations);

				if (!entity.dataId) {

					const parentAlias = await orm.func.entity.getEntityParentAlias(

						orm, modelName, bbid

					);

					entity.parentAlias = parentAlias;

				}

				res.locals.entity = entity;

				return next();

			}

			catch (err) {

				return next(new error.NotFoundError(errMessage, req));

			}
"
5602b5cb08969172f606ddc6f2801ead85e22f26,Monkey Do,refactor: Don't query search server when query is empty/null,src/client/entity-editor/common/entity-search-field-option.js,https://github.com/metabrainz/bookbrainz-site/commit/5602b5cb08969172f606ddc6f2801ead85e22f26,"	fetchOptions(query) {

		return request

			})

			.then((response) => ({

				options: response.body.map(this.entityToOption)

			}));
","	async fetchOptions(query) {

		if (!query) {

			return {

				options: []

			};

		}

		const response = await request

			});

		return {

			options: response.body.map(this.entityToOption)

		};
"
16358129e70fc42e10f8c7d8c8538da330e3a31b,PrabalSingh,fix(editor-revisions) : change the table in editor/:id/revisions and add pagination,src/server/routes/editor.js,https://github.com/metabrainz/bookbrainz-site/commit/16358129e70fc42e10f8c7d8c8538da330e3a31b,"router.get('/:id/revisions', (req, res, next) => {

	const {Editor, TitleUnlock} = req.app.locals.orm;

	new Editor({id: parseInt(req.params.id, 10)})

		.fetch({

			require: true,

			withRelated: {

				revisions(query) {

					query.orderBy('id');

				}

			}

		})

		.then((editor) => getEditorTitleJSON(editor.toJSON(), TitleUnlock))

		.then((editorJSON) => {

			const props = generateProps(req, res, {

				editor: editorJSON,

				tabActive: 1

			});

			const markup = ReactDOMServer.renderToString(

				<Layout {...propHelpers.extractLayoutProps(props)}>

					<EditorContainer

						{...propHelpers.extractEditorProps(props)}

					>

						<RevisionsTab

							editor={props.editor}

						/>

					</EditorContainer>

				</Layout>

			);

			res.send(target({

				markup,

				page: 'revisions',

				props: escapeProps(props),

				script: '/js/editor/editor.js'

			}));

		})

		.catch(Editor.NotFoundError, () => {

			throw new error.NotFoundError('Editor not found', req);

		})

		.catch(next);
","router.get('/:id/revisions', async (req, res, next) => {

	const {Editor, TitleUnlock, Revision} = req.app.locals.orm;



	const size = req.query.size ? parseInt(req.query.size, 10) : 20;

	const from = req.query.from ? parseInt(req.query.from, 10) : 0;

	const revisions = await new Revision()

		.query('where', 'author_id', '=', parseInt(req.params.id, 10)).orderBy('created_at', 'DESC')

		.fetchPage({

			limit: size,

			offset: from,

			withRelated: [

				'author'

			]

		});



	const revisionsJSON = revisions.toJSON();



	/* Massage the revisions to match the expected format */

	const formattedRevisions = revisionsJSON.map(rev => {

		const {author: editor, id: revisionId, ...otherProps} = rev;

		return {editor, entities: [], revisionId, ...otherProps};

	});



	/* Fetch associated ${entity}_revisions and last know alias for deleted entities */

	const orderedRevisions = await utilis.getAssociatedEntityRevisions(formattedRevisions, req.app.locals.orm);

	const props = generateProps(req, res, {

		from,

		results: orderedRevisions,

		size,

		tabActive: 1

	});

	props.editor = orderedRevisions[0].editor; // TODO change this

	const markup = ReactDOMServer.renderToString(

		<Layout {...propHelpers.extractLayoutProps(props)}>

			<EditorContainer

				{...propHelpers.extractEditorProps(props)}

			>

				<EditorRevisionPage

					from={props.from}

					results={props.results}

					size={props.size}

				/>

			</EditorContainer>

		</Layout>

	);

	res.send(target({

		markup,

		page: 'revisions',

		props: escapeProps(props),

		script: '/js/editor/editor.js'

	}));

// eslint-disable-next-line consistent-return

router.get('/:id/revisions/revisions', async (req, res, next) => {

	const {Editor, TitleUnlock, Revision} = req.app.locals.orm;

	const size = req.query.size ? parseInt(req.query.size, 10) : 20;

	const from = req.query.from ? parseInt(req.query.from, 10) : 0;



	const revisions = await new Revision()

		.query('where', 'author_id', '=', parseInt(req.params.id, 10)).orderBy('created_at', 'DESC')

		.fetchPage({

			limit: size,

			offset: from,

			withRelated: [

				'author'

			]

		});

	const revisionsJSON = revisions.toJSON();

	try {

		const formattedRevisions = revisionsJSON.map(rev => {

			const {author: editor, id: revisionId, ...otherProps} = rev;

			return {editor, entities: [], revisionId, ...otherProps};

		});



		/* Fetch associated ${entity}_revisions and last know alias for deleted entities */

		const orderedRevisions = await utilis.getAssociatedEntityRevisions(formattedRevisions, req.app.locals.orm);

		res.send(orderedRevisions);

	}

	catch (err) {

		return next(err);

	}

});
"
ba5ba3cb8064097efd29196522b7113f5c1f88ba,PrabalSingh,Display(revision-table-entity) : make revisions table for entity history similar to other revisions table; use pagination,src/server/routes/entity/entity.js,https://github.com/metabrainz/bookbrainz-site/commit/ba5ba3cb8064097efd29196522b7113f5c1f88ba,"export function displayRevisions(

	const {bbid} = req.params;

	return new RevisionModel()

		.where({bbid})

		.fetchAll({

			require: false,

			withRelated: ['revision', 'revision.author', 'revision.notes']

		})

		.then((collection) => {

			const revisions = collection ? collection.toJSON() : [];

			const props = generateProps(req, res, {

				revisions

			});

			const markup = ReactDOMServer.renderToString(

				<Layout {...propHelpers.extractLayoutProps(props)}>

					<EntityRevisions

						entity={props.entity}

						revisions={props.revisions}

					/>

				</Layout>

			);

			return res.send(target({

				markup,

				page: 'revisions',

				props: escapeProps(props),

				script: '/js/entity/entity.js'

			}));

		})

		.catch(next);
","async function getOrderedRevisionForEntityPage(

	from, next: NextFunction, RevisionModel: any, req: PassportRequest, size

) {

	try {

		const revisions = await new RevisionModel()

			.query('where', 'bbid', '=', req.params.bbid)

			.fetchPage({

				limit: size,

				offset: from,

				withRelated: ['revision', 'revision.author', 'revision.notes', 'revision.notes.author']

			});



		const revisionsJSON = revisions ? revisions.toJSON() : [];

		const orderedRevisions = revisionsJSON.map(rev => {

			const {revision} = rev;

			return {editor: revision.author, revisionId: revision.id, ...revision};

		});

		return orderedRevisions;

	}

	catch (err) {

		return next(err);

	}

}



export async function displayRevisions(

	const size = req.query.size ? parseInt(req.query.size, 10) : 20;

	const from = req.query.from ? parseInt(req.query.from, 10) : 0;



	try {

		const orderedRevisions = await getOrderedRevisionForEntityPage(from, next, RevisionModel, req, size);

		const props = generateProps(req, res, {

			from,

			revisions: orderedRevisions,

			showRevisionEditor: true,

			showRevisionNote: true,

			size,

			tableHeading: 'Revision History'

		});

		const markup = ReactDOMServer.renderToString(

			<Layout {...propHelpers.extractLayoutProps(props)}>

				<EntityRevisions

					{...{entity: props.entity}}

					{...propHelpers.extractChildProps(props)}

				/>

			</Layout>

		);

		return res.send(target({

			markup,

			page: 'revisions',

			props: escapeProps(props),

			script: '/js/entity/entity.js'

		}));

	}

	catch (err) {

		return next(err);

	}

}



// eslint-disable-next-line consistent-return

export async function displayRevisions2(

	req: PassportRequest, res: $Response, next: NextFunction, RevisionModel: any

) {

	const size = req.query.size ? parseInt(req.query.size, 10) : 20;

	const from = req.query.from ? parseInt(req.query.from, 10) : 0;



	try {

		const orderedRevisions = await getOrderedRevisionForEntityPage(from, next, RevisionModel, req, size);

		res.send(orderedRevisions);

	}

	catch (err) {

		return next(err);

	}
"
be49d61637ad0c820120057e863b40d49eeae2d8,Divyanshu Raj,fixed margin issue of brand logo in mobile view,src/server/routes/editor.js,https://github.com/metabrainz/bookbrainz-site/commit/be49d61637ad0c820120057e863b40d49eeae2d8,"router.get('/:id/revisions', (req, res, next) => {

	const {Editor, TitleUnlock} = req.app.locals.orm;

	new Editor({id: parseInt(req.params.id, 10)})

		.fetch({

			require: true,

			withRelated: {

				revisions(query) {

					query.orderBy('id');

				}

			}

		})

		.then((editor) => getEditorTitleJSON(editor.toJSON(), TitleUnlock))

		.then((editorJSON) => {

			const props = generateProps(req, res, {

				editor: editorJSON,

				tabActive: 1

			});

			const markup = ReactDOMServer.renderToString(

				<Layout {...propHelpers.extractLayoutProps(props)}>

					<EditorContainer

						{...propHelpers.extractEditorProps(props)}

					>

						<RevisionsTab

							editor={props.editor}

						/>

					</EditorContainer>

				</Layout>

			);

			res.send(target({

				markup,

				page: 'revisions',

				props: escapeProps(props),

				script: '/js/editor/editor.js'

			}));

		})

		})

		.catch(next);
","async function getOrderedRevisionForEditorPage(from, size, req) {

	const {Editor, Revision} = req.app.locals.orm;



	// If editor isn't present, throw an error

	await new Editor({id: req.params.id})

		.fetch()

		});



	const revisions = await new Revision()

		.query('where', 'author_id', '=', parseInt(req.params.id, 10))

		.orderBy('created_at', 'DESC')

		.fetchPage({

			limit: size,

			offset: from,

			withRelated: ['notes', 'notes.author']

		});

	const revisionsJSON = revisions.toJSON();

	const formattedRevisions = revisionsJSON.map(rev => {

		const {author: editor, id: revisionId, ...otherProps} = rev;

		return {editor, entities: [], revisionId, ...otherProps};

	});



	const orderedRevisions = await utils.getAssociatedEntityRevisions(formattedRevisions, req.app.locals.orm);



	return orderedRevisions;

}



// eslint-disable-next-line consistent-return

router.get('/:id/revisions', async (req, res, next) => {

	const {Editor, TitleUnlock} = req.app.locals.orm;



	const size = req.query.size ? parseInt(req.query.size, 10) : 20;

	const from = req.query.from ? parseInt(req.query.from, 10) : 0;



	try {

		const orderedRevisions = await getOrderedRevisionForEditorPage(from, size, req);



		const editor = await new Editor({id: req.params.id}).fetch();

		const editorJSON = await getEditorTitleJSON(editor.toJSON(), TitleUnlock);



		const props = generateProps(req, res, {

			editor: editorJSON,

			from,

			results: orderedRevisions,

			showRevisionNote: true,

			size,

			tabActive: 1,

			tableHeading: 'Revision History'

		});



		const markup = ReactDOMServer.renderToString(

			<Layout {...propHelpers.extractLayoutProps(props)}>

				<EditorContainer

					{...propHelpers.extractEditorProps(props)}

				>

					<EditorRevisionPage

						{...propHelpers.extractChildProps(props)}

					/>

				</EditorContainer>

			</Layout>

		);



		res.send(target({

			markup,

			page: 'revisions',

			props: escapeProps(props),

			script: '/js/editor/editor.js'

		}));

	}

	catch (err) {

		return next(err);

	}

// eslint-disable-next-line consistent-return

router.get('/:id/revisions/revisions', async (req, res, next) => {

	const size = req.query.size ? parseInt(req.query.size, 10) : 20;

	const from = req.query.from ? parseInt(req.query.from, 10) : 0;



	try {

		const orderedRevisions = await getOrderedRevisionForEditorPage(from, size, req);

		res.send(orderedRevisions);

	}

	catch (err) {

		return next(err);

	}

});




"
52a6762284e4ac495555a302db353ee95f51c9b1,Anirudh Jain,convert all promises to async await calls,src/server/routes/entity/entity.js,https://github.com/metabrainz/bookbrainz-site/commit/52a6762284e4ac495555a302db353ee95f51c9b1,"		const revisionParentsPromise = newRevisionPromise

			.then((revision) =>

				revision.related('parents').fetch({require: false, transacting}));

		const parentAddedPromise =

			revisionParentsPromise.then(

				(parents) => parents && parents.attach(

					entity.revisionId, {transacting}

				)

			);

		const notePromise = newRevisionPromise

			.then((revision) => _createNote(

				orm, body.note, editorJSON.id, revision, transacting

			));

		const newEntityRevisionPromise = newRevisionPromise

			.then((revision) => new RevisionModel({

				bbid: entity.bbid,

				dataId: null,

				id: revision.get('id')

			}).save(null, {

				method: 'insert',

				transacting

			}));

		const entityHeaderPromise = newEntityRevisionPromise

			.then((entityRevision) => new HeaderModel({

				bbid: entity.bbid,

				masterRevisionId: entityRevision.get('id')

			}).save(null, {transacting}));
","		const RevisionPromiseRevision = await newRevisionPromise;

		const revisionParentsPromise = await RevisionPromiseRevision.related('parents').fetch({require: false, transacting});

		// const revisionParentsPromise = newRevisionPromise

		// 	.then((revision) =>

		// 		revision.related('parents').fetch({require: false, transacting}));

		const parents = await revisionParentsPromise;



		const parentAddedPromise = await parents && parents.attach(

			entity.revisionId, {transacting}

		);



		const newRevisionPromiseRevision = await newRevisionPromise;



		const notePromise = _createNote(

			orm, body.note, editorJSON.id, newRevisionPromiseRevision, transacting

		);





		// const notePromise = newRevisionPromise

		// 	.then((revision) => _createNote(

		// 		orm, body.note, editorJSON.id, revision, transacting

		// 	));

		const newEntityRevisionPromise = await new RevisionModel({

			bbid: entity.bbid,

			dataId: null,

			id: await newRevisionPromiseRevision.get('id')

		}).save(null, {

			method: 'insert',

			transacting

		});



		// const newEntityRevisionPromise = newRevisionPromise

		// 	.then((revision) => new RevisionModel({

		// 		bbid: entity.bbid,

		// 		dataId: null,

		// 		id: revision.get('id')

		// 	}).save(null, {

		// 		method: 'insert',

		// 		transacting

		// 	}));



		const entityRevision = await newEntityRevisionPromise;



		const entityHeaderPromise = await new HeaderModel({

			bbid: entity.bbid,

			masterRevisionId: await entityRevision.get('id')

		}).save(null, {transacting});

		// const entityHeaderPromise = newEntityRevisionPromise

		// 	.then((entityRevision) => new HeaderModel({

		// 		bbid: entity.bbid,

		// 		masterRevisionId: entityRevision.get('id')

		// 	}).save(null, {transacting}));
"
e6c447bfd5c3acab9790060fef4fb73670d4241f,PrabalSingh,chore: use checkboxes to select collection,src/client/components/pages/parts/add-to-collection-modal.js,https://github.com/metabrainz/bookbrainz-site/commit/e6c447bfd5c3acab9790060fef4fb73670d4241f,"	handleAddToCollection(collection) {

		const {entities} = this.props;

		const submissionURL = `/collection/${collection.id}/add`;

		request.post(submissionURL)

			.send({entities})

			.then((res) => {

				this.setState({

					message: {

						text: `Added to ${collection.name}`,

						type: 'success'

					}

				});

			}, (error) => {

				this.setState({

					message: {

						text: 'Internal Error',

						type: 'danger'

					}

				});
","	async handleAddToCollection() {

		const {bbids} = this.props;

		const {selectedCollections} = this.state;

		if (selectedCollections.length) {

			const promiseArray = [];

			selectedCollections.forEach((collectionId) => {

				const submissionURL = `/collection/${collectionId}/add`;

				promiseArray.push(

					request.post(submissionURL)

						.send({bbids})

				);

			await Promise.all(promiseArray);

			this.setState({

				message: {

					text: 'Successfully added to selected collections',

					type: 'success'

				}

			});

		}

		else {

			this.setState({

				message: {

					text: 'No Collection Selected',

					type: 'danger'

				}

			});

		}
"
1831eeb9ade79801fcda5ccdf6c2c7c15a781cb8,Monkey Do,"fix(BB-537): Fix issue with EditionGroup matching mechanism

Made checkIfNameExists an async function instead of promise-based for clarity.",src/client/entity-editor/name-section/actions.js,https://github.com/metabrainz/bookbrainz-site/commit/1831eeb9ade79801fcda5ccdf6c2c7c15a781cb8,"		request.get('/search/exists')

			.query({

				q: name,

				type: _snakeCase(entityType)

			})

			.then(res => {

				let payload = JSON.parse(res.text) || null;

				if (Array.isArray(payload)) {

					payload = uniqBy(payload, 'bbid');

					// Filter out the current entity (if any)

					if (isString(entityBBID)) {

						remove(payload, ({bbid}) => entityBBID === bbid);

					}

				}

				return dispatch({

					payload,

					type: action || UPDATE_WARN_IF_EXISTS

			})

			.catch((error: {message: string}) => error);
","		try {

			const res = await request.get('/search/exists')

				.query({

					q: name,

					type: _snakeCase(entityType)



			let payload = JSON.parse(res.text) || null;

			if (Array.isArray(payload)) {

				payload = uniqBy(payload, 'bbid');

				// Filter out the current entity (if any)

				if (isString(entityBBID)) {

					remove(payload, ({bbid}) => entityBBID === bbid);

				}

			}

			dispatch({

				payload,

				type: action || UPDATE_WARN_IF_EXISTS

			});

		}

		catch (error) {

			log.error(error);

		}
"
de81ef4982bc02a236dd6b4db6b52c56dd2e450e,Ben Ockmore,"refactor(profile): make promise-returning functions async

This allows promise chains to be cleaned up and rewritten using await
expressions, which makes dependencies and error handling clearer.",src/server/routes/editor.js,https://github.com/metabrainz/bookbrainz-site/commit/de81ef4982bc02a236dd6b4db6b52c56dd2e450e,"function getEditorTitleJSON(editorJSON, TitleUnlock) {

	let editorTitleJSON;

	if (editorJSON.titleUnlockId === null) {

		editorTitleJSON = new Promise(resolve => resolve(editorJSON));

	else {

		editorTitleJSON = new TitleUnlock({

			id: editorJSON.titleUnlockId

		})

			.fetch({

				require: false,

				withRelated: ['title']

			})

			.then((unlock) => {

				if (unlock !== null) {

					editorJSON.title =

						unlock.relations.title.attributes;

				}

				return editorJSON;

			});

	return editorTitleJSON;

function getIdEditorJSONPromise(userId, req) {

	return new Editor({id: userId})

		.then((editordata) => editordata.toJSON())

		.then(_.partialRight(getEditorTitleJSON, TitleUnlock))
","async function getEditorTitleJSON(editorJSON, TitleUnlock) {

	const unlockID = editorJSON.titleUnlockId;

	if (unlockID === null) {

		return editorJSON;



	const titleUnlockModel = await new TitleUnlock({id: unlockID})

		.fetch({

			require: false,

			withRelated: ['title']

		});



	if (titleUnlockModel !== null) {

		editorJSON.title = titleUnlockModel.relations.title.attributes;



	return editorJSON;

async function getIdEditorJSONPromise(userId, req) {

	const editorData = await new Editor({id: userId})



	return getEditorTitleJSON(editorData.toJSON(), TitleUnlock);
"
de81ef4982bc02a236dd6b4db6b52c56dd2e450e,Ben Ockmore,"refactor(profile): make promise-returning functions async

This allows promise chains to be cleaned up and rewritten using await
expressions, which makes dependencies and error handling clearer.",src/server/routes/editor.js,https://github.com/metabrainz/bookbrainz-site/commit/de81ef4982bc02a236dd6b4db6b52c56dd2e450e,"function rankUpdate(orm, editorId, bodyRank, rank) {

	return new AchievementUnlock({

		.fetch({require: false})

		.then((unlock) => {

			if (unlock !== null) {

				unlock.set('profileRank', null)

					.save();

			}

		})

		.then(() => {

			let updatePromise;

			if (bodyRank === '') {

				updatePromise = new Promise(resolve => resolve(false));

			}

			else {

				updatePromise = new AchievementUnlock({

					achievementId: parseInt(bodyRank, 10),

					editorId: parseInt(editorId, 10)

				})

					.fetch({require: true})

					.then((unlock) => unlock.set('profileRank', rank).save());

			}

			return updatePromise;

		});
","async function rankUpdate(orm, editorId, bodyRank, rank) {



	// Get the achievement unlock which is currently in this ""rank""/slot

	const unlockToUnrank = await new AchievementUnlock({

		.fetch({require: false});





	// If there's a match, then unset the rank on the unlock, and save

	if (unlockToUnrank !== null) {

		await unlockToUnrank.set('profileRank', null).save();

	}



	if (bodyRank === '') {

		return false;

	}



	// Then fetch the achievement to be placed in the specified rank

	const unlockToRank = await new AchievementUnlock({

		achievementId: parseInt(bodyRank, 10),

		editorId

	})

		.fetch({require: true});



	// TODO: this can throw, so missing error handling (but so was old code)



	// And set the rank on the achievement and save it

	return unlockToRank.set('profileRank', rank).save();
"
6fc795cc023b5a7367fca4dfd6d160acfa2befdc,Ben Ockmore,"refactor(profile): rewrite route functions using async/await

This gets rid of hard-to-follow promise chains, and makes dependencies
and error handling clearer.",src/server/routes/editor.js,https://github.com/metabrainz/bookbrainz-site/commit/6fc795cc023b5a7367fca4dfd6d160acfa2befdc,"router.get('/edit', auth.isAuthenticated, (req, res, next) => {

	const editorJSONPromise = new Editor({id: parseInt(req.user.id, 10)})

		.then((editor) => editor.toJSON())

	const titleJSONPromise = new TitleUnlock()

		})

		.then((unlock) => {

			let titleJSON;

			if (unlock === null) {

				titleJSON = {};

			}

			else {

				titleJSON = unlock.toJSON();

			}

			return titleJSON;

		});

	const genderJSONPromise = new Gender()

		.fetchAll({require: false})

		.then((gender) => {

			if (gender) {

				return gender.toJSON();

			}

			return [];

	Promise.all([editorJSONPromise, titleJSONPromise, genderJSONPromise])

		.then(([editorJSON, titleJSON, genderJSON]) => {

			const props = generateProps(req, res, {

				editor: editorJSON,

				genders: genderJSON,

				titles: titleJSON

			});

			const script = '/js/editor/edit.js';

			const markup = ReactDOMServer.renderToString(

				<Layout {...propHelpers.extractLayoutProps(props)}>

					<ProfileForm

						editor={props.editor}

						genders={props.genders}

						titles={props.titles}

					/>

				</Layout>

			);

			res.send(target({

				markup,

				props: escapeProps(props),

				script

			}));

		})

		.catch(next);
","router.get('/edit', auth.isAuthenticated, async (req, res, next) => {



	// Prepare three promises to be resolved in parallel to fetch the required

	// data.

	const editorModelPromise = new Editor({id: parseInt(req.user.id, 10)})



	const titleUnlockModelPromise = new TitleUnlock()

	const gendersModelPromise = new Gender().fetchAll({require: false});



	// Parallel fetch the three required models. Only ""editorModelPromise"" has

	// ""require: true"", so only that can throw a NotFoundError, which is why the

	// other two model fetch operations have no error handling.

	const [editorModel, titleUnlockModel, genderModel] = await Promise.all([

		editorModelPromise, titleUnlockModelPromise, gendersModelPromise

	]).catch(next);



	// Convert the requested models to JSON structures.

	const editorJSON = editorModel.toJSON();

	const titleJSON =

		titleUnlockModel === null ? {} : titleUnlockModel.toJSON();

	const genderJSON = genderModel ? genderModel.toJSON() : [];



	// Populate the props to be passed to React with the fetched and formatted

	// information.

	const props = generateProps(req, res, {

		editor: editorJSON,

		genders: genderJSON,

		titles: titleJSON

	});



	// Render the DOM

	const markup = ReactDOMServer.renderToString(

		<Layout {...propHelpers.extractLayoutProps(props)}>

			<ProfileForm

				editor={props.editor}

				genders={props.genders}

				titles={props.titles}

			/>

		</Layout>

	);



	// Send the rendered DOM, the props and the script to the client

	res.send(target({

		markup,

		props: escapeProps(props),

		script: '/js/editor/edit.js'

	}));
"
6fc795cc023b5a7367fca4dfd6d160acfa2befdc,Ben Ockmore,"refactor(profile): rewrite route functions using async/await

This gets rid of hard-to-follow promise chains, and makes dependencies
and error handling clearer.",src/server/routes/editor.js,https://github.com/metabrainz/bookbrainz-site/commit/6fc795cc023b5a7367fca4dfd6d160acfa2befdc,"		})

		.then(achievementColToEditorGetJSON);





	Promise.all(

		[achievementJSONPromise, editorJSONPromise]

	)

		.then(([achievementJSON, editorJSON]) => {

			const props = generateProps(req, res, {

				achievement: achievementJSON,

				editor: editorJSON,

				tabActive: 0

			});

			const markup = ReactDOMServer.renderToString(

				<Layout {...propHelpers.extractLayoutProps(props)} >

					<EditorContainer

						{...propHelpers.extractEditorProps(props)}

					>

						<ProfileTab

							user={props.user}

							{...propHelpers.extractChildProps(props)}

						/>

					</EditorContainer>

				</Layout>

			);

			res.send(target({

				markup,

				page: 'profile',

				props: escapeProps(props),

				script: '/js/editor/editor.js',

				title: `${props.editor.name}'s Profile`

			}));
","

	const [achievementCol, editorJSON] = await Promise.all(

		[achievementColPromise, editorJSONPromise]

	).catch(next);



	editorJSON.activityData =

		await getEditorActivity(editorJSON.id, editorJSON.createdAt, Revision)

			.catch(next);



	const achievementJSON = achievementColToEditorGetJSON(achievementCol);



	const props = generateProps(req, res, {

		achievement: achievementJSON,

		editor: editorJSON,

		tabActive: 0

	});



	const markup = ReactDOMServer.renderToString(

		<Layout {...propHelpers.extractLayoutProps(props)} >

			<EditorContainer

				{...propHelpers.extractEditorProps(props)}

			>

				<ProfileTab

					user={props.user}

					{...propHelpers.extractChildProps(props)}

				/>

			</EditorContainer>

		</Layout>

	);



	res.send(target({

		markup,

		page: 'profile',

		props: escapeProps(props),

		script: '/js/editor/editor.js',

		title: `${props.editor.name}'s Profile`

	}));
"
6fc795cc023b5a7367fca4dfd6d160acfa2befdc,Ben Ockmore,"refactor(profile): rewrite route functions using async/await

This gets rid of hard-to-follow promise chains, and makes dependencies
and error handling clearer.",src/server/routes/editor.js,https://github.com/metabrainz/bookbrainz-site/commit/6fc795cc023b5a7367fca4dfd6d160acfa2befdc,"router.get('/:id/achievements', (req, res, next) => {

	const {

		AchievementType, AchievementUnlock

	} = req.app.locals.orm;

	const achievementJSONPromise = new AchievementUnlock()

		.fetchAll({require: false})

		.then(

			(unlocks) => unlocks && new AchievementType()

				.orderBy('id', 'ASC')

				.fetchAll()

				.then((achievements) => setAchievementUnlockedField(

					achievements, unlocks

				))

		);



	Promise.all([achievementJSONPromise, editorJSONPromise])

		.then(([achievementJSON, editorJSON]) => {

			const props = generateProps(req, res, {

				achievement: achievementJSON,

				editor: editorJSON,

				isOwner,

				tabActive: 2

			});

			const markup = ReactDOMServer.renderToString(

				<Layout {...propHelpers.extractLayoutProps(props)}>

					<EditorContainer

						{...propHelpers.extractEditorProps(props)}

					>

						<AchievementsTab

							achievement={props.achievement}

							editor={props.editor}

							isOwner={props.isOwner}

						/>

					</EditorContainer>

				</Layout>

			);

			const script = '/js/editor/achievement.js';

			res.send(target({

				markup,

				props: escapeProps(props),

				script,

				title: `${props.editor.name}'s Achievements`

			}));

		});
","router.get('/:id/achievements', async (req, res, next) => {

	const {AchievementType, AchievementUnlock} = req.app.locals.orm;



	const unlocksPromise = new AchievementUnlock()

		.fetchAll({require: false});



	const achievementTypesPromise = new AchievementType()

		.orderBy('id', 'ASC')

		.fetchAll();



	const [unlocks, editorJSON, achievementTypes] = await Promise.all([

		unlocksPromise, editorJSONPromise, achievementTypesPromise

	]);



	const achievementJSON =

		setAchievementUnlockedField(achievementTypes, unlocks);



	const props = generateProps(req, res, {

		achievement: achievementJSON,

		editor: editorJSON,

		isOwner,

		tabActive: 2

	});



	const markup = ReactDOMServer.renderToString(

		<Layout {...propHelpers.extractLayoutProps(props)}>

			<EditorContainer

				{...propHelpers.extractEditorProps(props)}

			>

				<AchievementsTab

					achievement={props.achievement}

					editor={props.editor}

					isOwner={props.isOwner}

				/>

			</EditorContainer>

		</Layout>

	);



	res.send(target({

		markup,

		props: escapeProps(props),

		script: '/js/editor/achievement.js',

		title: `${props.editor.name}'s Achievements`

	}));
"
21b621cd80e7b72dd5ad0d322c4c37e83f63f47b,Ben Ockmore,refactor(profile): add async wrapper in routes using sendPromiseResult,src/server/routes/editor.js,https://github.com/metabrainz/bookbrainz-site/commit/21b621cd80e7b72dd5ad0d322c4c37e83f63f47b,"	const {Editor} = req.app.locals.orm;

	const editorJSONPromise = new Promise((resolve) => {

		if (isCurrentUser(req.body.id, req.user)) {

			resolve();

		// Edit is for a user other than the current one

		throw new error.PermissionDeniedError(

			'You do not have permission to edit that user', req

		);

	})

		.then(

			// Fetch the current user from the database

			() => Editor.forge({id: parseInt(req.user.id, 10)}).fetch({require: true})

		)

		.catch(Editor.NotFoundError, () => {

			throw new error.NotFoundError('Editor not found', req);

		})

		.then(

			// Modify the user to match the updates from the form

			(editor) => editor.set('bio', req.body.bio)

				.set('areaId', req.body.areaId)

				.set('genderId', req.body.genderId)

				.set('name', req.body.name)

				.save()

		)

		.then((editor) => {

			let editorTitleUnlock;

			if (req.body.title) {

				editorTitleUnlock = editor.set('titleUnlockId', req.body.title);

			}

			else {

				editorTitleUnlock = editor.set('titleUnlockId', null);

			}

			return editorTitleUnlock.save();

		})

		.then((editor) => {

			const editorJSON = editor.toJSON();

			const editorForES = {};

			editorForES.bbid = editorJSON.id;

			editorForES.aliasSet = {

			};

			editorForES.type = 'Editor';

			return editorForES;

		});

	handler.sendPromiseResult(res, editorJSONPromise, search.indexEntity);
","	async function runAsync() {

		const {Editor} = req.app.locals.orm;



		if (!isCurrentUser(req.body.id, req.user)) {

			// Edit is for a user other than the current one

			throw new error.PermissionDeniedError(

				'You do not have permission to edit that user', req

			);

		const editor = await Editor

			.forge({id: parseInt(req.user.id, 10)})

			.fetch({require: true})

			.catch(Editor.NotFoundError, () => {

				throw new error.NotFoundError('Editor not found', req);

			});



		// Modify the user to match the updates from the form

		const titleID = _.get(req.body, 'title', null) || null;

		const modifiedEditor = await editor

			.set('bio', req.body.bio)

			.set('areaId', req.body.areaId)

			.set('genderId', req.body.genderId)

			.set('name', req.body.name)

			.set('titleUnlockId', titleID)

			.save();



		const editorJSON = modifiedEditor.toJSON();

		return {

			aliasSet: {

			},

			bbid: editorJSON.id,

			type: 'Editor'

		};

	}

	handler.sendPromiseResult(res, runAsync(), search.indexEntity);
"
21b621cd80e7b72dd5ad0d322c4c37e83f63f47b,Ben Ockmore,refactor(profile): add async wrapper in routes using sendPromiseResult,src/server/routes/editor.js,https://github.com/metabrainz/bookbrainz-site/commit/21b621cd80e7b72dd5ad0d322c4c37e83f63f47b,"	const editorPromise = new Editor({id: userId})

		.fetch({

			require: true,

			withRelated: ['type', 'gender', 'area']

		})

		.then((editordata) => {

			let editorJSON;



			if (!isCurrentUser(userId, req.user)) {

				editorJSON = new Promise((resolve, reject) => reject(new Error('Not authenticated')));

			}

			else {

				editorJSON = new Promise(resolve => resolve(editordata.toJSON()));

			}

			return editorJSON;

		});

	const rankOnePromise = rankUpdate(orm, req.params.id, req.body.rank1, 1);

	const rankTwoPromise = rankUpdate(orm, req.params.id, req.body.rank2, 2);

	const rankThreePromise = rankUpdate(orm, req.params.id, req.body.rank3, 3);





	const rankPromise =

		editorPromise.then(() =>

			Promise.all([

				rankOnePromise,

				rankTwoPromise,

				rankThreePromise

			]))

			.then((rankJSON) => {

				res.redirect(`/editor/${req.params.id}`);

				return rankJSON;

			});

	handler.sendPromiseResult(res, rankPromise);
","	async function runAsync() {

		if (!isCurrentUser(userId, req.user)) {

			throw new Error('Not authenticated');

		}



		// Presumably, this is testing that the provided editor ID is valid

		// prior to attempting to update the ranks. Possibly not needed since

		// the user must exist if authenticated?

		await new Editor({id: userId})

			.fetch({require: true});



		// TODO: missing error handling for possible missing editor - carried

		// over from old code.



		const rankOnePromise = rankUpdate(orm, userId, req.body.rank1, 1);

		const rankTwoPromise = rankUpdate(orm, userId, req.body.rank2, 2);

		const rankThreePromise = rankUpdate(orm, userId, req.body.rank3, 3);



		const rankJSON = await Promise.all([

			rankOnePromise, rankTwoPromise, rankThreePromise

		]);



		res.redirect(`/editor/${req.params.id}`);



		return rankJSON;

	}



	handler.sendPromiseResult(res, runAsync());
"
2618c5634c32ef0012d1bd044938a2c0a174c461,Ben Ockmore,refactor: rewrite sendPromiseResult using async function,src/server/helpers/handler.js,https://github.com/metabrainz/bookbrainz-site/commit/2618c5634c32ef0012d1bd044938a2c0a174c461,"export function sendPromiseResult(res, promise, processingCallback) {

	return promise

		.then((result) => {

			res.send(result);

			if (typeof processingCallback === 'function') {

				return processingCallback(result);

			}

			return result;

		})

		.catch((err) => { log.error(err); return error.sendErrorAsJSON(res, err); });
","export async function sendPromiseResult(response, promise, processingCallback) {

	const result = await promise;

	try {

		response.send(result);

		if (typeof processingCallback === 'function') {

			return processingCallback(result);

		}



		return result;

	}

	catch (err) {

		log.error(err);

		return error.sendErrorAsJSON(response, err);

	}
"
f63ab9fd5caa20043bd2844d10cf90304be6ef44,Monkey Do,"feat(areas): Display area type and parents in search options

Rewriting _fetchEntityModelsForESResults with async/await while I'm here.",src/common/helpers/search.js,https://github.com/metabrainz/bookbrainz-site/commit/f63ab9fd5caa20043bd2844d10cf90304be6ef44,"function _fetchEntityModelsForESResults(orm, results) {

	return Promise.all(results.hits.map((hit) => {

			return Area.forge({gid: entityStub.bbid})

				.fetch()

				.then((area) => {

					const areaJSON = area.toJSON();

					areaJSON.defaultAlias = {

						name: areaJSON.name

					};

					areaJSON.type = 'Area';

					return areaJSON;

				});

			return Editor.forge({id: entityStub.bbid})

				.fetch()

				.then((editor) => {

					const editorJSON = editor.toJSON();

					editorJSON.defaultAlias = {

						name: editorJSON.name

					};

					editorJSON.type = 'Editor';

					editorJSON.bbid = entityStub.bbid;

					return editorJSON;

				});

			return UserCollection.forge({id: entityStub.bbid})

				.fetch()

				.then((collection) => {

					const collectionJSON = collection.toJSON();

					collectionJSON.defaultAlias = {

						name: collectionJSON.name

					};

					collectionJSON.type = 'Collection';

					collectionJSON.bbid = entityStub.bbid;

					return collectionJSON;

				});

		return model.forge({bbid: entityStub.bbid})

			.fetch({require: false, withRelated: ['defaultAlias.language', 'disambiguation', 'aliasSet.aliases']})

			.then((entity) => entity && entity.toJSON());

	}));
","async function _fetchEntityModelsForESResults(orm, results) {

	const processedResults = await Promise.all(results.hits.map(async (hit) => {

		// Special cases first

			const area = await Area.forge({gid: entityStub.bbid})

				.fetch({withRelated: ['areaType']});



			const areaJSON = area.toJSON();

			const areaParents = await area.parents();

			areaJSON.defaultAlias = {

				name: areaJSON.name

			};

			areaJSON.type = 'Area';

			areaJSON.disambiguation = {

				comment: `${areaJSON.areaType?.name}${areaParents?.length ? ' - ' : ''}${areaParents?.map(parent => parent.name).join(', ')}`

			};

			return areaJSON;

			const editor = await Editor.forge({id: entityStub.bbid})

				.fetch();



			const editorJSON = editor.toJSON();

			editorJSON.defaultAlias = {

				name: editorJSON.name

			};

			editorJSON.type = 'Editor';

			editorJSON.bbid = entityStub.bbid;

			return editorJSON;

			const collection = await UserCollection.forge({id: entityStub.bbid})

				.fetch();



			const collectionJSON = collection.toJSON();

			collectionJSON.defaultAlias = {

				name: collectionJSON.name

			};

			collectionJSON.type = 'Collection';

			collectionJSON.bbid = entityStub.bbid;

			return collectionJSON;

		// Regular entity

		const entity = await model.forge({bbid: entityStub.bbid})

			.fetch({require: false, withRelated: ['defaultAlias.language', 'disambiguation', 'aliasSet.aliases']});



		return entity?.toJSON();

	})).catch(err => log.error(err));

	return processedResults;
"
91372fe46db6cd2edf72b1b04914822eecf21e8f,Monkey Do,"fix(editor): Improve editor form

Show errors, use async/await and fetch instead of superagent and promise chains, imrpove UI",src/client/components/forms/profile.js,https://github.com/metabrainz/bookbrainz-site/commit/91372fe46db6cd2edf72b1b04914822eecf21e8f,"		request.post('/editor/edit/handler')

			.send(data)

			.then(() => {

				window.location.href = `/editor/${this.props.editor.id}`;

	}

	valid() {

		return this.name.getValue();

	}
","		this.setState({

			waiting: true

		});

		try {

			const response = await fetch('/editor/edit/handler', {

				body: JSON.stringify(data),

				headers: {

					'Content-Type': 'application/json; charset=utf-8'

				},

				method: 'POST'

			});

			if (!response.ok) {

				throw new Error(response.statusText);

			}

			window.location.href = `/editor/${this.props.editor.id}`;

		}

		catch (err) {

			this.setState({

				error: err,

				waiting: false

		}

	};



	valid = () => this.name.getValue();
"
36a7da1f7d035f79968b1d56dae4d0af833c1831,Akash Gupta,"refactor(achievement): converted promise to async-await

Signed-off-by: Akash Gupta <akashgp9@gmail.com>",src/server/helpers/achievement.js,https://github.com/metabrainz/bookbrainz-site/commit/36a7da1f7d035f79968b1d56dae4d0af833c1831,"function testTiers(orm, signal, editorId, tiers) {

	const tierPromise = tiers.map((tier) => {

			tierOut = Promise.all([

				awardAchievement(orm, editorId, tier.name),

				awardTitle(orm, editorId, tier)

			])

				.then(([achievementUnlock, title]) => {

					const out = [];

					if (title) {

						out.push(title);

					}

					out.push(achievementUnlock);

					return out;

				})

				.catch((err) => log.debug(err));
","async function testTiers(orm, signal, editorId, tiers) {

	const tierPromise = tiers.map(async (tier) => {

			try {

			const achievementUnlock = await awardAchievement(orm, editorId, tier.name);			

			const title= await awardTitle(orm, editorId, tier);

			const out = [];

			if (title) {

				out.push(title);

			}

			out.push(achievementUnlock);

			tierOut = out;

			} catch (err) {

				return log.debug(err);

				}
"
36a7da1f7d035f79968b1d56dae4d0af833c1831,Akash Gupta,"refactor(achievement): converted promise to async-await

Signed-off-by: Akash Gupta <akashgp9@gmail.com>",src/server/helpers/achievement.js,https://github.com/metabrainz/bookbrainz-site/commit/36a7da1f7d035f79968b1d56dae4d0af833c1831,"	return Promise.all(tierPromise)

		.then((awardList) => awardListToAwardObject(awardList));


","	const awardList = await Promise.all(tierPromise);

	return awardListToAwardObject(awardList);
"
36a7da1f7d035f79968b1d56dae4d0af833c1831,Akash Gupta,"refactor(achievement): converted promise to async-await

Signed-off-by: Akash Gupta <akashgp9@gmail.com>",src/server/helpers/achievement.js,https://github.com/metabrainz/bookbrainz-site/commit/36a7da1f7d035f79968b1d56dae4d0af833c1831,"		.fetchAll({require: false})

		.then((out) => out.length);

function processRevisionist(orm, editorId) {

	return new Editor({id: editorId})

		.fetch({require: false})

		.then((editor) => {

			const revisions = editor.get('revisionsApplied');

			const tiers = [

				{

					name: 'Revisionist III',

					threshold: 250,

					titleName: 'Revisionist'

				},

				{

					name: 'Revisionist II',

					threshold: 50

				},

				{

					name: 'Revisionist I',

					threshold: 1

				}

			];

			return testTiers(orm, revisions, editorId, tiers);

		});

function processAuthorCreator(orm, editorId) {

	return getTypeCreation(new AuthorRevision(), 'author_revision', editorId)

		.then((rowCount) => {

			const tiers = [

				{

					name: 'Author Creator III',

					threshold: 100,

					titleName: 'Author Creator'

				},

				{

					name: 'Author Creator II',

					threshold: 10

				},

				{

					name: 'Author Creator I',

					threshold: 1

				}

			];

			return testTiers(orm, rowCount, editorId, tiers);

		});

function processLimitedEdition(orm, editorId) {

	return getTypeCreation(new EditionRevision(), 'edition_revision', editorId)

		.then((rowCount) => {

			const tiers = [

				{

					name: 'Limited Edition III',

					threshold: 100,

					titleName: 'Limited Edition'

				},

				{

					name: 'Limited Edition II',

					threshold: 10

				},

				{

					name: 'Limited Edition I',

					threshold: 1

				}

			];

			return testTiers(orm, rowCount, editorId, tiers);

		});

function processPublisher(orm, editorId) {

	return getTypeCreation(new EditionGroupRevision(),

		editorId)

		.then((rowCount) => {

			const tiers = [

				{

					name: 'Publisher III',

					threshold: 100,

					titleName: 'Publisher'

				},

				{

					name: 'Publisher II',

					threshold: 10

				},

				{

					name: 'Publisher I',

					threshold: 1

				}

			];

			return testTiers(orm, rowCount, editorId, tiers);

		});

function processPublisherCreator(orm, editorId) {

	return getTypeCreation(new PublisherRevision(),

		editorId)

		.then((rowCount) => {

			const tiers = [

				{

					name: 'Publisher Creator III',

					threshold: 100,

					titleName: 'Publisher Creator'

				},

				{

					name: 'Publisher Creator II',

					threshold: 10

				},

				{

					name: 'Publisher Creator I',

					threshold: 1

				}

			];

			return testTiers(orm, rowCount, editorId, tiers);

		});

function processWorkerBee(orm, editorId) {

	return getTypeCreation(new WorkRevision(),

		editorId)

		.then((rowCount) => {

			const tiers = [

				{

					name: 'Worker Bee III',

					threshold: 100,

					titleName: 'Worker Bee'

				},

				{

					name: 'Worker Bee II',

					threshold: 10

				},

				{

					name: 'Worker Bee I',

					threshold: 1

				}

			];

			return testTiers(orm, rowCount, editorId, tiers);

		});

function processSprinter(orm, editorId) {

	return bookshelf.knex.raw(rawSql)

		.then((out) => {

			const tiers = [

				{

					name: 'Sprinter',

					threshold: 10,

					titleName: 'Sprinter'

				}

			];

			return testTiers(orm, out.rowCount, editorId, tiers);

		});
","		.fetchAll({require: false});

	return out.length;

async function processRevisionist(orm, editorId) {

	const editor= await new Editor({id: editorId})

		.fetch({require: false});

	const revisions = editor.get('revisionsApplied');

	const tiers = [

		{

			name: 'Revisionist III',

			threshold: 250,

			titleName: 'Revisionist'

		},

		{

			name: 'Revisionist II',

			threshold: 50

		},

		{

			name: 'Revisionist I',

			threshold: 1

		}

	];

	return testTiers(orm, revisions, editorId, tiers);	

async function processAuthorCreator(orm, editorId) {

	const rowCount = await getTypeCreation(new AuthorRevision(), 'author_revision', editorId);	

	const tiers = [

		{

			name: 'Author Creator III',

			threshold: 100,

			titleName: 'Author Creator'

		},

		{

			name: 'Author Creator II',

			threshold: 10

		},

		{

			name: 'Author Creator I',

			threshold: 1

		}

	];

	return testTiers(orm, rowCount, editorId, tiers);

	

async function processLimitedEdition(orm, editorId) {

	const rowCount = await getTypeCreation(new EditionRevision(), 'edition_revision', editorId);

	const tiers = [

		{

			name: 'Limited Edition III',

			threshold: 100,

			titleName: 'Limited Edition'

		},

		{

			name: 'Limited Edition II',

			threshold: 10

		},

		{

			name: 'Limited Edition I',

			threshold: 1

		}

	];	

	return testTiers(orm, rowCount, editorId, tiers);

async function processPublisher(orm, editorId) {

	const rowCount = await getTypeCreation(new EditionGroupRevision(),

		editorId);

	const tiers = [

		{

			name: 'Publisher III',

			threshold: 100,

			titleName: 'Publisher'

		},

		{

			name: 'Publisher II',

			threshold: 10

		},

		{

			name: 'Publisher I',

			threshold: 1

		}

	];

	return testTiers(orm, rowCount, editorId, tiers);

async function processPublisherCreator(orm, editorId) {

	const rowCount = await getTypeCreation(new PublisherRevision(),

		editorId);

	const tiers = [

		{

			name: 'Publisher Creator III',

			threshold: 100,

			titleName: 'Publisher Creator'

		},

		{

			name: 'Publisher Creator II',

			threshold: 10

		},

		{

			name: 'Publisher Creator I',

			threshold: 1

		}

	];

	return testTiers(orm, rowCount, editorId, tiers);

async function processWorkerBee(orm, editorId) {

	const rowCount = await getTypeCreation(new WorkRevision(),

		editorId);		

	const tiers = [

		{

			name: 'Worker Bee III',

			threshold: 100,

			titleName: 'Worker Bee'

		},

		{

			name: 'Worker Bee II',

			threshold: 10

		},

		{

			name: 'Worker Bee I',

			threshold: 1

		}

	];

	return testTiers(orm, rowCount, editorId, tiers);

async function processSprinter(orm, editorId) {

	const out = await bookshelf.knex.raw(rawSql);

	const tiers = [

		{

			name: 'Sprinter',

			threshold: 10,

			titleName: 'Sprinter'

		}

	];

	return testTiers(orm, out.rowCount, editorId, tiers);
"
4c65696d39fdfdf7b80863abc535743ed03b47e5,Akash Gupta,"refactor(achievement): converted All promise to async-await

Signed-off-by: Akash Gupta <akashgp9@gmail.com>",src/server/helpers/achievement.js,https://github.com/metabrainz/bookbrainz-site/commit/4c65696d39fdfdf7b80863abc535743ed03b47e5,"function getEditsInDays(orm, editorId, days) {

	return bookshelf.knex.raw(rawSql)

		.then((out) => out.rowCount);

function processFunRunner(orm, editorId) {

	return getEditsInDays(orm, editorId, 6)

		.then((rowCount) => {

			const tiers = [

				{

					name: 'Fun Runner',

					threshold: 7,

					titleName: 'Fun Runner'

				}

			];

			return testTiers(orm, rowCount, editorId, tiers);

		});

function processMarathoner(orm, editorId) {

	return getEditsInDays(orm, editorId, 29)

		.then((rowCount) => {

			const tiers = [{

				name: 'Marathoner',

				threshold: 30,

				titleName: 'Marathoner'

			}];

			return testTiers(orm, rowCount, editorId, tiers);

		});
","async function getEditsInDays(orm, editorId, days) {

	const out = await bookshelf.knex.raw(rawSql);

	return out.rowCount;

async function processFunRunner(orm, editorId) {

	const rowCount = await getEditsInDays(orm, editorId, 6)

	const tiers = [

		{

			name: 'Fun Runner',

			threshold: 7,

			titleName: 'Fun Runner'

		}

	];

	return testTiers(orm, rowCount, editorId, tiers);



async function processMarathoner(orm, editorId) {

	const rowCount = await getEditsInDays(orm, editorId, 29);

	const tiers = [{

		name: 'Marathoner',

		threshold: 30,

		titleName: 'Marathoner'

	}];

	return testTiers(orm, rowCount, editorId, tiers);
"
4c65696d39fdfdf7b80863abc535743ed03b47e5,Akash Gupta,"refactor(achievement): converted All promise to async-await

Signed-off-by: Akash Gupta <akashgp9@gmail.com>",src/server/helpers/achievement.js,https://github.com/metabrainz/bookbrainz-site/commit/4c65696d39fdfdf7b80863abc535743ed03b47e5,"function getEntityVisits(orm, editorId) {

	return new EditorEntityVisits()

		.fetchAll({require: true})

		.then((visits) => visits.length);

function processExplorer(orm, editorId) {

	return getEntityVisits(editorId)

		.then((visits) => {

			const tiers = [

				{

					name: 'Explorer I',

					threshold: 10

				},

				{

					name: 'Explorer II',

					threshold: 100

				},

				{

					name: 'Explorer III',

					threshold: 1000,

					titleName: 'Explorer'

				}

			];

			return testTiers(orm, visits, editorId, tiers);

		})

		.catch((err) => ({Explorer: err}));
","async function getEntityVisits(orm, editorId) {

	const visits = await new EditorEntityVisits()

		.fetchAll({require: true});

	return visits.length;

async function processExplorer(orm, editorId) {

	try {

		const visits =  getEntityVisits(editorId);



		const tiers = [

			{

				name: 'Explorer I',

				threshold: 10

			},

			{

				name: 'Explorer II',

				threshold: 100

			},

			{

				name: 'Explorer III',

				threshold: 1000,

				titleName: 'Explorer'

			}

		];

		return testTiers(orm, visits, editorId, tiers);

	} catch (err) {

		return ({Explorer: err});

	}

		
"
4c65696d39fdfdf7b80863abc535743ed03b47e5,Akash Gupta,"refactor(achievement): converted All promise to async-await

Signed-off-by: Akash Gupta <akashgp9@gmail.com>",src/server/helpers/achievement.js,https://github.com/metabrainz/bookbrainz-site/commit/4c65696d39fdfdf7b80863abc535743ed03b47e5,"export function processEdit(orm, userId, revisionId) {

	return Promise.all([

		processRevisionist(orm, userId),

		processAuthorCreator(orm, userId),

		processLimitedEdition(orm, userId),

		processPublisher(orm, userId),

		processPublisherCreator(orm, userId),

		processWorkerBee(orm, userId),

		processSprinter(orm, userId),

		processFunRunner(orm, userId),

		processMarathoner(orm, userId),

		processTimeTraveller(orm, userId, revisionId),

		processHotOffThePress(orm, userId, revisionId)

	])

		.then(([

			revisionist,

			authorCreator,

			limitedEdition,

			publisher,

			publisherCreator,

			workerBee,

			sprinter,

			funRunner,

			marathoner,

			timeTraveller,

			hotOffThePress

		]) => {

			let alert = [];

			alert.push(

				achievementToUnlockId(revisionist),

				achievementToUnlockId(authorCreator),

				achievementToUnlockId(limitedEdition),

				achievementToUnlockId(publisher),

				achievementToUnlockId(publisherCreator),

				achievementToUnlockId(workerBee),

				achievementToUnlockId(sprinter),

				achievementToUnlockId(funRunner),

				achievementToUnlockId(marathoner),

				achievementToUnlockId(timeTraveller),

				achievementToUnlockId(hotOffThePress)

			);

			alert = flattenDeep(alert);

			alert = alert.join(',');

			return {

				alert,

				authorCreator,

				funRunner,

				hotOffThePress,

				limitedEdition,

				marathoner,

				publisher,

				publisherCreator,

				revisionist,

				sprinter,

				timeTraveller,

				workerBee

			};

		});
","export async function processEdit(orm, userId, revisionId) {

	const revisionist = await processRevisionist(orm, userId); 

	const authorCreator = await processAuthorCreator(orm, userId);

	const limitedEdition = await processLimitedEdition(orm, userId);

	const publisher = await processPublisher(orm, userId);

	const publisherCreator = await processPublisherCreator(orm, userId);

	const workerBee = await processWorkerBee(orm, userId);

	const sprinter = await processSprinter(orm, userId);

	const funRunner = await processFunRunner(orm, userId);

	const marathoner = await processMarathoner(orm, userId);

	const timeTraveller = await processTimeTraveller(orm, userId, revisionId);

	const hotOffThePress = await processHotOffThePress(orm, userId, revisionId);

	let alert = [];

	alert.push(

		achievementToUnlockId(revisionist),

		achievementToUnlockId(authorCreator),

		achievementToUnlockId(limitedEdition),

		achievementToUnlockId(publisher),

		achievementToUnlockId(publisherCreator),

		achievementToUnlockId(workerBee),

		achievementToUnlockId(sprinter),

		achievementToUnlockId(funRunner),

		achievementToUnlockId(marathoner),

		achievementToUnlockId(timeTraveller),

		achievementToUnlockId(hotOffThePress)

	);

	alert = flattenDeep(alert);

	alert = alert.join(',');

	return {

		alert,

		authorCreator,

		funRunner,

		hotOffThePress,

		limitedEdition,

		marathoner,

		publisher,

		publisherCreator,

		revisionist,

		sprinter,

		timeTraveller,

		workerBee

	};
"
505d71054958a422f1d5f1d65ba40b9ae85744e1,Monkey Do,"fix(search page): Allow empty search queries

Fixes a 500 error when visiting the search page with no query
Also rewrites the /search route to use async/await",src/server/routes/search.js,https://github.com/metabrainz/bookbrainz-site/commit/505d71054958a422f1d5f1d65ba40b9ae85744e1,"router.get('/', (req, res, next) => {

	const query = req.query.q;

	// get 1 more results to check nextEnabled

	search.searchByName(orm, query, _snakeCase(type), size + 1, from)

		.then((entities) => ({

			initialResults: entities.filter(entity => !isNil(entity)),

		}))

		.then((searchResults) => {

			const entityTypes = _keys(commonUtils.getEntityModels(orm));

			const {newResultsArray, nextEnabled} = utils.getNextEnabledAndResultsArray(searchResults.initialResults, size);

			searchResults.initialResults = newResultsArray;



			const props = generateProps(req, res, {

				entityTypes,

				from,

				hideSearch: true,

				nextEnabled,

				resultsPerPage: size,

				...searchResults,

				type: req.query.type

			});

			const markup = ReactDOMServer.renderToString(

				<Layout {...propHelpers.extractLayoutProps(props)}>

					<SearchPage

						user={props.user}

						{...propHelpers.extractChildProps(props)}

					/>

				</Layout>

			);



			res.send(target({

				markup,

				props: escapeProps(props),

				script: '/js/search.js',

				title: 'Search Results'

			}));

		})

		.catch(next);
","router.get('/', async (req, res, next) => {

	const query = req.query.q ?? '';

	try {

		let searchResults = {

			initialResults: [],

		};

		if (query) {

			// get 1 more results to check nextEnabled

			const entities = await search.searchByName(orm, query, _snakeCase(type), size + 1, from);

			searchResults = {

				initialResults: entities.filter(entity => !isNil(entity)),

				query

			};

		}



		const entityTypes = _keys(commonUtils.getEntityModels(orm));

		const {newResultsArray, nextEnabled} = utils.getNextEnabledAndResultsArray(searchResults.initialResults, size);

		searchResults.initialResults = newResultsArray;



		const props = generateProps(req, res, {

			entityTypes,

			from,

			hideSearch: true,

			nextEnabled,

			resultsPerPage: size,

			...searchResults,

			type: req.query.type

		});

		const markup = ReactDOMServer.renderToString(

			<Layout {...propHelpers.extractLayoutProps(props)}>

				<SearchPage

					user={props.user}

					{...propHelpers.extractChildProps(props)}

				/>

			</Layout>

		);



		return res.send(target({

			markup,

			props: escapeProps(props),

			script: '/js/search.js',

			title: 'Search Results'

		}));

	}

	catch (err) {

		return next(err);

	}
"
703269dca1267e6150c61291f58a454736b00a98,Monkey Do,"feat(search): return total number of search results

This is required for the CritiqueBrainz-BookBrainz integration project.
Also adds totalCount to API search endpoint",src/common/helpers/search.js,https://github.com/metabrainz/bookbrainz-site/commit/703269dca1267e6150c61291f58a454736b00a98,"function _searchForEntities(orm, dslQuery) {

	return _client.search(dslQuery)

		.then((searchResponse) => searchResponse.body?.hits)

		.then((results) => _fetchEntityModelsForESResults(orm, results))

		.catch(error => log.error(error));
","async function _searchForEntities(orm, dslQuery) {

	try {

		const searchResponse = await _client.search(dslQuery);

		const results = await _fetchEntityModelsForESResults(orm, searchResponse.body.hits);

		return {results, total: searchResponse.body.hits.total};

	}

	catch (error) {

		log.error(error);

	}

	return {results: [], total: 0};
"
dfe86b24e93f968632fed8f6513119508bdbc4df,Rohan Sasne,refactor(BB-673): Code rewritten using async/await syntax.,src/server/helpers/middleware.ts,https://github.com/metabrainz/bookbrainz-site/commit/dfe86b24e93f968632fed8f6513119508bdbc4df,"function makeLoader(modelName, propName, sortFunc?, relations = []) {

	return function loaderFunc(req: $Request, res: $Response, next: NextFunction) {

		const {orm}: any = req.app.locals;

		const model = orm[modelName];

		return model.fetchAll({withRelated: [...relations]})

			.then((results) => {

				const resultsSerial = results.toJSON();



				res.locals[propName] =

					sortFunc ? resultsSerial.sort(sortFunc) : resultsSerial;



				next();



				return null;

			})

			.catch(next);

	};
","async function makeLoader(modelName, propName, sortFunc?, relations = []) {

	try {

		return async function loaderFunc(req: $Request, res: $Response, next: NextFunction) {

			const {orm}: any = req.app.locals;

			const model = orm[modelName];

			const results = await model.fetchAll({withRelated: [...relations]});

			const resultsSerial = results.toJSON();

			res.locals[propName] =

				sortFunc ? resultsSerial.sort(sortFunc) : resultsSerial;

			next();

			return null;

		};

	} catch (error) {

		throw error;

	}


"
dfe86b24e93f968632fed8f6513119508bdbc4df,Rohan Sasne,refactor(BB-673): Code rewritten using async/await syntax.,src/server/helpers/middleware.ts,https://github.com/metabrainz/bookbrainz-site/commit/dfe86b24e93f968632fed8f6513119508bdbc4df,"

	return Promise.all(entity.relationships.map((relationship) =>

		Promise.all([getEntityWithAlias(relationship.source), getEntityWithAlias(relationship.target)])

			.then(([source, target]) => {

				relationship.source = source.toJSON();

				relationship.target = target.toJSON();



				return relationship;

			})));

export function loadEntityRelationships(req: $Request, res: $Response, next: NextFunction) {

	new Promise<void>((resolve) => {

		resolve();

	})

		.then(

			() => RelationshipSet.forge({id: entity.relationshipSetId})

				.fetch({

					require: false,

					withRelated: [

						'relationships.source',

						'relationships.target',

						'relationships.type.attributeTypes',

						'relationships.attributeSet.relationshipAttributes.value',

						'relationships.attributeSet.relationshipAttributes.type'

					]

				})

		)

		.then((relationshipSet) => addRelationships(entity, relationshipSet, orm))

		.then(() => {

			next();

			return null;

		})

		.catch(next);
","

	const relationshipPromises = entity.relationships.map(async (relationship) => {

		const [source, target] = await Promise.all([getEntityWithAlias(relationship.source), getEntityWithAlias(relationship.target)]);

		relationship.source = source.toJSON();

		relationship.target = target.toJSON();



		return relationship;

	});



	return Promise.all(relationshipPromises);



export async function loadEntityRelationships(req: $Request, res: $Response, next: NextFunction) {

	try {

		const relationshipSet = await RelationshipSet.forge({id: entity.relationshipSetId})

			.fetch({

				require: false,

				withRelated: [

					'relationships.source',

					'relationships.target',

					'relationships.type.attributeTypes',

					'relationships.attributeSet.relationshipAttributes.value',

					'relationships.attributeSet.relationshipAttributes.type'

				]

			});



		await addRelationships(entity, relationshipSet, orm);



		next();

	} catch (err) {

		next(err);

	}


"
832e7f7bc0c214bf7bfc6a5787c35a7847ec6f17,Rohan Sasne,BB-674: Rewrite revision file using async/await syntax,src/server/routes/revision.js,https://github.com/metabrainz/bookbrainz-site/commit/832e7f7bc0c214bf7bfc6a5787c35a7847ec6f17,"function diffRevisionsWithParents(orm, entityRevisions, entityType) {

	return Promise.all(entityRevisions.map(

			return revision.parent()

				.then(

					(parent) => {

						let isNew = false;
","async function diffRevisionsWithParents(orm, entityRevisions, entityType) {

	const promises = entityRevisions.map(

			try {

				const parent = await revision.parent();

				let isNew = false;

				
"
832e7f7bc0c214bf7bfc6a5787c35a7847ec6f17,Rohan Sasne,BB-674: Rewrite revision file using async/await syntax,src/server/routes/revision.js,https://github.com/metabrainz/bookbrainz-site/commit/832e7f7bc0c214bf7bfc6a5787c35a7847ec6f17,"	function _createRevision(EntityRevisionModel, entityType) {

		return EntityRevisionModel.forge()

			.where('id', req.params.id)

			.fetchAll({merge: false, remove: false, require: false, withRelated: 'entity'})

			.then((entityRevisions) => diffRevisionsWithParents(req.app.locals.orm, entityRevisions, entityType))

			.catch(err => { log.error(err); throw err; });
","	async function _createRevision(EntityRevisionModel, entityType) {

		try {

			const entityRevisions = await EntityRevisionModel.forge()

				.where('id', req.params.id)

				.fetchAll({merge: false, remove: false, require: false, withRelated: 'entity'});

			return await diffRevisionsWithParents(req.app.locals.orm, entityRevisions, entityType);

		} catch (err) {

			log.error(err);

			throw err;

		}

	
"
e56d8a83243805c1f0288075ea8221b14561dd9b,the-good-boy,feat: add reindex search engine as a privilege,src/server/routes/search.js,https://github.com/metabrainz/bookbrainz-site/commit/e56d8a83243805c1f0288075ea8221b14561dd9b,"router.get('/reindex', auth.isAuthenticated, (req, res) => {

	const indexPromise = new Promise((resolve) => {

		// TODO: This is hacky, and we should replace it once we switch to SOLR.

		const trustedUsers = ['Leftmost Cat', 'LordSputnik', 'Monkey', 'iliekcomputers'];

		const NO_MATCH = -1;

		if (trustedUsers.indexOf(req.user.name) === NO_MATCH) {

			throw new error.PermissionDeniedError(null, req);

		}



		resolve();

	})

		.then(() => search.generateIndex(orm))

		.then(() => ({success: true}));



	handler.sendPromiseResult(res, indexPromise);
","router.get('/reindex', auth.isAuthenticated, auth.isAuthorized(REINDEX_SEARCH_SERVER), async (req, res) => {

	await search.generateIndex(orm);

	handler.sendPromiseResult(res, {success: true});
"
4767a89032e5935ad9303b91ede687ebc6cdba67,Monkey Do,"chore(search): Send entity models for indexing

With the change from the previous commit (accepting an ORM model rather than JSON for search indexing), we need to rewrite accordingly the parts of the code that use the search indexing.

Taking this opportunity to rewrite some code from promises to async/await syntax.",src/server/helpers/collectionRouteUtils.js,https://github.com/metabrainz/bookbrainz-site/commit/4767a89032e5935ad9303b91ede687ebc6cdba67,"			const collectionPromiseForES = new Promise((resolve) => {

				const collectionForES = {

					aliasSet: {

						aliases: [

							{name: newCollection.get('name')}

						]

					},

					bbid: newCollection.get('id'),

					id: newCollection.get('id'),

					type: 'Collection'

				};

				resolve(collectionForES);

			});

			return handler.sendPromiseResult(res, collectionPromiseForES, search.indexEntity);

		return res.send(newCollection.toJSON());
","			await search.indexEntity(newCollection);

		return res.status(200).send(newCollection.toJSON());
"
4767a89032e5935ad9303b91ede687ebc6cdba67,Monkey Do,"chore(search): Send entity models for indexing

With the change from the previous commit (accepting an ORM model rather than JSON for search indexing), we need to rewrite accordingly the parts of the code that use the search indexing.

Taking this opportunity to rewrite some code from promises to async/await syntax.",src/server/routes/register.js,https://github.com/metabrainz/bookbrainz-site/commit/4767a89032e5935ad9303b91ede687ebc6cdba67,"router.post('/handler', (req, res) => {

	const {Editor, EditorType} = req.app.locals.orm;

	// Check whether the user is logged in - if so, redirect to profile page

	if (req.user) {

		return res.redirect(`/editor/${req.user.id}`);

	}

	if (!req.session.mbProfile) {

		return res.redirect('/auth');



	// Fetch the default EditorType from the database

	const registerPromise = EditorType.forge({label: 'Editor'})

		.fetch({require: true})

		.then(

			// Create a new Editor and add to the database

			(editorType) =>

				new Editor({

					cachedMetabrainzName: req.session.mbProfile.sub,

					genderId: req.body.gender,

					metabrainzUserId: req.session.mbProfile.metabrainz_user_id,

					name: req.body.displayName,

					typeId: editorType.id

				})

					.save()

		)

		.then((editor) => {

			req.session.mbProfile = null;

			const editorJSON = editor.toJSON();



			// in ES index, we're storing the editor as entity

			const editorForES = {};

			editorForES.bbid = editorJSON.id;

			editorForES.aliasSet = {

				aliases: [

					{name: editorJSON.name}

				]

			};

			editorForES.type = 'Editor';

			return editorForES;

		})

		.catch((err) => {

			log.debug(err);



			if (_.isMatch(err, {constraint: 'editor_name_key'})) {

				throw new error.FormSubmissionError(

					'That username already exists - please try using another,' +

					' or contact us to have your existing BookBrainz account' +

					' linked to a MusicBrainz account.'

				);

			}



			throw new error.FormSubmissionError(

				'Something went wrong when registering, please try again!'

			);

		});



	return handler.sendPromiseResult(res, registerPromise, search.indexEntity);
","router.post('/handler', async (req, res) => {

	try {

		const {Editor, EditorType} = req.app.locals.orm;



		// Check whether the user is logged in - if so, redirect to profile page

		if (req.user) {

			return res.redirect(`/editor/${req.user.id}`);

		}



		if (!req.session.mbProfile) {

			return res.redirect('/auth');

		}



		// Fetch the default EditorType from the database

		const editorType = await EditorType.forge({label: 'Editor'})

			.fetch({require: true});



		// Create a new Editor and add to the database



		const editor = await new Editor({

			cachedMetabrainzName: req.session.mbProfile.sub,

			genderId: req.body.gender,

			metabrainzUserId: req.session.mbProfile.metabrainz_user_id,

			name: req.body.displayName,

			typeId: editorType.id

		})

			.save();

		req.session.mbProfile = null;

		await search.indexEntity(editor);

		return res.status(200).send(editor.toJSON());

	}

	catch (err) {

		if (_.isMatch(err, {constraint: 'editor_name_key'})) {

			return error.sendErrorAsJSON(res, new error.FormSubmissionError(

				'That username already exists - please try using another,' +

			' or contact us to have your existing BookBrainz account' +

			' linked to a MusicBrainz account.'

			));

		}

		log.error(err);



		return error.sendErrorAsJSON(res, new error.FormSubmissionError(

			'Something went wrong when registering, please try again!'

		));
"
