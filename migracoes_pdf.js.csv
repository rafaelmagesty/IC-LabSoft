commit_hash,author,message,file_path,commit_url,removed_chunk,added_chunk,commit_date
099ed0885239f070f7c7e1d703b57cc64c3f634d,Jonas Jenwald,"Add support for `async`/`await` using Babel

For proof-of-concept, this patch converts a couple of `Promise` returning methods to use `async` instead.
Please note that the `generic` build, based on this patch, has been successfully testing in IE11 (i.e. the viewer loads and nothing is obviously broken).

Being able to use modern JavaScript features like `async`/`await` is a huge plus, but there's one (obvious) side-effect: The size of the built files will increase slightly (unless `SKIP_BABEL == true`). That's unavoidable, but seems like a small price to pay in the grand scheme of things.

Finally, note that the `chromium` build target was changed to no longer skip Babel translation, since the Chrome extension still supports version `49` of the browser (where native `async` support isn't available).",src/core/evaluator.js,https://github.com/mozilla/pdf.js/commit/099ed0885239f070f7c7e1d703b57cc64c3f634d,"    this.fetchBuiltInCMap = (name) => {

        return Promise.resolve(this.builtInCMapCache.get(name));

      return this.handler.sendWithPromise('FetchBuiltInCMap', {

        name,

      }).then((data) => {

        if (data.compressionType !== CMapCompressionType.NONE) {

          // Given the size of uncompressed CMaps, only cache compressed ones.

          this.builtInCMapCache.set(name, data);

        }

        return data;

      });
","    this.fetchBuiltInCMap = async (name) => {

        return this.builtInCMapCache.get(name);

      const data = await this.handler.sendWithPromise('FetchBuiltInCMap',

                                                      { name, });

      if (data.compressionType !== CMapCompressionType.NONE) {

        // Given the size of uncompressed CMaps, only cache compressed ones.

        this.builtInCMapCache.set(name, data);

      }

      return data;
",2018-07-30 13:58:09+02:00
099ed0885239f070f7c7e1d703b57cc64c3f634d,Jonas Jenwald,"Add support for `async`/`await` using Babel

For proof-of-concept, this patch converts a couple of `Promise` returning methods to use `async` instead.
Please note that the `generic` build, based on this patch, has been successfully testing in IE11 (i.e. the viewer loads and nothing is obviously broken).

Being able to use modern JavaScript features like `async`/`await` is a huge plus, but there's one (obvious) side-effect: The size of the built files will increase slightly (unless `SKIP_BABEL == true`). That's unavoidable, but seems like a small price to pay in the grand scheme of things.

Finally, note that the `chromium` build target was changed to no longer skip Babel translation, since the Chrome extension still supports version `49` of the browser (where native `async` support isn't available).",src/core/obj.js,https://github.com/mozilla/pdf.js/commit/099ed0885239f070f7c7e1d703b57cc64c3f634d,"    fetchIfRefAsync: function XRef_fetchIfRefAsync(obj, suppressEncryption) {

        return Promise.resolve(obj);

    fetchAsync: function XRef_fetchAsync(ref, suppressEncryption) {

      var streamManager = this.stream.manager;

      var xref = this;

      return new Promise(function tryFetch(resolve, reject) {

        try {

          resolve(xref.fetch(ref, suppressEncryption));

        } catch (e) {

          if (e instanceof MissingDataException) {

            streamManager.requestRange(e.begin, e.end).then(function () {

              tryFetch(resolve, reject);

            }, reject);

            return;

          }

          reject(e);

      });
","    async fetchIfRefAsync(obj, suppressEncryption) {

        return obj;

    async fetchAsync(ref, suppressEncryption) {

      try {

        return this.fetch(ref, suppressEncryption);

      } catch (ex) {

        if (!(ex instanceof MissingDataException)) {

          throw ex;

        await this.pdfManager.requestRange(ex.begin, ex.end);

        return this.fetchAsync(ref, suppressEncryption);

      }
",2018-07-30 13:58:09+02:00
099ed0885239f070f7c7e1d703b57cc64c3f634d,Jonas Jenwald,"Add support for `async`/`await` using Babel

For proof-of-concept, this patch converts a couple of `Promise` returning methods to use `async` instead.
Please note that the `generic` build, based on this patch, has been successfully testing in IE11 (i.e. the viewer loads and nothing is obviously broken).

Being able to use modern JavaScript features like `async`/`await` is a huge plus, but there's one (obvious) side-effect: The size of the built files will increase slightly (unless `SKIP_BABEL == true`). That's unavoidable, but seems like a small price to pay in the grand scheme of things.

Finally, note that the `chromium` build target was changed to no longer skip Babel translation, since the Chrome extension still supports version `49` of the browser (where native `async` support isn't available).",src/core/pdf_manager.js,https://github.com/mozilla/pdf.js/commit/099ed0885239f070f7c7e1d703b57cc64c3f634d,"  ensure(obj, prop, args) {

    return new Promise(function(resolve) {

      const value = obj[prop];

      if (typeof value === 'function') {

        resolve(value.apply(obj, args));

      } else {

        resolve(value);

      }

    });
","  async ensure(obj, prop, args) {

    const value = obj[prop];

    if (typeof value === 'function') {

      return value.apply(obj, args);

    }

    return value;
",2018-07-30 13:58:09+02:00
099ed0885239f070f7c7e1d703b57cc64c3f634d,Jonas Jenwald,"Add support for `async`/`await` using Babel

For proof-of-concept, this patch converts a couple of `Promise` returning methods to use `async` instead.
Please note that the `generic` build, based on this patch, has been successfully testing in IE11 (i.e. the viewer loads and nothing is obviously broken).

Being able to use modern JavaScript features like `async`/`await` is a huge plus, but there's one (obvious) side-effect: The size of the built files will increase slightly (unless `SKIP_BABEL == true`). That's unavoidable, but seems like a small price to pay in the grand scheme of things.

Finally, note that the `chromium` build target was changed to no longer skip Babel translation, since the Chrome extension still supports version `49` of the browser (where native `async` support isn't available).",src/core/pdf_manager.js,https://github.com/mozilla/pdf.js/commit/099ed0885239f070f7c7e1d703b57cc64c3f634d,"  ensure(obj, prop, args) {

    return new Promise((resolve, reject) => {

      let ensureHelper = () => {

        try {

          const value = obj[prop];

          let result;

          if (typeof value === 'function') {

            result = value.apply(obj, args);

          } else {

            result = value;

          }

          resolve(result);

        } catch (ex) {

          if (!(ex instanceof MissingDataException)) {

            reject(ex);

            return;

          }

          this.streamManager.requestRange(ex.begin, ex.end)

            .then(ensureHelper, reject);

        }

      };



      ensureHelper();

    });
","  async ensure(obj, prop, args) {

    try {

      const value = obj[prop];

      if (typeof value === 'function') {

        return value.apply(obj, args);

      }

      return value;

    } catch (ex) {

      if (!(ex instanceof MissingDataException)) {

        throw ex;

      }

      await this.requestRange(ex.begin, ex.end);

      return this.ensure(obj, prop, args);

    }
",2018-07-30 13:58:09+02:00
099ed0885239f070f7c7e1d703b57cc64c3f634d,Jonas Jenwald,"Add support for `async`/`await` using Babel

For proof-of-concept, this patch converts a couple of `Promise` returning methods to use `async` instead.
Please note that the `generic` build, based on this patch, has been successfully testing in IE11 (i.e. the viewer loads and nothing is obviously broken).

Being able to use modern JavaScript features like `async`/`await` is a huge plus, but there's one (obvious) side-effect: The size of the built files will increase slightly (unless `SKIP_BABEL == true`). That's unavoidable, but seems like a small price to pay in the grand scheme of things.

Finally, note that the `chromium` build target was changed to no longer skip Babel translation, since the Chrome extension still supports version `49` of the browser (where native `async` support isn't available).",src/display/fetch_stream.js,https://github.com/mozilla/pdf.js/commit/099ed0885239f070f7c7e1d703b57cc64c3f634d,"  read() {

    return this._headersCapability.promise.then(() => {

      return this._reader.read().then(({ value, done, }) => {

        if (done) {

          return Promise.resolve({ value, done, });

        }

        this._loaded += value.byteLength;

        if (this.onProgress) {

          this.onProgress({

            loaded: this._loaded,

            total: this._contentLength,

          });

        }

        let buffer = new Uint8Array(value).buffer;

        return Promise.resolve({ value: buffer, done: false, });

    });
","  async read() {

    await this._headersCapability.promise;

    const { value, done, } = await this._reader.read();

    if (done) {

      return { value, done, };

    }

    this._loaded += value.byteLength;

    if (this.onProgress) {

      this.onProgress({

        loaded: this._loaded,

        total: this._contentLength,

    }

    let buffer = new Uint8Array(value).buffer;

    return { value: buffer, done: false, };
",2018-07-30 13:58:09+02:00
099ed0885239f070f7c7e1d703b57cc64c3f634d,Jonas Jenwald,"Add support for `async`/`await` using Babel

For proof-of-concept, this patch converts a couple of `Promise` returning methods to use `async` instead.
Please note that the `generic` build, based on this patch, has been successfully testing in IE11 (i.e. the viewer loads and nothing is obviously broken).

Being able to use modern JavaScript features like `async`/`await` is a huge plus, but there's one (obvious) side-effect: The size of the built files will increase slightly (unless `SKIP_BABEL == true`). That's unavoidable, but seems like a small price to pay in the grand scheme of things.

Finally, note that the `chromium` build target was changed to no longer skip Babel translation, since the Chrome extension still supports version `49` of the browser (where native `async` support isn't available).",src/display/fetch_stream.js,https://github.com/mozilla/pdf.js/commit/099ed0885239f070f7c7e1d703b57cc64c3f634d,"  read() {

    return this._readCapability.promise.then(() => {

      return this._reader.read().then(({ value, done, }) => {

        if (done) {

          return Promise.resolve({ value, done, });

        }

        this._loaded += value.byteLength;

        if (this.onProgress) {

          this.onProgress({ loaded: this._loaded, });

        }

        let buffer = new Uint8Array(value).buffer;

        return Promise.resolve({ value: buffer, done: false, });

      });

    });
","  async read() {

    await this._readCapability.promise;

    const { value, done, } = await this._reader.read();

    if (done) {

      return { value, done, };

    }

    this._loaded += value.byteLength;

    if (this.onProgress) {

      this.onProgress({ loaded: this._loaded, });

    }

    let buffer = new Uint8Array(value).buffer;

    return { value: buffer, done: false, };
",2018-07-30 13:58:09+02:00
099ed0885239f070f7c7e1d703b57cc64c3f634d,Jonas Jenwald,"Add support for `async`/`await` using Babel

For proof-of-concept, this patch converts a couple of `Promise` returning methods to use `async` instead.
Please note that the `generic` build, based on this patch, has been successfully testing in IE11 (i.e. the viewer loads and nothing is obviously broken).

Being able to use modern JavaScript features like `async`/`await` is a huge plus, but there's one (obvious) side-effect: The size of the built files will increase slightly (unless `SKIP_BABEL == true`). That's unavoidable, but seems like a small price to pay in the grand scheme of things.

Finally, note that the `chromium` build target was changed to no longer skip Babel translation, since the Chrome extension still supports version `49` of the browser (where native `async` support isn't available).",src/display/node_stream.js,https://github.com/mozilla/pdf.js/commit/099ed0885239f070f7c7e1d703b57cc64c3f634d,"  read() {

    return this._readCapability.promise.then(() => {

      if (this._done) {

        return Promise.resolve({ value: undefined, done: true, });

      }

      if (this._storedError) {

        return Promise.reject(this._storedError);

      }

      let chunk = this._readableStream.read();

      if (chunk === null) {

        this._readCapability = createPromiseCapability();

        return this.read();

      }

      this._loaded += chunk.length;

      if (this.onProgress) {

        this.onProgress({

          loaded: this._loaded,

          total: this._contentLength,

        });

      }

      // Ensure that `read()` method returns ArrayBuffer.

      let buffer = new Uint8Array(chunk).buffer;

      return Promise.resolve({ value: buffer, done: false, });

    });
","  async read() {

    await this._readCapability.promise;

    if (this._done) {

      return { value: undefined, done: true, };

    }

    if (this._storedError) {

      throw this._storedError;

    }

    let chunk = this._readableStream.read();

    if (chunk === null) {

      this._readCapability = createPromiseCapability();

      return this.read();

    }

    this._loaded += chunk.length;

    if (this.onProgress) {

      this.onProgress({

        loaded: this._loaded,

        total: this._contentLength,

      });

    }

    // Ensure that `read()` method returns ArrayBuffer.

    let buffer = new Uint8Array(chunk).buffer;

    return { value: buffer, done: false, };
",2018-07-30 13:58:09+02:00
099ed0885239f070f7c7e1d703b57cc64c3f634d,Jonas Jenwald,"Add support for `async`/`await` using Babel

For proof-of-concept, this patch converts a couple of `Promise` returning methods to use `async` instead.
Please note that the `generic` build, based on this patch, has been successfully testing in IE11 (i.e. the viewer loads and nothing is obviously broken).

Being able to use modern JavaScript features like `async`/`await` is a huge plus, but there's one (obvious) side-effect: The size of the built files will increase slightly (unless `SKIP_BABEL == true`). That's unavoidable, but seems like a small price to pay in the grand scheme of things.

Finally, note that the `chromium` build target was changed to no longer skip Babel translation, since the Chrome extension still supports version `49` of the browser (where native `async` support isn't available).",src/display/node_stream.js,https://github.com/mozilla/pdf.js/commit/099ed0885239f070f7c7e1d703b57cc64c3f634d,"  read() {

    return this._readCapability.promise.then(() => {

      if (this._done) {

        return Promise.resolve({ value: undefined, done: true, });

      }

      if (this._storedError) {

        return Promise.reject(this._storedError);

      }

      let chunk = this._readableStream.read();

      if (chunk === null) {

        this._readCapability = createPromiseCapability();

        return this.read();

      }

      this._loaded += chunk.length;

      if (this.onProgress) {

        this.onProgress({ loaded: this._loaded, });

      }

      // Ensure that `read()` method returns ArrayBuffer.

      let buffer = new Uint8Array(chunk).buffer;

      return Promise.resolve({ value: buffer, done: false, });

    });
","  async read() {

    await this._readCapability.promise;

    if (this._done) {

      return { value: undefined, done: true, };

    }

    if (this._storedError) {

      throw this._storedError;

    }

    let chunk = this._readableStream.read();

    if (chunk === null) {

      this._readCapability = createPromiseCapability();

      return this.read();

    }

    this._loaded += chunk.length;

    if (this.onProgress) {

      this.onProgress({ loaded: this._loaded, });

    }

    // Ensure that `read()` method returns ArrayBuffer.

    let buffer = new Uint8Array(chunk).buffer;

    return { value: buffer, done: false, };
",2018-07-30 13:58:09+02:00
099ed0885239f070f7c7e1d703b57cc64c3f634d,Jonas Jenwald,"Add support for `async`/`await` using Babel

For proof-of-concept, this patch converts a couple of `Promise` returning methods to use `async` instead.
Please note that the `generic` build, based on this patch, has been successfully testing in IE11 (i.e. the viewer loads and nothing is obviously broken).

Being able to use modern JavaScript features like `async`/`await` is a huge plus, but there's one (obvious) side-effect: The size of the built files will increase slightly (unless `SKIP_BABEL == true`). That's unavoidable, but seems like a small price to pay in the grand scheme of things.

Finally, note that the `chromium` build target was changed to no longer skip Babel translation, since the Chrome extension still supports version `49` of the browser (where native `async` support isn't available).",src/shared/message_handler.js,https://github.com/mozilla/pdf.js/commit/099ed0885239f070f7c7e1d703b57cc64c3f634d,"function resolveCall(fn, args, thisArg = null) {

    return Promise.resolve(undefined);

  return new Promise((resolve, reject) => {

    resolve(fn.apply(thisArg, args));

  });
","async function resolveCall(fn, args, thisArg = null) {

    return;

  return fn.apply(thisArg, args);
",2018-07-30 13:58:09+02:00
b0fa02e8456b6a27d6d3b242c4301a4e70937b17,Jonas Jenwald,"Refactor the `IL10n` implementations to utilize `async` methods rather than manually returning `Promise`s

This changes the methods signatures of `GenericL10n`, `MozL10n`, and `NullL10n`.",web/genericl10n.js,https://github.com/mozilla/pdf.js/commit/b0fa02e8456b6a27d6d3b242c4301a4e70937b17,"  getLanguage() {

    return this._ready.then((l10n) => {

      return l10n.getLanguage();

    });

  getDirection() {

    return this._ready.then((l10n) => {

      return l10n.getDirection();

    });

  get(property, args, fallback) {

    return this._ready.then((l10n) => {

      return l10n.get(property, args, fallback);

    });

  translate(element) {

    return this._ready.then((l10n) => {

      return l10n.translate(element);

    });
","  async getLanguage() {

    const l10n = await this._ready;

    return l10n.getLanguage();

  async getDirection() {

    const l10n = await this._ready;

    return l10n.getDirection();

  async get(property, args, fallback) {

    const l10n = await this._ready;

    return l10n.get(property, args, fallback);

  async translate(element) {

    const l10n = await this._ready;

    return l10n.translate(element);
",2018-07-30 16:28:39+02:00
64e70fc16ffb102524215d02b5b3ebabddbacc09,Jonas Jenwald,Refactor the `OverlayManager`  to utilize `async` methods rather than manually returning `Promise`s,web/overlay_manager.js,https://github.com/mozilla/pdf.js/commit/64e70fc16ffb102524215d02b5b3ebabddbacc09,"  register(name, element, callerCloseMethod = null, canForceClose = false) {

    return new Promise((resolve) => {

      let container;

      if (!name || !element || !(container = element.parentNode)) {

        throw new Error('Not enough parameters.');

      } else if (this._overlays[name]) {

        throw new Error('The overlay is already registered.');

      }

      this._overlays[name] = {

        element,

        container,

        callerCloseMethod,

        canForceClose,

      };

      resolve();

    });
","  async register(name, element, callerCloseMethod = null,

                 canForceClose = false) {

    let container;

    if (!name || !element || !(container = element.parentNode)) {

      throw new Error('Not enough parameters.');

    } else if (this._overlays[name]) {

      throw new Error('The overlay is already registered.');

    }

    this._overlays[name] = {

      element,

      container,

      callerCloseMethod,

      canForceClose,

    };
",2018-07-30 16:39:06+02:00
64e70fc16ffb102524215d02b5b3ebabddbacc09,Jonas Jenwald,Refactor the `OverlayManager`  to utilize `async` methods rather than manually returning `Promise`s,web/overlay_manager.js,https://github.com/mozilla/pdf.js/commit/64e70fc16ffb102524215d02b5b3ebabddbacc09,"  unregister(name) {

    return new Promise((resolve) => {

      if (!this._overlays[name]) {

        throw new Error('The overlay does not exist.');

      } else if (this._active === name) {

        throw new Error('The overlay cannot be removed while it is active.');

      }

      delete this._overlays[name];

      resolve();

    });
","  async unregister(name) {

    if (!this._overlays[name]) {

      throw new Error('The overlay does not exist.');

    } else if (this._active === name) {

      throw new Error('The overlay cannot be removed while it is active.');

    }

    delete this._overlays[name];
",2018-07-30 16:39:06+02:00
64e70fc16ffb102524215d02b5b3ebabddbacc09,Jonas Jenwald,Refactor the `OverlayManager`  to utilize `async` methods rather than manually returning `Promise`s,web/overlay_manager.js,https://github.com/mozilla/pdf.js/commit/64e70fc16ffb102524215d02b5b3ebabddbacc09,"  open(name) {

    return new Promise((resolve) => {

      if (!this._overlays[name]) {

        throw new Error('The overlay does not exist.');

      } else if (this._active) {

        if (this._overlays[name].canForceClose) {

          this._closeThroughCaller();

        } else if (this._active === name) {

          throw new Error('The overlay is already active.');

        } else {

          throw new Error('Another overlay is currently active.');

        }

      this._active = name;

      this._overlays[this._active].element.classList.remove('hidden');

      this._overlays[this._active].container.classList.remove('hidden');

      window.addEventListener('keydown', this._keyDownBound);

      resolve();

    });
","  async open(name) {

    if (!this._overlays[name]) {

      throw new Error('The overlay does not exist.');

    } else if (this._active) {

      if (this._overlays[name].canForceClose) {

        this._closeThroughCaller();

      } else if (this._active === name) {

        throw new Error('The overlay is already active.');

      } else {

        throw new Error('Another overlay is currently active.');

    }

    this._active = name;

    this._overlays[this._active].element.classList.remove('hidden');

    this._overlays[this._active].container.classList.remove('hidden');

    window.addEventListener('keydown', this._keyDownBound);
",2018-07-30 16:39:06+02:00
64e70fc16ffb102524215d02b5b3ebabddbacc09,Jonas Jenwald,Refactor the `OverlayManager`  to utilize `async` methods rather than manually returning `Promise`s,web/overlay_manager.js,https://github.com/mozilla/pdf.js/commit/64e70fc16ffb102524215d02b5b3ebabddbacc09,"  close(name) {

    return new Promise((resolve) => {

      if (!this._overlays[name]) {

        throw new Error('The overlay does not exist.');

      } else if (!this._active) {

        throw new Error('The overlay is currently not active.');

      } else if (this._active !== name) {

        throw new Error('Another overlay is currently active.');

      }

      this._overlays[this._active].container.classList.add('hidden');

      this._overlays[this._active].element.classList.add('hidden');

      this._active = null;

      window.removeEventListener('keydown', this._keyDownBound);

      resolve();

    });
","  async close(name) {

    if (!this._overlays[name]) {

      throw new Error('The overlay does not exist.');

    } else if (!this._active) {

      throw new Error('The overlay is currently not active.');

    } else if (this._active !== name) {

      throw new Error('Another overlay is currently active.');

    }

    this._overlays[this._active].container.classList.add('hidden');

    this._overlays[this._active].element.classList.add('hidden');

    this._active = null;

    window.removeEventListener('keydown', this._keyDownBound);
",2018-07-30 16:39:06+02:00
233b3274bf7973aa06a674dddef585f4313f3742,Jonas Jenwald,Refactor the `Preferences` classes to utilize `async` methods rather than manually returning `Promise`s,web/genericcom.js,https://github.com/mozilla/pdf.js/commit/233b3274bf7973aa06a674dddef585f4313f3742,"  _writeToStorage(prefObj) {

    return new Promise(function(resolve) {

      localStorage.setItem('pdfjs.preferences', JSON.stringify(prefObj));

      resolve();

    });

  _readFromStorage(prefObj) {

    return new Promise(function(resolve) {

      let readPrefs = JSON.parse(localStorage.getItem('pdfjs.preferences'));

      resolve(readPrefs);

    });
","  async _writeToStorage(prefObj) {

    localStorage.setItem('pdfjs.preferences', JSON.stringify(prefObj));

  async _readFromStorage(prefObj) {

    return JSON.parse(localStorage.getItem('pdfjs.preferences'));
",2018-07-30 16:48:16+02:00
233b3274bf7973aa06a674dddef585f4313f3742,Jonas Jenwald,Refactor the `Preferences` classes to utilize `async` methods rather than manually returning `Promise`s,web/preferences.js,https://github.com/mozilla/pdf.js/commit/233b3274bf7973aa06a674dddef585f4313f3742,"  reset() {

    return this._initializedPromise.then(() => {

      this.prefs = Object.assign(Object.create(null), this.defaults);

      return this._writeToStorage(this.defaults);

    });
","  async reset() {

    await this._initializedPromise;

    this.prefs = Object.assign(Object.create(null), this.defaults);

    return this._writeToStorage(this.defaults);
",2018-07-30 16:48:16+02:00
233b3274bf7973aa06a674dddef585f4313f3742,Jonas Jenwald,Refactor the `Preferences` classes to utilize `async` methods rather than manually returning `Promise`s,web/preferences.js,https://github.com/mozilla/pdf.js/commit/233b3274bf7973aa06a674dddef585f4313f3742,"  set(name, value) {

    return this._initializedPromise.then(() => {

      if (this.defaults[name] === undefined) {

        throw new Error(`Set preference: ""${name}"" is undefined.`);

      } else if (value === undefined) {

        throw new Error('Set preference: no value is specified.');

      }

      let valueType = typeof value;

      let defaultType = typeof this.defaults[name];

      if (valueType !== defaultType) {

        if (valueType === 'number' && defaultType === 'string') {

          value = value.toString();

        } else {

          throw new Error(`Set preference: ""${value}"" is a ${valueType}, ` +

                          `expected a ${defaultType}.`);

        }

        if (valueType === 'number' && !Number.isInteger(value)) {

          throw new Error(`Set preference: ""${value}"" must be an integer.`);

        }

      this.prefs[name] = value;

      return this._writeToStorage(this.prefs);

    });
","  async set(name, value) {

    await this._initializedPromise;

    let defaultValue = this.defaults[name];

    if (defaultValue === undefined) {

      throw new Error(`Set preference: ""${name}"" is undefined.`);

    } else if (value === undefined) {

      throw new Error('Set preference: no value is specified.');

    }

    let valueType = typeof value;

    let defaultType = typeof defaultValue;



    if (valueType !== defaultType) {

      if (valueType === 'number' && defaultType === 'string') {

        value = value.toString();

        throw new Error(`Set preference: ""${value}"" is a ${valueType}, ` +

                        `expected a ${defaultType}.`);

    } else {

      if (valueType === 'number' && !Number.isInteger(value)) {

        throw new Error(`Set preference: ""${value}"" must be an integer.`);

      }

    }

    this.prefs[name] = value;

    return this._writeToStorage(this.prefs);
",2018-07-30 16:48:16+02:00
233b3274bf7973aa06a674dddef585f4313f3742,Jonas Jenwald,Refactor the `Preferences` classes to utilize `async` methods rather than manually returning `Promise`s,web/preferences.js,https://github.com/mozilla/pdf.js/commit/233b3274bf7973aa06a674dddef585f4313f3742,"  get(name) {

    return this._initializedPromise.then(() => {

      let defaultValue = this.defaults[name];

      if (defaultValue === undefined) {

        throw new Error(`Get preference: ""${name}"" is undefined.`);

      } else {

        let prefValue = this.prefs[name];

        if (prefValue !== undefined) {

          return prefValue;

        }

      return defaultValue;

    });
","  async get(name) {

    await this._initializedPromise;

    let defaultValue = this.defaults[name];

    if (defaultValue === undefined) {

      throw new Error(`Get preference: ""${name}"" is undefined.`);

    } else {

      let prefValue = this.prefs[name];

      if (prefValue !== undefined) {

        return prefValue;

    }

    return defaultValue;
",2018-07-30 16:48:16+02:00
233b3274bf7973aa06a674dddef585f4313f3742,Jonas Jenwald,Refactor the `Preferences` classes to utilize `async` methods rather than manually returning `Promise`s,web/preferences.js,https://github.com/mozilla/pdf.js/commit/233b3274bf7973aa06a674dddef585f4313f3742,"  getAll() {

    return this._initializedPromise.then(() => {

      return Object.assign(Object.create(null), this.defaults, this.prefs);

    });
","  async getAll() {

    await this._initializedPromise;

    return Object.assign(Object.create(null), this.defaults, this.prefs);
",2018-07-30 16:48:16+02:00
a60963f88224235ff6e8847a019dfd93da203738,Jonas Jenwald,Refactor the `ViewHistory` to utilize `async` methods rather than manually returning `Promise`s,web/view_history.js,https://github.com/mozilla/pdf.js/commit/a60963f88224235ff6e8847a019dfd93da203738,"  _writeToStorage() {

    return new Promise((resolve) => {

      let databaseStr = JSON.stringify(this.database);

      if (typeof PDFJSDev !== 'undefined' &&

          PDFJSDev.test('FIREFOX || MOZCENTRAL')) {

        sessionStorage.setItem('pdfjs.history', databaseStr);

      } else {

        localStorage.setItem('pdfjs.history', databaseStr);

      }

      resolve();

    });

  _readFromStorage() {

    return new Promise(function(resolve) {

      if (typeof PDFJSDev !== 'undefined' &&

          PDFJSDev.test('FIREFOX || MOZCENTRAL')) {

        resolve(sessionStorage.getItem('pdfjs.history'));

      } else {

        resolve(localStorage.getItem('pdfjs.history'));

      }

    });

  set(name, val) {

    return this._initializedPromise.then(() => {

      this.file[name] = val;

      return this._writeToStorage();

    });

  setMultiple(properties) {

    return this._initializedPromise.then(() => {

      for (let name in properties) {

        this.file[name] = properties[name];

      }

      return this._writeToStorage();

    });

  get(name, defaultValue) {

    return this._initializedPromise.then(() => {

      let val = this.file[name];

      return val !== undefined ? val : defaultValue;

    });

  getMultiple(properties) {

    return this._initializedPromise.then(() => {

      let values = Object.create(null);

      for (let name in properties) {

        let val = this.file[name];

        values[name] = val !== undefined ? val : properties[name];

      }

      return values;

    });
","  async _writeToStorage() {

    let databaseStr = JSON.stringify(this.database);

    if (typeof PDFJSDev !== 'undefined' &&

        PDFJSDev.test('FIREFOX || MOZCENTRAL')) {

      sessionStorage.setItem('pdfjs.history', databaseStr);

      return;

    }

    localStorage.setItem('pdfjs.history', databaseStr);

  async _readFromStorage() {

    if (typeof PDFJSDev !== 'undefined' &&

        PDFJSDev.test('FIREFOX || MOZCENTRAL')) {

      return sessionStorage.getItem('pdfjs.history');

    }

    return localStorage.getItem('pdfjs.history');

  async set(name, val) {

    await this._initializedPromise;

    this.file[name] = val;

    return this._writeToStorage();

  async setMultiple(properties) {

    await this._initializedPromise;

    for (let name in properties) {

      this.file[name] = properties[name];

    }

    return this._writeToStorage();

  async get(name, defaultValue) {

    await this._initializedPromise;

    let val = this.file[name];

    return val !== undefined ? val : defaultValue;

  async getMultiple(properties) {

    await this._initializedPromise;

    let values = Object.create(null);

    for (let name in properties) {

      let val = this.file[name];

      values[name] = val !== undefined ? val : properties[name];

    }

    return values;
",2018-07-30 17:07:21+02:00
3eba7ea2673828865081d0f188477351803235f5,Jonas Jenwald,"Refactor a number of methods in `PDFViewerApplication` to be `async` rather than manually returning `Promise`s

*Ignoring whitespace changes is probably necessary, in order for the diff to be readable.*",web/app.js,https://github.com/mozilla/pdf.js/commit/3eba7ea2673828865081d0f188477351803235f5,"    return this.preferences.getAll().then(function(prefs) {

    }, function(reason) { });

  _parseHashParameters() {

    if (typeof PDFJSDev === 'undefined' || !PDFJSDev.test('PRODUCTION') ||

        AppOptions.get('pdfBugEnabled')) {

      // Special debugging flags in the hash section of the URL.

      let hash = document.location.hash.substring(1);

      let hashParams = parseQueryString(hash);

      if ('disableworker' in hashParams &&

          hashParams['disableworker'] === 'true') {

        waitOn.push(loadFakeWorker());

      }

      if ('disablerange' in hashParams) {

        AppOptions.set('disableRange', hashParams['disablerange'] === 'true');

      }

      if ('disablestream' in hashParams) {

        AppOptions.set('disableStream', hashParams['disablestream'] === 'true');

      }

      if ('disableautofetch' in hashParams) {

        AppOptions.set('disableAutoFetch',

                       hashParams['disableautofetch'] === 'true');

      }

      if ('disablefontface' in hashParams) {

        AppOptions.set('disableFontFace',

                       hashParams['disablefontface'] === 'true');

      }

      if ('disablehistory' in hashParams) {

        AppOptions.set('disableHistory',

                       hashParams['disablehistory'] === 'true');

      }

      if ('webgl' in hashParams) {

        AppOptions.set('enableWebGL', hashParams['webgl'] === 'true');

      }

      if ('useonlycsszoom' in hashParams) {

        AppOptions.set('useOnlyCssZoom',

                       hashParams['useonlycsszoom'] === 'true');

      }

      if ('verbosity' in hashParams) {

        AppOptions.set('verbosity', hashParams['verbosity'] | 0);

      }

      if ((typeof PDFJSDev === 'undefined' || !PDFJSDev.test('PRODUCTION')) &&

          hashParams['disablebcmaps'] === 'true') {

        AppOptions.set('cMapUrl', '../external/cmaps/');

        AppOptions.set('cMapPacked', false);

      }

      if ('textlayer' in hashParams) {

        switch (hashParams['textlayer']) {

          case 'off':

            AppOptions.set('textLayerMode', TextLayerMode.DISABLE);

            break;

          case 'visible':

          case 'shadow':

          case 'hover':

            let viewer = this.appConfig.viewerContainer;

            viewer.classList.add('textLayer-' + hashParams['textlayer']);

            break;

        }

      }

      if ('pdfbug' in hashParams) {

        AppOptions.set('pdfBug', true);

        let enabled = hashParams['pdfbug'].split(',');

        waitOn.push(loadAndEnablePDFBug(enabled));

      }

      // It is not possible to change locale for the (various) extension builds.

      if ((typeof PDFJSDev === 'undefined' ||

           PDFJSDev.test('!PRODUCTION || GENERIC')) && 'locale' in hashParams) {

        AppOptions.set('locale', hashParams['locale']);
","    try {

      const prefs = await this.preferences.getAll();

    } catch (reason) { }

  async _parseHashParameters() {

    if (typeof PDFJSDev !== 'undefined' && PDFJSDev.test('PRODUCTION') &&

        !AppOptions.get('pdfBugEnabled')) {

      return;

    }

    // Special debugging flags in the hash section of the URL.

    let hash = document.location.hash.substring(1);

    let hashParams = parseQueryString(hash);

    if ('disableworker' in hashParams &&

        hashParams['disableworker'] === 'true') {

      waitOn.push(loadFakeWorker());

    }

    if ('disablerange' in hashParams) {

      AppOptions.set('disableRange', hashParams['disablerange'] === 'true');

    }

    if ('disablestream' in hashParams) {

      AppOptions.set('disableStream', hashParams['disablestream'] === 'true');

    }

    if ('disableautofetch' in hashParams) {

      AppOptions.set('disableAutoFetch',

                     hashParams['disableautofetch'] === 'true');

    }

    if ('disablefontface' in hashParams) {

      AppOptions.set('disableFontFace',

                     hashParams['disablefontface'] === 'true');

    }

    if ('disablehistory' in hashParams) {

      AppOptions.set('disableHistory', hashParams['disablehistory'] === 'true');

    }

    if ('webgl' in hashParams) {

      AppOptions.set('enableWebGL', hashParams['webgl'] === 'true');

    }

    if ('useonlycsszoom' in hashParams) {

      AppOptions.set('useOnlyCssZoom', hashParams['useonlycsszoom'] === 'true');

    }

    if ('verbosity' in hashParams) {

      AppOptions.set('verbosity', hashParams['verbosity'] | 0);

    }

    if ((typeof PDFJSDev === 'undefined' || !PDFJSDev.test('PRODUCTION')) &&

        hashParams['disablebcmaps'] === 'true') {

      AppOptions.set('cMapUrl', '../external/cmaps/');

      AppOptions.set('cMapPacked', false);

    }

    if ('textlayer' in hashParams) {

      switch (hashParams['textlayer']) {

        case 'off':

          AppOptions.set('textLayerMode', TextLayerMode.DISABLE);

          break;

        case 'visible':

        case 'shadow':

        case 'hover':

          let viewer = this.appConfig.viewerContainer;

          viewer.classList.add('textLayer-' + hashParams['textlayer']);

          break;

    if ('pdfbug' in hashParams) {

      AppOptions.set('pdfBug', true);

      let enabled = hashParams['pdfbug'].split(',');

      waitOn.push(loadAndEnablePDFBug(enabled));

    }

    // It is not possible to change locale for the (various) extension builds.

    if ((typeof PDFJSDev === 'undefined' ||

         PDFJSDev.test('!PRODUCTION || GENERIC')) && 'locale' in hashParams) {

      AppOptions.set('locale', hashParams['locale']);

    }
",2018-07-30 17:41:39+02:00
3eba7ea2673828865081d0f188477351803235f5,Jonas Jenwald,"Refactor a number of methods in `PDFViewerApplication` to be `async` rather than manually returning `Promise`s

*Ignoring whitespace changes is probably necessary, in order for the diff to be readable.*",web/app.js,https://github.com/mozilla/pdf.js/commit/3eba7ea2673828865081d0f188477351803235f5,"  _initializeL10n() {

    return this.l10n.getDirection().then((dir) => {

      document.getElementsByTagName('html')[0].dir = dir;

    });

  _initializeViewerComponents() {

    let { appConfig, } = this;



    return new Promise((resolve, reject) => {

      this.overlayManager = new OverlayManager();



      const dispatchToDOM = AppOptions.get('eventBusDispatchToDOM');

      let eventBus = appConfig.eventBus || getGlobalEventBus(dispatchToDOM);

      this.eventBus = eventBus;

      let pdfRenderingQueue = new PDFRenderingQueue();

      pdfRenderingQueue.onIdle = this.cleanup.bind(this);

      this.pdfRenderingQueue = pdfRenderingQueue;

      let pdfLinkService = new PDFLinkService({

        eventBus,

        externalLinkTarget: AppOptions.get('externalLinkTarget'),

        externalLinkRel: AppOptions.get('externalLinkRel'),

      });

      this.pdfLinkService = pdfLinkService;

      let downloadManager = this.externalServices.createDownloadManager({

        disableCreateObjectURL: AppOptions.get('disableCreateObjectURL'),

      });

      this.downloadManager = downloadManager;

      let container = appConfig.mainContainer;

      let viewer = appConfig.viewerContainer;

      this.pdfViewer = new PDFViewer({

        container,

        viewer,

        eventBus,

        renderingQueue: pdfRenderingQueue,

        linkService: pdfLinkService,

        downloadManager,

        renderer: AppOptions.get('renderer'),

        enableWebGL: AppOptions.get('enableWebGL'),

        l10n: this.l10n,

        textLayerMode: AppOptions.get('textLayerMode'),

        imageResourcesPath: AppOptions.get('imageResourcesPath'),

        renderInteractiveForms: AppOptions.get('renderInteractiveForms'),

        enablePrintAutoRotate: AppOptions.get('enablePrintAutoRotate'),

        useOnlyCssZoom: AppOptions.get('useOnlyCssZoom'),

        maxCanvasPixels: AppOptions.get('maxCanvasPixels'),

      });

      pdfRenderingQueue.setViewer(this.pdfViewer);

      pdfLinkService.setViewer(this.pdfViewer);



      let thumbnailContainer = appConfig.sidebar.thumbnailView;

      this.pdfThumbnailViewer = new PDFThumbnailViewer({

        container: thumbnailContainer,

        renderingQueue: pdfRenderingQueue,

        linkService: pdfLinkService,

        l10n: this.l10n,

      });

      pdfRenderingQueue.setThumbnailViewer(this.pdfThumbnailViewer);



      this.pdfHistory = new PDFHistory({

        linkService: pdfLinkService,

        eventBus,

      });

      pdfLinkService.setHistory(this.pdfHistory);

      this.findController = new PDFFindController({

        pdfViewer: this.pdfViewer,

        eventBus,

      });

      this.findController.onUpdateResultsCount = (matchCount) => {

        if (this.supportsIntegratedFind) {

          return;

        }

        this.findBar.updateResultsCount(matchCount);

      };

      this.findController.onUpdateState = (state, previous, matchCount) => {

        if (this.supportsIntegratedFind) {

          this.externalServices.updateFindControlState({

            result: state,

            findPrevious: previous,

          });

        } else {

          this.findBar.updateUIState(state, previous, matchCount);

        }

      };

      this.pdfViewer.setFindController(this.findController);

      // TODO: improve `PDFFindBar` constructor parameter passing

      let findBarConfig = Object.create(appConfig.findBar);

      findBarConfig.findController = this.findController;

      findBarConfig.eventBus = eventBus;

      this.findBar = new PDFFindBar(findBarConfig, this.l10n);

      this.pdfDocumentProperties =

        new PDFDocumentProperties(appConfig.documentProperties,

                                  this.overlayManager, eventBus, this.l10n);

      this.pdfCursorTools = new PDFCursorTools({

        container,

        eventBus,

        cursorToolOnLoad: AppOptions.get('cursorToolOnLoad'),

      });

      this.toolbar = new Toolbar(appConfig.toolbar, container, eventBus,

                                 this.l10n);

      this.secondaryToolbar =

        new SecondaryToolbar(appConfig.secondaryToolbar, container, eventBus);

      if (this.supportsFullscreen) {

        this.pdfPresentationMode = new PDFPresentationMode({

          container,

          viewer,

          pdfViewer: this.pdfViewer,

          eventBus,

          contextMenuItems: appConfig.fullscreen,

        });

      }

      this.passwordPrompt = new PasswordPrompt(appConfig.passwordOverlay,

                                               this.overlayManager, this.l10n);

      this.pdfOutlineViewer = new PDFOutlineViewer({

        container: appConfig.sidebar.outlineView,

        linkService: pdfLinkService,

      this.pdfAttachmentViewer = new PDFAttachmentViewer({

        container: appConfig.sidebar.attachmentsView,

        eventBus,

        downloadManager,

      });

      // TODO: improve `PDFSidebar` constructor parameter passing

      let sidebarConfig = Object.create(appConfig.sidebar);

      sidebarConfig.pdfViewer = this.pdfViewer;

      sidebarConfig.pdfThumbnailViewer = this.pdfThumbnailViewer;

      sidebarConfig.pdfOutlineViewer = this.pdfOutlineViewer;

      sidebarConfig.eventBus = eventBus;

      this.pdfSidebar = new PDFSidebar(sidebarConfig, this.l10n);

      this.pdfSidebar.onToggled = this.forceRendering.bind(this);



      this.pdfSidebarResizer = new PDFSidebarResizer(appConfig.sidebarResizer,

                                                     eventBus, this.l10n);

      resolve(undefined);
","  async _initializeL10n() {

    const dir = await this.l10n.getDirection();

    document.getElementsByTagName('html')[0].dir = dir;

  async _initializeViewerComponents() {

    const appConfig = this.appConfig;

    this.overlayManager = new OverlayManager();

    const dispatchToDOM = AppOptions.get('eventBusDispatchToDOM');

    let eventBus = appConfig.eventBus || getGlobalEventBus(dispatchToDOM);

    this.eventBus = eventBus;

    let pdfRenderingQueue = new PDFRenderingQueue();

    pdfRenderingQueue.onIdle = this.cleanup.bind(this);

    this.pdfRenderingQueue = pdfRenderingQueue;

    let pdfLinkService = new PDFLinkService({

      eventBus,

      externalLinkTarget: AppOptions.get('externalLinkTarget'),

      externalLinkRel: AppOptions.get('externalLinkRel'),

    });

    this.pdfLinkService = pdfLinkService;

    let downloadManager = this.externalServices.createDownloadManager({

      disableCreateObjectURL: AppOptions.get('disableCreateObjectURL'),

    });

    this.downloadManager = downloadManager;



    let container = appConfig.mainContainer;

    let viewer = appConfig.viewerContainer;

    this.pdfViewer = new PDFViewer({

      container,

      viewer,

      eventBus,

      renderingQueue: pdfRenderingQueue,

      linkService: pdfLinkService,

      downloadManager,

      renderer: AppOptions.get('renderer'),

      enableWebGL: AppOptions.get('enableWebGL'),

      l10n: this.l10n,

      textLayerMode: AppOptions.get('textLayerMode'),

      imageResourcesPath: AppOptions.get('imageResourcesPath'),

      renderInteractiveForms: AppOptions.get('renderInteractiveForms'),

      enablePrintAutoRotate: AppOptions.get('enablePrintAutoRotate'),

      useOnlyCssZoom: AppOptions.get('useOnlyCssZoom'),

      maxCanvasPixels: AppOptions.get('maxCanvasPixels'),

    });

    pdfRenderingQueue.setViewer(this.pdfViewer);

    pdfLinkService.setViewer(this.pdfViewer);



    let thumbnailContainer = appConfig.sidebar.thumbnailView;

    this.pdfThumbnailViewer = new PDFThumbnailViewer({

      container: thumbnailContainer,

      renderingQueue: pdfRenderingQueue,

      linkService: pdfLinkService,

      l10n: this.l10n,

    });

    pdfRenderingQueue.setThumbnailViewer(this.pdfThumbnailViewer);

    this.pdfHistory = new PDFHistory({

      linkService: pdfLinkService,

      eventBus,

    });

    pdfLinkService.setHistory(this.pdfHistory);

    this.findController = new PDFFindController({

      pdfViewer: this.pdfViewer,

      eventBus,

    });

    this.findController.onUpdateResultsCount = (matchCount) => {

      if (this.supportsIntegratedFind) {

        return;

      }

      this.findBar.updateResultsCount(matchCount);

    };

    this.findController.onUpdateState = (state, previous, matchCount) => {

      if (this.supportsIntegratedFind) {

        this.externalServices.updateFindControlState({

          result: state,

          findPrevious: previous,

        });

      } else {

        this.findBar.updateUIState(state, previous, matchCount);

      }

    };

    this.pdfViewer.setFindController(this.findController);

    // TODO: improve `PDFFindBar` constructor parameter passing

    let findBarConfig = Object.create(appConfig.findBar);

    findBarConfig.findController = this.findController;

    findBarConfig.eventBus = eventBus;

    this.findBar = new PDFFindBar(findBarConfig, this.l10n);

    this.pdfDocumentProperties =

      new PDFDocumentProperties(appConfig.documentProperties,

                                this.overlayManager, eventBus, this.l10n);

    this.pdfCursorTools = new PDFCursorTools({

      container,

      eventBus,

      cursorToolOnLoad: AppOptions.get('cursorToolOnLoad'),

    });

    this.toolbar = new Toolbar(appConfig.toolbar, container, eventBus,

                               this.l10n);

    this.secondaryToolbar =

      new SecondaryToolbar(appConfig.secondaryToolbar, container, eventBus);

    if (this.supportsFullscreen) {

      this.pdfPresentationMode = new PDFPresentationMode({

        container,

        viewer,

        pdfViewer: this.pdfViewer,

        contextMenuItems: appConfig.fullscreen,

    }

    this.passwordPrompt = new PasswordPrompt(appConfig.passwordOverlay,

                                             this.overlayManager, this.l10n);



    this.pdfOutlineViewer = new PDFOutlineViewer({

      container: appConfig.sidebar.outlineView,

      eventBus,

      linkService: pdfLinkService,

    });

    this.pdfAttachmentViewer = new PDFAttachmentViewer({

      container: appConfig.sidebar.attachmentsView,

      eventBus,

      downloadManager,



    // TODO: improve `PDFSidebar` constructor parameter passing

    let sidebarConfig = Object.create(appConfig.sidebar);

    sidebarConfig.pdfViewer = this.pdfViewer;

    sidebarConfig.pdfThumbnailViewer = this.pdfThumbnailViewer;

    sidebarConfig.pdfOutlineViewer = this.pdfOutlineViewer;

    sidebarConfig.eventBus = eventBus;

    this.pdfSidebar = new PDFSidebar(sidebarConfig, this.l10n);

    this.pdfSidebar.onToggled = this.forceRendering.bind(this);



    this.pdfSidebarResizer = new PDFSidebarResizer(appConfig.sidebarResizer,

                                                   eventBus, this.l10n);
",2018-07-30 17:41:39+02:00
3eba7ea2673828865081d0f188477351803235f5,Jonas Jenwald,"Refactor a number of methods in `PDFViewerApplication` to be `async` rather than manually returning `Promise`s

*Ignoring whitespace changes is probably necessary, in order for the diff to be readable.*",web/app.js,https://github.com/mozilla/pdf.js/commit/3eba7ea2673828865081d0f188477351803235f5,"  open(file, args) {

      return this.close().then(() => {

        // ... and repeat the open() call.

        return this.open(file, args);

      });
","  async open(file, args) {

      await this.close();
",2018-07-30 17:41:39+02:00
1bdfdd07b822827856bff4cea9f779010c510b7f,Jonas Jenwald,Utilize `async`/`await` in `PDFViewerApplication.load` to reduce the number of Promises and temporary variables necessary when setting the initial document location,web/app.js,https://github.com/mozilla/pdf.js/commit/1bdfdd07b822827856bff4cea9f779010c510b7f,"        return {

          hash,

          rotation,

          sidebarView,

          scrollMode,

          spreadMode,

        };

      }).then(({ hash, rotation, sidebarView, scrollMode, spreadMode, }) => {

        initialParams.bookmark = this.initialBookmark;

        initialParams.hash = hash;



        return Promise.race([

      }).then(() => {

        // For documents with different page sizes, once all pages are resolved,

        // ensure that the correct location becomes visible on load.

        // To reduce the risk, in very large and/or slow loading documents,

        // that the location changes *after* the user has started interacting

        // with the viewer, wait for either `pagesPromise` or a timeout above.



        if (!initialParams.bookmark && !initialParams.hash) {

        this.initialBookmark = initialParams.bookmark;

        this.setInitialView(initialParams.hash);
","        // For documents with different page sizes, once all pages are resolved,

        // ensure that the correct location becomes visible on load.

        // (To reduce the risk, in very large and/or slow loading documents,

        //  that the location changes *after* the user has started interacting

        //  with the viewer, wait for either `pagesPromise` or a timeout.)

        await Promise.race([

        if (!initialBookmark && !hash) {

        this.initialBookmark = initialBookmark;

        // Re-apply the initial document location.

        this.setInitialView(hash);
",2018-08-09 15:15:41+02:00
2c003a82d57b5ad778fbf221a86f1d1408c02952,Jonas Jenwald,"Convert `RenderTask`, in `src/display/api.js`, to an ES6 class

Also deprecates the `then` method, in favour of the `promise` getter.",test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/2c003a82d57b5ad778fbf221a86f1d1408c02952,"    function renderPDF(filename) {

      var loadingTask = getDocument(filename);

      return loadingTask.promise

        .then(function(pdf) {

          pdfDocuments.push(pdf);

          return pdf.getPage(1);

        }).then(function(page) {

          var viewport = page.getViewport(1.2);

          var canvasAndCtx = CanvasFactory.create(viewport.width,

                                                  viewport.height);

          return page.render({

            canvasContext: canvasAndCtx.context,

            viewport,

          }).then(function() {

            var data = canvasAndCtx.canvas.toDataURL();

            CanvasFactory.destroy(canvasAndCtx);

            return data;

          });

        });
","    async function renderPDF(filename) {

      const loadingTask = getDocument(filename);

      const pdf = await loadingTask.promise;

      pdfDocuments.push(pdf);

      const page = await pdf.getPage(1);

      const viewport = page.getViewport(1.2);

      const canvasAndCtx = CanvasFactory.create(viewport.width,

                                                viewport.height);

      const renderTask = page.render({

        canvasContext: canvasAndCtx.context,

        viewport,

      });

      await renderTask.promise;

      const data = canvasAndCtx.canvas.toDataURL();

      CanvasFactory.destroy(canvasAndCtx);

      return data;
",2018-11-08 13:46:02+01:00
02e77a39ec68247c619a6f67d9b8432ad40a50bc,Jonas Jenwald,"Convert `InternalRenderTask`, in `src/display/api.js`, to an ES6 class

This changes all occurrences of `var` to `let`/`const` in this code, and updates the signature of the constructor to use object destructuring for better readability (and self documentation).
Also, `useRequestAnimationFrame` is changed to a parameter and the `typeof window` check is now done *once* rather than at every `_scheduleNext` call.",src/display/api.js,https://github.com/mozilla/pdf.js/commit/02e77a39ec68247c619a6f67d9b8432ad40a50bc,"    },

    _scheduleNext: function InternalRenderTask__scheduleNext() {

      if (this.useRequestAnimationFrame && typeof window !== 'undefined') {

    },

    _next: function InternalRenderTask__next() {

      return new Promise(() => {

        if (this.cancelled) {

          return;

        }

        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList,

                                          this.operatorListIdx,

                                          this._continueBound,

                                          this.stepper);

        if (this.operatorListIdx === this.operatorList.argsArray.length) {

          this.running = false;

          if (this.operatorList.lastChunk) {

            this.gfx.endDrawing();

            if (this._canvas) {

              canvasInRendering.delete(this._canvas);

            }

            this.callback();

      });

    },



  };


","    }

    _scheduleNext() {

      if (this._useRequestAnimationFrame) {

    }

    async _next() {

      if (this.cancelled) {

        return;

      }

      this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList,

                                                          this.operatorListIdx,

                                                          this._continueBound,

                                                          this.stepper);

      if (this.operatorListIdx === this.operatorList.argsArray.length) {

        this.running = false;

        if (this.operatorList.lastChunk) {

          this.gfx.endDrawing();

          if (this._canvas) {

            canvasInRendering.delete(this._canvas);

          this.callback();

      }

    }

  }
",2018-11-08 14:33:56+01:00
60bcce184ee74dc56d682a4c75ccdea69cd0670e,Jonas Jenwald,"Check that the first page can be successfully loaded, to try and ascertain the validity of the XRef table (issue 7496, issue 10326)

For PDF documents with sufficiently broken XRef tables, it's usually quite obvious when you need to fallback to indexing the entire file. However, for certain kinds of corrupted PDF documents the XRef table will, for all intents and purposes, appear to be valid. It's not until you actually try to fetch various objects that things will start to break, which is the case in the referenced issues[1].

Since there's generally a real effort being in made PDF.js to load even corrupt PDF documents, this patch contains a suggested approach to attempt to do a bit more validation of the XRef table during the initial document loading phase.

Here the choice is made to attempt to load the *first* page, as a basic sanity check of the validity of the XRef table. Please note that attempting to load a more-or-less arbitrarily chosen object without any context of what it's supposed to be isn't a very useful, which is why this particular choice was made.
Obviously, just because the first page can be loaded successfully that doesn't guarantee that the *entire* XRef table is valid, however if even the first page fails to load you can be reasonably sure that the document is *not* valid[2].

Even though this patch won't cause any significant increase in the amount of parsing required during initial loading of the document[3], it will require loading of more data upfront which thus delays the initial `getDocument` call.
Whether or not this is a problem depends very much on what you actually measure, please consider the following examples:

```javascript
console.time('first');
getDocument(...).promise.then((pdfDocument) => {
  console.timeEnd('first');
});

console.time('second');
getDocument(...).promise.then((pdfDocument) => {
  pdfDocument.getPage(1).then((pdfPage) => { // Note: the API uses `pageNumber >= 1`, the Worker uses `pageIndex >= 0`.
    console.timeEnd('second');
  });
});
```

The first case is pretty much guaranteed to show a small regression, however the second case won't be affected at all since the Worker caches the result of `getPage` calls. Again, please remember that the second case is what matters for the standard PDF.js use-case which is why I'm hoping that this patch is deemed acceptable.

---
[1] In issue 7496, the problem is that the document is edited without the XRef table being correctly updated.
In issue 10326, the generator was sorting the XRef table according to the offsets rather than the objects.

[2] The idea of checking the first page in particular came from the ""standard"" use-case for the PDF.js library, i.e. the default viewer, where a failure to load the first page basically means that nothing will work; note how `{BaseViewer, PDFThumbnailViewer}.setDocument` depends completely on being able to fetch the *first* page.

[3] The only extra parsing is caused by, potentially, having to traverse *part* of the `Pages` tree to find the first page.",src/core/worker.js,https://github.com/mozilla/pdf.js/commit/60bcce184ee74dc56d682a4c75ccdea69cd0670e,"    function loadDocument(recoveryMode) {

      var loadDocumentCapability = createPromiseCapability();



      var parseSuccess = function parseSuccess() {

        Promise.all([

          pdfManager.ensureDoc('numPages'),

          pdfManager.ensureDoc('fingerprint'),

        ]).then(function([numPages, fingerprint]) {

          loadDocumentCapability.resolve({

            numPages,

            fingerprint,

          });

        }, parseFailure);

      };



      var parseFailure = function parseFailure(e) {

        loadDocumentCapability.reject(e);

      };



      pdfManager.ensureDoc('checkHeader', []).then(function() {

        pdfManager.ensureDoc('parseStartXRef', []).then(function() {

          pdfManager.ensureDoc('parse', [recoveryMode]).then(

            parseSuccess, parseFailure);

        }, parseFailure);

      }, parseFailure);

      return loadDocumentCapability.promise;
","    async function loadDocument(recoveryMode) {

      await pdfManager.ensureDoc('checkHeader');

      await pdfManager.ensureDoc('parseStartXRef');

      await pdfManager.ensureDoc('parse', [recoveryMode]);



      if (!recoveryMode) {

        // Check that at least the first page can be successfully loaded,

        // since otherwise the XRef table is definitely not valid.

        await pdfManager.ensureDoc('checkFirstPage');

      }

      const [numPages, fingerprint] = await Promise.all([

        pdfManager.ensureDoc('numPages'),

        pdfManager.ensureDoc('fingerprint'),

      ]);

      return { numPages, fingerprint, };
",2018-12-04 21:51:27+01:00
04497bcb3c8df5a04565ef60a37245d73a17b4e1,Jonas Jenwald,"Re-factor the `ObjectLoader._walk` method to be properly asynchronous

Rather than having to store a `PromiseCapability` on the `ObjectLoader` instances, we can simply convert `_walk` to be `async` and thus have the same functionality with native JavaScript instead.",src/core/obj.js,https://github.com/mozilla/pdf.js/commit/04497bcb3c8df5a04565ef60a37245d73a17b4e1,"        this.xref.stream.manager.requestRanges(pendingRequests).then(() => {

          for (let i = 0, ii = nodesToRevisit.length; i < ii; i++) {

            let node = nodesToRevisit[i];

            // Remove any reference nodes from the current `RefSet` so they

            // aren't skipped when we revist them.

            if (node instanceof Ref) {

              this.refSet.remove(node);

            }

          this._walk(nodesToRevisit);

        }, this.capability.reject);

        return;

      this.capability.resolve();
","        await this.xref.stream.manager.requestRanges(pendingRequests);



        for (let i = 0, ii = nodesToRevisit.length; i < ii; i++) {

          let node = nodesToRevisit[i];

          // Remove any reference nodes from the current `RefSet` so they

          // aren't skipped when we revist them.

          if (node instanceof Ref) {

            this.refSet.remove(node);

        }

        return this._walk(nodesToRevisit);

      return undefined;
",2019-11-03 14:58:40+01:00
0d89006bf16b7262fe6aceb35557a9b54e3ec396,Jonas Jenwald,"Convert `Catalog.getPageDict` to an `async` method

This makes it possible to remove the internal `next` helper function, and also gets rid of the need to manually resolve/reject a `PromiseCapability`.",src/core/obj.js,https://github.com/mozilla/pdf.js/commit/0d89006bf16b7262fe6aceb35557a9b54e3ec396,"  getPageDict(pageIndex) {

    const capability = createPromiseCapability();

    function next() {

      while (nodesToVisit.length) {

        const currentNode = nodesToVisit.pop();

        if (isRef(currentNode)) {

          count = pageKidsCountCache.get(currentNode);

          // Skip nodes where the page can't be.

          if (count > 0 && currentPageIndex + count < pageIndex) {

            currentPageIndex += count;

            continue;

          }

          xref.fetchAsync(currentNode).then(function(obj) {

            if (isDict(obj, 'Page') || (isDict(obj) && !obj.has('Kids'))) {

              if (pageIndex === currentPageIndex) {

                // Cache the Page reference, since it can *greatly* improve

                // performance by reducing redundant lookups in long documents

                // where all nodes are found at *one* level of the tree.

                if (currentNode && !pageKidsCountCache.has(currentNode)) {

                  pageKidsCountCache.put(currentNode, 1);

                }

                capability.resolve([obj, currentNode]);

              } else {

                currentPageIndex++;

                next();

              }

              return;

            nodesToVisit.push(obj);

            next();

          }, capability.reject);

          return;

        // Must be a child page dictionary.

        if (!isDict(currentNode)) {

          capability.reject(new FormatError(

            'Page dictionary kid reference points to wrong type of object.'));

          return;

        }

        count = currentNode.get('Count');

        if (Number.isInteger(count) && count >= 0) {

          // Cache the Kids count, since it can reduce redundant lookups in

          // documents where all nodes are found at *one* level of the tree.

          const objId = currentNode.objId;

          if (objId && !pageKidsCountCache.has(objId)) {

            pageKidsCountCache.put(objId, count);

          }

          // Skip nodes where the page can't be.

          if (currentPageIndex + count <= pageIndex) {

            currentPageIndex += count;

            continue;

          }

        const kids = currentNode.get('Kids');

        if (!Array.isArray(kids)) {

          // Prevent errors in corrupt PDF documents that violate the

          // specification by *inlining* Page dicts directly in the Kids

          // array, rather than using indirect objects (fixes issue9540.pdf).

          if (isName(currentNode.get('Type'), 'Page') ||

              (!currentNode.has('Type') && currentNode.has('Contents'))) {

            if (currentPageIndex === pageIndex) {

              capability.resolve([currentNode, null]);

              return;

            }

            currentPageIndex++;

            continue;



          capability.reject(new FormatError(

            'Page dictionary kids object is not an array.'));

          return;

        // Always check all `Kids` nodes, to avoid getting stuck in an empty

        // node further down in the tree (see issue5644.pdf, issue8088.pdf),

        // and to ensure that we actually find the correct `Page` dict.

        for (let last = kids.length - 1; last >= 0; last--) {

          nodesToVisit.push(kids[last]);

        }

      capability.reject(new Error(`Page index ${pageIndex} not found.`));

    next();

    return capability.promise;
","  async getPageDict(pageIndex) {

    while (nodesToVisit.length) {

      const currentNode = nodesToVisit.pop();

      if (isRef(currentNode)) {

        count = pageKidsCountCache.get(currentNode);

        // Skip nodes where the page can't be.

        if (count > 0 && currentPageIndex + count < pageIndex) {

          currentPageIndex += count;

          continue;

        }

        const obj = await xref.fetchAsync(currentNode);

        if (isDict(obj, 'Page') || (isDict(obj) && !obj.has('Kids'))) {

          if (pageIndex === currentPageIndex) {

            // Cache the Page reference, since it can *greatly* improve

            // performance by reducing redundant lookups in long documents

            // where all nodes are found at *one* level of the tree.

            if (currentNode && !pageKidsCountCache.has(currentNode)) {

              pageKidsCountCache.put(currentNode, 1);

            return [obj, currentNode];

          }

          currentPageIndex++;

          continue;

        nodesToVisit.push(obj);

        continue;

      }

      // Must be a child page dictionary.

      if (!isDict(currentNode)) {

        throw new FormatError(

          'Page dictionary kid reference points to wrong type of object.');

      }

      count = currentNode.get('Count');

      if (Number.isInteger(count) && count >= 0) {

        // Cache the Kids count, since it can reduce redundant lookups in

        // documents where all nodes are found at *one* level of the tree.

        const objId = currentNode.objId;

        if (objId && !pageKidsCountCache.has(objId)) {

          pageKidsCountCache.put(objId, count);

        // Skip nodes where the page can't be.

        if (currentPageIndex + count <= pageIndex) {

          currentPageIndex += count;

          continue;

        }

      }

      const kids = currentNode.get('Kids');

      if (!Array.isArray(kids)) {

        // Prevent errors in corrupt PDF documents that violate the

        // specification by *inlining* Page dicts directly in the Kids

        // array, rather than using indirect objects (fixes issue9540.pdf).

        if (isName(currentNode.get('Type'), 'Page') ||

            (!currentNode.has('Type') && currentNode.has('Contents'))) {

          if (currentPageIndex === pageIndex) {

            return [currentNode, null];

          currentPageIndex++;

          continue;

        throw new FormatError('Page dictionary kids object is not an array.');

      }

      // Always check all `Kids` nodes, to avoid getting stuck in an empty

      // node further down in the tree (see issue5644.pdf, issue8088.pdf),

      // and to ensure that we actually find the correct `Page` dict.

      for (let last = kids.length - 1; last >= 0; last--) {

        nodesToVisit.push(kids[last]);

    throw new Error(`Page index ${pageIndex} not found.`);
",2019-11-04 16:02:08+01:00
8519f87efb3a24b1a8a9f03e2e8d0728a7cd642d,Jonas Jenwald,"Re-factor the `setupFakeWorkerGlobal` function (in `src/display/api.js`), and the `loadFakeWorker` function (in `web/app.js`)

This patch reduces some duplication, by moving *all* fake worker loader code into the `setupFakeWorkerGlobal` function. Furthermore, the functions are simplified further by using `async`/`await` where appropriate.",web/app.js,https://github.com/mozilla/pdf.js/commit/8519f87efb3a24b1a8a9f03e2e8d0728a7cd642d,"function loadFakeWorker() {

    return new Promise(function(resolve, reject) {

      if (typeof SystemJS === 'object') {

        SystemJS.import('pdfjs/core/worker').then((worker) => {

          window.pdfjsWorker = worker;

          resolve();

        }).catch(reject);

      } else {

        reject(new Error('SystemJS must be used to load fake worker.'));

      }

    });
","async function loadFakeWorker() {

    if (typeof SystemJS !== 'object') {

      throw new Error('SystemJS must be used to load fake worker.');

    }

    window.pdfjsWorker = await SystemJS.import('pdfjs/core/worker');

    return undefined;
",2019-12-19 18:11:56+01:00
b54c1fe39528c72281e9158d1920deec7c4ea285,Jonas Jenwald,"Re-factor `Toolbar._adjustScaleWidth` to improve/simplify how the zoom dropdown width is calculated

This patch contains some *much* needed clean-up of, and improvements to, this old code thus addressing a number of issues:

 - Set more reasonable *default* values for the widths, in `web/viewer.css`, since the current ones are actually too small even for the (default) `en-US` locale.
   This obviously result in a slightly larger zoom dropdown width for many locales, but the more consistent UI does look good to me.

 - Stop setting the `min-width`/`max-width` and just use `width` instead.

 - Set an explicit `height` of the zoom dropdown, in an attempt to get Google Chrome to display it with the same height as the toolbar buttons.

 - Remove additional `Element.setAttribute(""style"", ...)` usage.

 - Actually check *all* of the predefined l10n strings, since the old implementation (implicitly) assumed that the currently selected one was the longest (note e.g. the `ja-JP` locale where one string is considerably longer than the rest).

 - Stop invalidating the DOM multiple times when doing the measurements. This was achieved by using a temporary in-memory `canvas`, and we now only need to query the DOM once in order to get the current font properties of the zoom dropdown.",web/toolbar.js,https://github.com/mozilla/pdf.js/commit/b54c1fe39528c72281e9158d1920deec7c4ea285,"  _adjustScaleWidth() {

    const container = this.items.scaleSelectContainer;

    const select = this.items.scaleSelect;

    animationStarted.then(function() {

      // Adjust the width of the zoom box to fit the content.

      // Note: If the window is narrow enough that the zoom box is not

      //       visible, we temporarily show it to be able to adjust its width.

      if (container.clientWidth === 0) {

        container.setAttribute(""style"", ""display: inherit;"");

      }

      if (container.clientWidth > 0) {

        select.setAttribute(""style"", ""min-width: inherit;"");

        const width = select.clientWidth + SCALE_SELECT_CONTAINER_PADDING;

        select.setAttribute(

          ""style"",

          `min-width: ${width + SCALE_SELECT_PADDING}px;`

        );

        container.setAttribute(

          ""style"",

          `min-width: ${width}px; max-width: ${width}px;`

        );

    });
","  /**

   * Increase the width of the zoom dropdown DOM element if, and only if, it's

   * too narrow to fit the *longest* of the localized strings.

   * @private

   */

  async _adjustScaleWidth() {

    const { items, l10n } = this;

    const predefinedValuesPromise = Promise.all([

      l10n.get(""page_scale_auto"", null, ""Automatic Zoom""),

      l10n.get(""page_scale_actual"", null, ""Actual Size""),

      l10n.get(""page_scale_fit"", null, ""Page Fit""),

      l10n.get(""page_scale_width"", null, ""Page Width""),

    ]);



    // The temporary canvas is used to measure text length in the DOM.

    let canvas = document.createElement(""canvas"");

    if (

      typeof PDFJSDev === ""undefined"" ||

      PDFJSDev.test(""MOZCENTRAL || GENERIC"")

    ) {

      canvas.mozOpaque = true;

    }

    let ctx = canvas.getContext(""2d"", { alpha: false });



    await animationStarted;

    const { fontSize, fontFamily } = getComputedStyle(items.scaleSelect);

    ctx.font = `${fontSize} ${fontFamily}`;



    let maxWidth = 0;

    for (const predefinedValue of await predefinedValuesPromise) {

      const { width } = ctx.measureText(predefinedValue);

      if (width > maxWidth) {

        maxWidth = width;

    }

    const overflow = SCALE_SELECT_WIDTH - SCALE_SELECT_CONTAINER_WIDTH;

    maxWidth += 1.5 * overflow;



    if (maxWidth > SCALE_SELECT_CONTAINER_WIDTH) {

      items.scaleSelect.style.width = `${maxWidth + overflow}px`;

      items.scaleSelectContainer.style.width = `${maxWidth}px`;

    }

    // Zeroing the width and height cause Firefox to release graphics resources

    // immediately, which can greatly reduce memory consumption.

    canvas.width = 0;

    canvas.height = 0;

    canvas = ctx = null;
",2020-02-06 14:22:14+01:00
d07be1a89bed0b78dcd18f5134f6601caac0b9fb,Jonas Jenwald,"Move the initialization of ""metadata"" out of `PDFViewerApplication.load`

Over time, with more and more API-functionality added, the `PDFViewerApplication.load` method has become quite large and complex. In an attempt to improve the current situation somewhat, this patch moves the fetching and initialization of ""metadata"" out into its own (private) helper method instead.",web/app.js,https://github.com/mozilla/pdf.js/commit/d07be1a89bed0b78dcd18f5134f6601caac0b9fb,"    pdfDocument

      .getMetadata()

      .then(({ info, metadata, contentDispositionFilename }) => {

        this.documentInfo = info;

        this.metadata = metadata;

        this.contentDispositionFilename = contentDispositionFilename;



        // Provides some basic debug information

        console.log(

          ""PDF "" +

            pdfDocument.fingerprint +

            "" ["" +

            info.PDFFormatVersion +

            "" "" +

            (info.Producer || ""-"").trim() +

            "" / "" +

            (info.Creator || ""-"").trim() +

            ""]"" +

            "" (PDF.js: "" +

            (version || ""-"") +

            (AppOptions.get(""enableWebGL"") ? "" [WebGL]"" : """") +

            "")""

        );

        let pdfTitle;

        const infoTitle = info && info[""Title""];

        if (infoTitle) {

          pdfTitle = infoTitle;

        }

        const metadataTitle = metadata && metadata.get(""dc:title"");

        if (metadataTitle) {

          // Ghostscript can produce invalid 'dc:title' Metadata entries:

          //  - The title may be ""Untitled"" (fixes bug 1031612).

          //  - The title may contain incorrectly encoded characters, which thus

          //    looks broken, hence we ignore the Metadata entry when it

          //    contains characters from the Specials Unicode block

          //    (fixes bug 1605526).

          if (

            metadataTitle !== ""Untitled"" &&

            !/[\uFFF0-\uFFFF]/g.test(metadataTitle)

          ) {

            pdfTitle = metadataTitle;

          }

        }

        if (pdfTitle) {

          this.setTitle(

            `${pdfTitle} - ${contentDispositionFilename || document.title}`

          );

        } else if (contentDispositionFilename) {

          this.setTitle(contentDispositionFilename);

        }

        if (info.IsAcroFormPresent) {

          console.warn(""Warning: AcroForm/XFA is not supported"");

          this.fallback(UNSUPPORTED_FEATURES.forms);

        }

        if (

          typeof PDFJSDev === ""undefined"" ||

          PDFJSDev.test(""MOZCENTRAL || GENERIC"")

        ) {

          // Telemetry labels must be C++ variable friendly.

          let versionId = ""other"";

          // Keep these in sync with mozilla central's Histograms.json.

          const KNOWN_VERSIONS = [

            ""1.0"",

            ""1.1"",

            ""1.2"",

            ""1.3"",

            ""1.4"",

            ""1.5"",

            ""1.6"",

            ""1.7"",

            ""1.8"",

            ""1.9"",

            ""2.0"",

            ""2.1"",

            ""2.2"",

            ""2.3"",

          ];

          if (KNOWN_VERSIONS.includes(info.PDFFormatVersion)) {

            versionId = `v${info.PDFFormatVersion.replace(""."", ""_"")}`;

          }

          let generatorId = ""other"";

          // Keep these in sync with mozilla central's Histograms.json.

          const KNOWN_GENERATORS = [

            ""acrobat distiller"",

            ""acrobat pdfwriter"",

            ""adobe livecycle"",

            ""adobe pdf library"",

            ""adobe photoshop"",

            ""ghostscript"",

            ""tcpdf"",

            ""cairo"",

            ""dvipdfm"",

            ""dvips"",

            ""pdftex"",

            ""pdfkit"",

            ""itext"",

            ""prince"",

            ""quarkxpress"",

            ""mac os x"",

            ""microsoft"",

            ""openoffice"",

            ""oracle"",

            ""luradocument"",

            ""pdf-xchange"",

            ""antenna house"",

            ""aspose.cells"",

            ""fpdf"",

          ];

          if (info.Producer) {

            const producer = info.Producer.toLowerCase();

            KNOWN_GENERATORS.some(function(generator) {

              if (!producer.includes(generator)) {

                return false;

              }

              generatorId = generator.replace(/[ .\-]/g, ""_"");

              return true;

            });

          }

          let formType = null;

          if (info.IsAcroFormPresent) {

            formType = info.IsXFAPresent ? ""xfa"" : ""acroform"";

          this.externalServices.reportTelemetry({

            type: ""documentInfo"",

            version: versionId,

            generator: generatorId,

            formType,

          });

        }
","    this._initializeMetadata(pdfDocument);

  },

  /**

   * @private

   */

  async _initializeMetadata(pdfDocument) {

    const {

      info,

      metadata,

      contentDispositionFilename,

    } = await pdfDocument.getMetadata();

    if (pdfDocument !== this.pdfDocument) {

      return; // The document was closed while the metadata resolved.

    }

    this.documentInfo = info;

    this.metadata = metadata;

    this.contentDispositionFilename = contentDispositionFilename;



    // Provides some basic debug information

    console.log(

      ""PDF "" +

        pdfDocument.fingerprint +

        "" ["" +

        info.PDFFormatVersion +

        "" "" +

        (info.Producer || ""-"").trim() +

        "" / "" +

        (info.Creator || ""-"").trim() +

        ""]"" +

        "" (PDF.js: "" +

        (version || ""-"") +

        (AppOptions.get(""enableWebGL"") ? "" [WebGL]"" : """") +

        "")""

    );

    let pdfTitle;

    const infoTitle = info && info[""Title""];

    if (infoTitle) {

      pdfTitle = infoTitle;

    }

    const metadataTitle = metadata && metadata.get(""dc:title"");

    if (metadataTitle) {

      // Ghostscript can produce invalid 'dc:title' Metadata entries:

      //  - The title may be ""Untitled"" (fixes bug 1031612).

      //  - The title may contain incorrectly encoded characters, which thus

      //    looks broken, hence we ignore the Metadata entry when it

      //    contains characters from the Specials Unicode block

      //    (fixes bug 1605526).

      if (

        metadataTitle !== ""Untitled"" &&

        !/[\uFFF0-\uFFFF]/g.test(metadataTitle)

      ) {

        pdfTitle = metadataTitle;

      }

    }

    if (pdfTitle) {

      this.setTitle(

        `${pdfTitle} - ${contentDispositionFilename || document.title}`

      );

    } else if (contentDispositionFilename) {

      this.setTitle(contentDispositionFilename);

    }

    if (info.IsAcroFormPresent) {

      console.warn(""Warning: AcroForm/XFA is not supported"");

      this.fallback(UNSUPPORTED_FEATURES.forms);

    }

    if (

      typeof PDFJSDev === ""undefined"" ||

      PDFJSDev.test(""MOZCENTRAL || GENERIC"")

    ) {

      // Telemetry labels must be C++ variable friendly.

      let versionId = ""other"";

      // Keep these in sync with mozilla central's Histograms.json.

      const KNOWN_VERSIONS = [

        ""1.0"",

        ""1.1"",

        ""1.2"",

        ""1.3"",

        ""1.4"",

        ""1.5"",

        ""1.6"",

        ""1.7"",

        ""1.8"",

        ""1.9"",

        ""2.0"",

        ""2.1"",

        ""2.2"",

        ""2.3"",

      ];

      if (KNOWN_VERSIONS.includes(info.PDFFormatVersion)) {

        versionId = `v${info.PDFFormatVersion.replace(""."", ""_"")}`;

      }

      let generatorId = ""other"";

      // Keep these in sync with mozilla central's Histograms.json.

      const KNOWN_GENERATORS = [

        ""acrobat distiller"",

        ""acrobat pdfwriter"",

        ""adobe livecycle"",

        ""adobe pdf library"",

        ""adobe photoshop"",

        ""ghostscript"",

        ""tcpdf"",

        ""cairo"",

        ""dvipdfm"",

        ""dvips"",

        ""pdftex"",

        ""pdfkit"",

        ""itext"",

        ""prince"",

        ""quarkxpress"",

        ""mac os x"",

        ""microsoft"",

        ""openoffice"",

        ""oracle"",

        ""luradocument"",

        ""pdf-xchange"",

        ""antenna house"",

        ""aspose.cells"",

        ""fpdf"",

      ];

      if (info.Producer) {

        const producer = info.Producer.toLowerCase();

        KNOWN_GENERATORS.some(function(generator) {

          if (!producer.includes(generator)) {

            return false;

          generatorId = generator.replace(/[ .\-]/g, ""_"");

          return true;

        });

      }



      let formType = null;

      if (info.IsAcroFormPresent) {

        formType = info.IsXFAPresent ? ""xfa"" : ""acroform"";

      }

      this.externalServices.reportTelemetry({

        type: ""documentInfo"",

        version: versionId,

        generator: generatorId,

        formType,

    }
",2020-04-05 10:26:55+02:00
6967b9dd96638bbfa88ae169ab5302278ce72a44,Jonas Jenwald,"Modernize the font-tests

This patch first of all enables linting of the files in the `test/font/` folder, and secondly it also re-factors all test files to use native `import`/`export` statements. Finally, all tests are now loaded correctly, rather than being included as scripts through the `font_test.html` file.",test/font/jasmine-boot.js,https://github.com/mozilla/pdf.js/commit/6967b9dd96638bbfa88ae169ab5302278ce72a44,"function initializePDFJS(callback) {

  Promise.all([

    SystemJS.import(""pdfjs/core/fonts.js""),

    SystemJS.import(""pdfjs/core/stream.js""),

    SystemJS.import(""pdfjs/core/primitives.js""),

    SystemJS.import(""pdfjs/core/cmap.js""),

  ]).then(function (modules) {

    var fonts = modules[0],

      stream = modules[1],

      primitives = modules[2],

      cmap = modules[3];

    // Expose some of the PDFJS members to global scope for tests.

    window.Font = fonts.Font;

    window.ToUnicodeMap = fonts.ToUnicodeMap;

    window.Stream = stream.Stream;

    window.Name = primitives.Name;

    window.CMapFactory = cmap.CMapFactory;



    callback();

  });
","async function initializePDFJS(callback) {

  await Promise.all(

    [

      ""pdfjs-test/font/font_core_spec.js"",

      ""pdfjs-test/font/font_os2_spec.js"",

      ""pdfjs-test/font/font_post_spec.js"",

      ""pdfjs-test/font/font_fpgm_spec.js"",

    ].map(function (moduleName) {

      return SystemJS.import(moduleName);

    })

  );



  callback();
",2020-10-26 12:12:40+01:00
a49b3e04d5b3cd89175f51040a64038569b0446a,Jonas Jenwald,"Add a new `FirefoxCom.requestAsync` method, to simplify the code in `web/firefoxcom.js`

There's a fair number of cases where `FirefoxCom.request`-calls are manually wrapped in a Promise to make it asynchronous. We can reduce the amount of boilerplate code in these cases by introducing a new `FirefoxCom.requestAsync` method instead.

Furthermore, a couple of `FirefoxCom.request`-calls in the `DownloadManager` are also changed to be asynchronous rather than using callback-functions.
With this patch, we're thus able to replace a lot of *direct* usages of `FirefoxCom.request` with the new `FirefoxCom.requestAsync` method instead.",web/firefoxcom.js,https://github.com/mozilla/pdf.js/commit/a49b3e04d5b3cd89175f51040a64038569b0446a,"    return new Promise(resolve => {

      FirefoxCom.request(""createSandbox"", data, resolve);

    }).then(success => {

      if (!success) {

        throw new Error(""Cannot create sandbox."");

      }

    });
","    const success = await FirefoxCom.requestAsync(""createSandbox"", data);

    if (!success) {

      throw new Error(""Cannot create sandbox."");

    }
",2021-01-01 14:40:46+01:00
6dae2677d5fabe3116065c6ada5e50aec451dcba,Ross Johnson,"[api-minor] Highlight search results correctly for normalized text (PR 9448)

This patch is a rebased *and* refactored version of PR 9448, such that it applies cleanly given that `PDFFindController` has changed since that PR was opened; obviously keeping the original author information intact.

This patch will thus ensure that e.g. fractions, and other things that we normalize before searching, will still be highlighted correctly in the textLayer.

Furthermore, this patch also adds basic unit-tests for this functionality.

*Note:* The `[api-minor]` tag is added, since third-party implementations of the `PDFFindController` must now always use the `pageMatchesLength` property to get accurate length information (see the `web/text_layer_builder.js` changes).

Co-authored-by: Ross Johnson <ross@mazira.com>
Co-authored-by: Jonas Jenwald <jonas.jenwald@gmail.com>",test/unit/pdf_find_controller_spec.js,https://github.com/mozilla/pdf.js/commit/6dae2677d5fabe3116065c6ada5e50aec451dcba,"    }).then(done);

  it(""performs a normal search and finds the previous result"", function (done) {

    testSearch({
","    });

  it(""performs a normal search and finds the previous result"", async function () {

    const { eventBus, pdfFindController } = await initPdfFindController();



    await testSearch({

      eventBus,

      pdfFindController,
",2021-01-12 15:21:19+01:00
6dae2677d5fabe3116065c6ada5e50aec451dcba,Ross Johnson,"[api-minor] Highlight search results correctly for normalized text (PR 9448)

This patch is a rebased *and* refactored version of PR 9448, such that it applies cleanly given that `PDFFindController` has changed since that PR was opened; obviously keeping the original author information intact.

This patch will thus ensure that e.g. fractions, and other things that we normalize before searching, will still be highlighted correctly in the textLayer.

Furthermore, this patch also adds basic unit-tests for this functionality.

*Note:* The `[api-minor]` tag is added, since third-party implementations of the `PDFFindController` must now always use the `pageMatchesLength` property to get accurate length information (see the `web/text_layer_builder.js` changes).

Co-authored-by: Ross Johnson <ross@mazira.com>
Co-authored-by: Jonas Jenwald <jonas.jenwald@gmail.com>",test/unit/pdf_find_controller_spec.js,https://github.com/mozilla/pdf.js/commit/6dae2677d5fabe3116065c6ada5e50aec451dcba,"    }).then(done);

  it(""performs a case sensitive search"", function (done) {

    testSearch({
","    });

  it(""performs a case sensitive search"", async function () {

    const { eventBus, pdfFindController } = await initPdfFindController();



    await testSearch({

      eventBus,

      pdfFindController,
",2021-01-12 15:21:19+01:00
6dae2677d5fabe3116065c6ada5e50aec451dcba,Ross Johnson,"[api-minor] Highlight search results correctly for normalized text (PR 9448)

This patch is a rebased *and* refactored version of PR 9448, such that it applies cleanly given that `PDFFindController` has changed since that PR was opened; obviously keeping the original author information intact.

This patch will thus ensure that e.g. fractions, and other things that we normalize before searching, will still be highlighted correctly in the textLayer.

Furthermore, this patch also adds basic unit-tests for this functionality.

*Note:* The `[api-minor]` tag is added, since third-party implementations of the `PDFFindController` must now always use the `pageMatchesLength` property to get accurate length information (see the `web/text_layer_builder.js` changes).

Co-authored-by: Ross Johnson <ross@mazira.com>
Co-authored-by: Jonas Jenwald <jonas.jenwald@gmail.com>",test/unit/pdf_find_controller_spec.js,https://github.com/mozilla/pdf.js/commit/6dae2677d5fabe3116065c6ada5e50aec451dcba,"    }).then(done);

  it(""performs an entire word search"", function (done) {

    testSearch({
","    });

  it(""performs an entire word search"", async function () {

    const { eventBus, pdfFindController } = await initPdfFindController();



    await testSearch({

      eventBus,

      pdfFindController,
",2021-01-12 15:21:19+01:00
6dae2677d5fabe3116065c6ada5e50aec451dcba,Ross Johnson,"[api-minor] Highlight search results correctly for normalized text (PR 9448)

This patch is a rebased *and* refactored version of PR 9448, such that it applies cleanly given that `PDFFindController` has changed since that PR was opened; obviously keeping the original author information intact.

This patch will thus ensure that e.g. fractions, and other things that we normalize before searching, will still be highlighted correctly in the textLayer.

Furthermore, this patch also adds basic unit-tests for this functionality.

*Note:* The `[api-minor]` tag is added, since third-party implementations of the `PDFFindController` must now always use the `pageMatchesLength` property to get accurate length information (see the `web/text_layer_builder.js` changes).

Co-authored-by: Ross Johnson <ross@mazira.com>
Co-authored-by: Jonas Jenwald <jonas.jenwald@gmail.com>",test/unit/pdf_find_controller_spec.js,https://github.com/mozilla/pdf.js/commit/6dae2677d5fabe3116065c6ada5e50aec451dcba,"    }).then(done);

  it(""performs a multiple term (no phrase) search"", function (done) {

    testSearch({
","    });

  it(""performs a multiple term (no phrase) search"", async function () {

    const { eventBus, pdfFindController } = await initPdfFindController();



    await testSearch({

      eventBus,

      pdfFindController,
",2021-01-12 15:21:19+01:00
6dae2677d5fabe3116065c6ada5e50aec451dcba,Ross Johnson,"[api-minor] Highlight search results correctly for normalized text (PR 9448)

This patch is a rebased *and* refactored version of PR 9448, such that it applies cleanly given that `PDFFindController` has changed since that PR was opened; obviously keeping the original author information intact.

This patch will thus ensure that e.g. fractions, and other things that we normalize before searching, will still be highlighted correctly in the textLayer.

Furthermore, this patch also adds basic unit-tests for this functionality.

*Note:* The `[api-minor]` tag is added, since third-party implementations of the `PDFFindController` must now always use the `pageMatchesLength` property to get accurate length information (see the `web/text_layer_builder.js` changes).

Co-authored-by: Ross Johnson <ross@mazira.com>
Co-authored-by: Jonas Jenwald <jonas.jenwald@gmail.com>",test/unit/pdf_find_controller_spec.js,https://github.com/mozilla/pdf.js/commit/6dae2677d5fabe3116065c6ada5e50aec451dcba,"    }).then(done);
","    });

  });



  it(""performs a normal search, where the text is normalized"", async function () {

    const { eventBus, pdfFindController } = await initPdfFindController(

      ""fraction-highlight.pdf""

    );



    await testSearch({

      eventBus,

      pdfFindController,

      parameters: {

        query: ""fraction"",

        caseSensitive: false,

        entireWord: false,

        phraseSearch: true,

        findPrevious: false,

      },

      matchesPerPage: [3],

      selectedMatch: {

        pageIndex: 0,

        matchIndex: 0,

      },

      pageMatches: [[19, 48, 66]],

      pageMatchesLength: [[8, 8, 8]],

    });
",2021-01-12 15:21:19+01:00
ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,Calixte Denizet,Remove Promise.all and async+done from unit/scripting_spec,test/unit/scripting_spec.js,https://github.com/mozilla/pdf.js/commit/ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,"      it(""should print a date according to a format"", function (done) {

        Promise.all([

          myeval(`util.printd(0, ${date})`).then(value => {

            expect(value).toEqual(""D:20070415031415"");

          }),

          myeval(`util.printd(1, ${date})`).then(value => {

            expect(value).toEqual(""2007.04.15 03:14:15"");

          }),

          myeval(`util.printd(2, ${date})`).then(value => {

            expect(value).toEqual(""4/15/07 3:14:15 am"");

          }),

          myeval(`util.printd(""mmmm mmm mm m"", ${date})`).then(value => {

            expect(value).toEqual(""April Apr 04 4"");

          }),

          myeval(`util.printd(""dddd ddd dd d"", ${date})`).then(value => {

            expect(value).toEqual(""Sunday Sun 15 15"");

          }),

        ]).then(() => done());

      it(""should parse a date according to a format"", function (done) {

        Promise.all([

          myeval(`util.scand(0, ""D:20070415031415"").toString()`).then(value => {

            expect(new Date(value)).toEqual(date);

          }),

          myeval(`util.scand(1, ""2007.04.15 03:14:15"").toString()`).then(

            value => {

              expect(new Date(value)).toEqual(date);

            }

          ),

          myeval(`util.scand(2, ""4/15/07 3:14:15 am"").toString()`).then(

            value => {

              expect(new Date(value)).toEqual(date);

            }

          ),

        ]).then(() => done());

      it(""should print some data according to a format"", function (done) {

        Promise.all([

          myeval(

            `util.printf(""Integer numbers: %d, %d,..."", 1.234, 56.789)`

          ).then(value => {

            expect(value).toEqual(""Integer numbers: 1, 56,..."");

          }),

          myeval(`util.printf(""Hex numbers: %x, %x,..."", 1234, 56789)`).then(

            value => {

              expect(value).toEqual(""Hex numbers: 4D2, DDD5,..."");

            }

          ),

          myeval(

            `util.printf(""Hex numbers with 0x: %#x, %#x,..."", 1234, 56789)`

          ).then(value => {

            expect(value).toEqual(""Hex numbers with 0x: 0x4D2, 0xDDD5,..."");

          }),

          myeval(`util.printf(""Decimal number: %,0+.3f"", 1234567.89123)`).then(

            value => {

              expect(value).toEqual(""Decimal number: +1,234,567.891"");

            }

          ),

          myeval(`util.printf(""Decimal number: %,0+8.3f"", 1.234567)`).then(

            value => {

              expect(value).toEqual(""Decimal number: +  1.235"");

            }

          ),

          myeval(`util.printf(""Decimal number: %,0.2f"", -12.34567)`).then(

            value => {

              expect(value).toEqual(""Decimal number: -12.35"");

            }

          ),

        ]).then(() => done());

      it(""should print a string with no argument"", function (done) {

        myeval(`util.printf(""hello world"")`)

          .then(value => {

            expect(value).toEqual(""hello world"");

          })

          .then(() => done());

      it(""print a string with a percent"", function (done) {

        myeval(`util.printf(""%%s"")`)

          .then(value => {

            expect(value).toEqual(""%%s"");

          })

          .then(() => done());

      it(""should print some data according to a format"", function (done) {

        myeval(`util.printx(""9 (999) 999-9999"", ""aaa14159697489zzz"")`)

          .then(value => {

            expect(value).toEqual(""1 (415) 969-7489"");

          })

          .then(() => done());

    it(""should trigger an event and modify the source"", function (done) {
","      it(""should print a date according to a format"", async () => {

        let value = await myeval(`util.printd(0, ${date})`);

        expect(value).toEqual(""D:20070415031415"");



        value = await myeval(`util.printd(1, ${date})`);

        expect(value).toEqual(""2007.04.15 03:14:15"");



        value = await myeval(`util.printd(2, ${date})`);

        expect(value).toEqual(""4/15/07 3:14:15 am"");



        value = await myeval(`util.printd(""mmmm mmm mm m"", ${date})`);

        expect(value).toEqual(""April Apr 04 4"");



        value = await myeval(`util.printd(""dddd ddd dd d"", ${date})`);

        expect(value).toEqual(""Sunday Sun 15 15"");

      it(""should parse a date according to a format"", async () => {

        let value = await myeval(

          `util.scand(0, ""D:20070415031415"").toString()`

        );

        expect(new Date(value)).toEqual(date);



        value = await myeval(`util.scand(1, ""2007.04.15 03:14:15"").toString()`);

        expect(new Date(value)).toEqual(date);



        value = await myeval(`util.scand(2, ""4/15/07 3:14:15 am"").toString()`);

        expect(new Date(value)).toEqual(date);

      it(""should print some data according to a format"", async () => {

        let value = await myeval(

          `util.printf(""Integer numbers: %d, %d,..."", 1.234, 56.789)`

        );

        expect(value).toEqual(""Integer numbers: 1, 56,..."");



        value = await myeval(

          `util.printf(""Hex numbers: %x, %x,..."", 1234, 56789)`

        );

        expect(value).toEqual(""Hex numbers: 4D2, DDD5,..."");



        value = await myeval(

          `util.printf(""Hex numbers with 0x: %#x, %#x,..."", 1234, 56789)`

        );

        expect(value).toEqual(""Hex numbers with 0x: 0x4D2, 0xDDD5,..."");



        value = await myeval(

          `util.printf(""Decimal number: %,0+.3f"", 1234567.89123)`

        );

        expect(value).toEqual(""Decimal number: +1,234,567.891"");



        value = await myeval(

          `util.printf(""Decimal number: %,0+8.3f"", 1.234567)`

        );

        expect(value).toEqual(""Decimal number: +  1.235"");



        value = await myeval(

          `util.printf(""Decimal number: %,0.2f"", -12.34567)`

        );

        expect(value).toEqual(""Decimal number: -12.35"");

      it(""should print a string with no argument"", async () => {

        const value = await myeval(`util.printf(""hello world"")`);

        expect(value).toEqual(""hello world"");

      it(""print a string with a percent"", async () => {

        const value = await myeval(`util.printf(""%%s"")`);

        expect(value).toEqual(""%%s"");

      it(""should print some data according to a format"", async () => {

        const value = await myeval(

          `util.printx(""9 (999) 999-9999"", ""aaa14159697489zzz"")`

        );

        expect(value).toEqual(""1 (415) 969-7489"");

    it(""should trigger an event and modify the source"", async () => {
",2021-02-17 11:19:39+01:00
ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,Calixte Denizet,Remove Promise.all and async+done from unit/scripting_spec,test/unit/scripting_spec.js,https://github.com/mozilla/pdf.js/commit/ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,"      sandbox

        .dispatchEventInSandbox({

          id: refId,

          value: """",

          name: ""test"",

          willCommit: true,

        })

        .then(() => {

          expect(send_queue.has(refId)).toEqual(true);

          expect(send_queue.get(refId)).toEqual({

            id: refId,

            value: ""123"",

          });

          done();

        })

        .catch(done.fail);

    it(""should trigger a Keystroke event and invalidate it"", function (done) {
","

      await sandbox.dispatchEventInSandbox({

        id: refId,

        value: """",

        name: ""test"",

        willCommit: true,

      });



      expect(send_queue.has(refId)).toEqual(true);

      expect(send_queue.get(refId)).toEqual({

        id: refId,

        value: ""123"",

      });

    it(""should trigger a Keystroke event and invalidate it"", async () => {
",2021-02-17 11:19:39+01:00
ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,Calixte Denizet,Remove Promise.all and async+done from unit/scripting_spec,test/unit/scripting_spec.js,https://github.com/mozilla/pdf.js/commit/ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,"      sandbox

        .dispatchEventInSandbox({

          id: refId,

          value: ""hell"",

          name: ""Keystroke"",

          willCommit: false,

          change: ""o"",

          selStart: 4,

          selEnd: 4,

        })

        .then(() => {

          expect(send_queue.has(refId)).toEqual(true);

          expect(send_queue.get(refId)).toEqual({

            id: refId,

            value: ""hell"",

            selRange: [4, 4],

          });

          done();

        })

        .catch(done.fail);

    it(""should trigger a Keystroke event and change it"", function (done) {
","      await sandbox.dispatchEventInSandbox({

        id: refId,

        value: ""hell"",

        name: ""Keystroke"",

        willCommit: false,

        change: ""o"",

        selStart: 4,

        selEnd: 4,

      });



      expect(send_queue.has(refId)).toEqual(true);

      expect(send_queue.get(refId)).toEqual({

        id: refId,

        value: ""hell"",

        selRange: [4, 4],

      });

    it(""should trigger a Keystroke event and change it"", async () => {
",2021-02-17 11:19:39+01:00
ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,Calixte Denizet,Remove Promise.all and async+done from unit/scripting_spec,test/unit/scripting_spec.js,https://github.com/mozilla/pdf.js/commit/ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,"      sandbox

        .dispatchEventInSandbox({

          id: refId,

          value: ""hell"",

          name: ""Keystroke"",

          willCommit: false,

          change: ""o"",

          selStart: 4,

          selEnd: 4,

        })

        .then(() => {

          expect(send_queue.has(refId)).toEqual(true);

          expect(send_queue.get(refId)).toEqual({

            id: refId,

            value: ""hella"",

          });

          done();

        })

        .catch(done.fail);

    it(""should trigger an invalid commit Keystroke event"", function (done) {
","      await sandbox.dispatchEventInSandbox({

        id: refId,

        value: ""hell"",

        name: ""Keystroke"",

        willCommit: false,

        change: ""o"",

        selStart: 4,

        selEnd: 4,

      });



      expect(send_queue.has(refId)).toEqual(true);

      expect(send_queue.get(refId)).toEqual({

        id: refId,

        value: ""hella"",

      });

    it(""should trigger an invalid commit Keystroke event"", async () => {
",2021-02-17 11:19:39+01:00
ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,Calixte Denizet,Remove Promise.all and async+done from unit/scripting_spec,test/unit/scripting_spec.js,https://github.com/mozilla/pdf.js/commit/ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,"      sandbox

        .dispatchEventInSandbox({

          id: refId,

          value: """",

          name: ""test"",

          willCommit: true,

        })

        .then(() => {

          expect(send_queue.has(refId)).toEqual(false);

          done();

        })

        .catch(done.fail);

    it(""should trigger a valid commit Keystroke event"", function (done) {
","      await sandbox.dispatchEventInSandbox({

        id: refId,

        value: """",

        name: ""test"",

        willCommit: true,

      });

      expect(send_queue.has(refId)).toEqual(false);

    it(""should trigger a valid commit Keystroke event"", async () => {
",2021-02-17 11:19:39+01:00
ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,Calixte Denizet,Remove Promise.all and async+done from unit/scripting_spec,test/unit/scripting_spec.js,https://github.com/mozilla/pdf.js/commit/ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,"      sandbox

        .dispatchEventInSandbox({

          id: refId1,

          value: ""hello"",

          name: ""Keystroke"",

          willCommit: true,

        })

        .then(() => {

          expect(send_queue.has(refId1)).toEqual(true);

          expect(send_queue.get(refId1)).toEqual({

            id: refId1,

            value: ""world"",

            valueAsString: ""world"",

          });

          done();

        })

        .catch(done.fail);
","      await sandbox.dispatchEventInSandbox({

        id: refId1,

        value: ""hello"",

        name: ""Keystroke"",

        willCommit: true,

      });



      expect(send_queue.has(refId1)).toEqual(true);

      expect(send_queue.get(refId1)).toEqual({

        id: refId1,

        value: ""world"",

        valueAsString: ""world"",

      });
",2021-02-17 11:19:39+01:00
ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,Calixte Denizet,Remove Promise.all and async+done from unit/scripting_spec,test/unit/scripting_spec.js,https://github.com/mozilla/pdf.js/commit/ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,"    it(""should convert RGB color for different color spaces"", function (done) {

      Promise.all([

        myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""T"")`).then(value => {

          expect(round(value)).toEqual([""T""]);

        }),

        myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""G"")`).then(value => {

          expect(round(value)).toEqual([""G"", 0.181]);

        }),

        myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""RGB"")`).then(value => {

          expect(round(value)).toEqual([""RGB"", 0.1, 0.2, 0.3]);

        }),

        myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""CMYK"")`).then(value => {

          expect(round(value)).toEqual([""CMYK"", 0.9, 0.8, 0.7, 0.7]);

        }),

      ]).then(() => done());

    it(""should convert CMYK color for different color spaces"", function (done) {

      Promise.all([

        myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""T"")`).then(

          value => {

            expect(round(value)).toEqual([""T""]);

          }

        ),

        myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""G"")`).then(

          value => {

            expect(round(value)).toEqual([""G"", 0.371]);

          }

        ),

        myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""RGB"")`).then(

          value => {

            expect(round(value)).toEqual([""RGB"", 0.5, 0.3, 0.4]);

          }

        ),

        myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""CMYK"")`).then(

          value => {

            expect(round(value)).toEqual([""CMYK"", 0.1, 0.2, 0.3, 0.4]);

          }

        ),

      ]).then(() => done());

    it(""should convert Gray color for different color spaces"", function (done) {

      Promise.all([

        myeval(`color.convert([""G"", 0.1], ""T"")`).then(value => {

          expect(round(value)).toEqual([""T""]);

        }),

        myeval(`color.convert([""G"", 0.1], ""G"")`).then(value => {

          expect(round(value)).toEqual([""G"", 0.1]);

        }),

        myeval(`color.convert([""G"", 0.1], ""RGB"")`).then(value => {

          expect(round(value)).toEqual([""RGB"", 0.1, 0.1, 0.1]);

        }),

        myeval(`color.convert([""G"", 0.1], ""CMYK"")`).then(value => {

          expect(round(value)).toEqual([""CMYK"", 0, 0, 0, 0.9]);

        }),

      ]).then(() => done());

    it(""should convert Transparent color for different color spaces"", function (done) {

      Promise.all([

        myeval(`color.convert([""T""], ""T"")`).then(value => {

          expect(round(value)).toEqual([""T""]);

        }),

        myeval(`color.convert([""T""], ""G"")`).then(value => {

          expect(round(value)).toEqual([""G"", 0]);

        }),

        myeval(`color.convert([""T""], ""RGB"")`).then(value => {

          expect(round(value)).toEqual([""RGB"", 0, 0, 0]);

        }),

        myeval(`color.convert([""T""], ""CMYK"")`).then(value => {

          expect(round(value)).toEqual([""CMYK"", 0, 0, 0, 1]);

        }),

      ]).then(() => done());
","    it(""should convert RGB color for different color spaces"", async () => {

      let value = await myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""T"")`);

      expect(round(value)).toEqual([""T""]);



      value = await myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""G"")`);

      expect(round(value)).toEqual([""G"", 0.181]);



      value = await myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""RGB"")`);

      expect(round(value)).toEqual([""RGB"", 0.1, 0.2, 0.3]);



      value = await myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""CMYK"")`);

      expect(round(value)).toEqual([""CMYK"", 0.9, 0.8, 0.7, 0.7]);

    it(""should convert CMYK color for different color spaces"", async () => {

      let value = await myeval(

        `color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""T"")`

      );

      expect(round(value)).toEqual([""T""]);



      value = await myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""G"")`);

      expect(round(value)).toEqual([""G"", 0.371]);



      value = await myeval(

        `color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""RGB"")`

      );

      expect(round(value)).toEqual([""RGB"", 0.5, 0.3, 0.4]);



      value = await myeval(

        `color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""CMYK"")`

      );

      expect(round(value)).toEqual([""CMYK"", 0.1, 0.2, 0.3, 0.4]);

    it(""should convert Gray color for different color spaces"", async () => {

      let value = await myeval(`color.convert([""G"", 0.1], ""T"")`);

      expect(round(value)).toEqual([""T""]);



      value = await myeval(`color.convert([""G"", 0.1], ""G"")`);

      expect(round(value)).toEqual([""G"", 0.1]);



      value = await myeval(`color.convert([""G"", 0.1], ""RGB"")`);

      expect(round(value)).toEqual([""RGB"", 0.1, 0.1, 0.1]);



      value = await myeval(`color.convert([""G"", 0.1], ""CMYK"")`);

      expect(round(value)).toEqual([""CMYK"", 0, 0, 0, 0.9]);

    it(""should convert Transparent color for different color spaces"", async () => {

      let value = await myeval(`color.convert([""T""], ""T"")`);

      expect(round(value)).toEqual([""T""]);



      value = await myeval(`color.convert([""T""], ""G"")`);

      expect(round(value)).toEqual([""G"", 0]);



      value = await myeval(`color.convert([""T""], ""RGB"")`);

      expect(round(value)).toEqual([""RGB"", 0, 0, 0]);



      value = await myeval(`color.convert([""T""], ""CMYK"")`);

      expect(round(value)).toEqual([""CMYK"", 0, 0, 0, 1]);
",2021-02-17 11:19:39+01:00
ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,Calixte Denizet,Remove Promise.all and async+done from unit/scripting_spec,test/unit/scripting_spec.js,https://github.com/mozilla/pdf.js/commit/ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad,"    it(""should test language"", function (done) {

      Promise.all([

        myeval(`app.language`).then(value => {

          expect(value).toEqual(""ENU"");

        }),

        myeval(`app.language = ""hello""`).then(value => {

          expect(value).toEqual(""app.language is read-only"");

        }),

      ]).then(() => done());

    it(""should test platform"", function (done) {

      Promise.all([

        myeval(`app.platform`).then(value => {

          expect(value).toEqual(""UNIX"");

        }),

        myeval(`app.platform = ""hello""`).then(value => {

          expect(value).toEqual(""app.platform is read-only"");

        }),

      ]).then(() => done());
","    it(""should test language"", async () => {

      let value = await myeval(`app.language`);

      expect(value).toEqual(""ENU"");



      value = await myeval(`app.language = ""hello""`);

      expect(value).toEqual(""app.language is read-only"");

    it(""should test platform"", async () => {

      let value = await myeval(`app.platform`);

      expect(value).toEqual(""UNIX"");



      value = await myeval(`app.platform = ""hello""`);

      expect(value).toEqual(""app.platform is read-only"");
",2021-02-17 11:19:39+01:00
05de20071a43f7dac9903835f479d57e863521f7,Jonas Jenwald,"Modernize some of the code in `src/core/cmap.js` by using classes and async/await

This converts a couple of our old ""classes"" to proper ECMAScript classes, and replaces a lot of manual Promise-wrapping with async/await instead.",src/core/cmap.js,https://github.com/mozilla/pdf.js/commit/05de20071a43f7dac9903835f479d57e863521f7,"    },

  };

  function processBinaryCMap(data, cMap, extend) {

    return new Promise(function (resolve, reject) {
","    }

  }

  // eslint-disable-next-line no-shadow

  class BinaryCMapReader {

    async process(data, cMap, extend) {
",2021-02-27 14:20:43+01:00
05de20071a43f7dac9903835f479d57e863521f7,Jonas Jenwald,"Modernize some of the code in `src/core/cmap.js` by using classes and async/await

This converts a couple of our old ""classes"" to proper ECMAScript classes, and replaces a lot of manual Promise-wrapping with async/await instead.",src/core/cmap.js,https://github.com/mozilla/pdf.js/commit/05de20071a43f7dac9903835f479d57e863521f7,"    return Promise.resolve(cMap);

  function extendCMap(cMap, fetchBuiltInCMap, useCMap) {

    return createBuiltInCMap(useCMap, fetchBuiltInCMap).then(function (

      newCMap

    ) {

      cMap.useCMap = newCMap;

      // If there aren't any code space ranges defined clone all the parent ones

      // into this cMap.

      if (cMap.numCodespaceRanges === 0) {

        var useCodespaceRanges = cMap.useCMap.codespaceRanges;

        for (var i = 0; i < useCodespaceRanges.length; i++) {

          cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();

        }

        cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;

      // Merge the map into the current one, making sure not to override

      // any previously defined entries.

      cMap.useCMap.forEach(function (key, value) {

        if (!cMap.contains(key)) {

          cMap.mapOne(key, cMap.useCMap.lookup(key));

        }

      });



      return cMap;

  function createBuiltInCMap(name, fetchBuiltInCMap) {

      return Promise.resolve(new IdentityCMap(false, 2));

      return Promise.resolve(new IdentityCMap(true, 2));

      return Promise.reject(new Error(""Unknown CMap name: "" + name));

      return Promise.reject(

        new Error(""Built-in CMap parameters are not provided."")

      );

    return fetchBuiltInCMap(name).then(function (data) {

      var cMapData = data.cMapData,

        compressionType = data.compressionType;

      var cMap = new CMap(true);



      if (compressionType === CMapCompressionType.BINARY) {

        return new BinaryCMapReader().process(

          cMapData,

          cMap,

          function (useCMap) {

            return extendCMap(cMap, fetchBuiltInCMap, useCMap);

          }

        );

      }

      if (compressionType === CMapCompressionType.NONE) {

        var lexer = new Lexer(new Stream(cMapData));

        return parseCMap(cMap, lexer, fetchBuiltInCMap, null);

      }

      return Promise.reject(

        new Error(

          ""TODO: Only BINARY/NONE CMap compression is currently supported.""

        )

      );

    });
","    return cMap;

  async function extendCMap(cMap, fetchBuiltInCMap, useCMap) {

    cMap.useCMap = await createBuiltInCMap(useCMap, fetchBuiltInCMap);

    // If there aren't any code space ranges defined clone all the parent ones

    // into this cMap.

    if (cMap.numCodespaceRanges === 0) {

      var useCodespaceRanges = cMap.useCMap.codespaceRanges;

      for (var i = 0; i < useCodespaceRanges.length; i++) {

        cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();

      }

      cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;

    }

    // Merge the map into the current one, making sure not to override

    // any previously defined entries.

    cMap.useCMap.forEach(function (key, value) {

      if (!cMap.contains(key)) {

        cMap.mapOne(key, cMap.useCMap.lookup(key));



    return cMap;

  async function createBuiltInCMap(name, fetchBuiltInCMap) {

      return new IdentityCMap(false, 2);

      return new IdentityCMap(true, 2);

      throw new Error(""Unknown CMap name: "" + name);

      throw new Error(""Built-in CMap parameters are not provided."");

    const { cMapData, compressionType } = await fetchBuiltInCMap(name);

    var cMap = new CMap(true);



    if (compressionType === CMapCompressionType.BINARY) {

      return new BinaryCMapReader().process(cMapData, cMap, useCMap => {

        return extendCMap(cMap, fetchBuiltInCMap, useCMap);

      });

    }

    if (compressionType === CMapCompressionType.NONE) {

      var lexer = new Lexer(new Stream(cMapData));

      return parseCMap(cMap, lexer, fetchBuiltInCMap, null);

    }

    throw new Error(

      ""TODO: Only BINARY/NONE CMap compression is currently supported.""

    );
",2021-02-27 14:20:43+01:00
05de20071a43f7dac9903835f479d57e863521f7,Jonas Jenwald,"Modernize some of the code in `src/core/cmap.js` by using classes and async/await

This converts a couple of our old ""classes"" to proper ECMAScript classes, and replaces a lot of manual Promise-wrapping with async/await instead.",src/core/cmap.js,https://github.com/mozilla/pdf.js/commit/05de20071a43f7dac9903835f479d57e863521f7,"        var cMap = new CMap();

        var lexer = new Lexer(encoding);

        return parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap).then(function (

          parsedCMap

        ) {

          if (parsedCMap.isIdentityCMap) {

            return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);

          }

          return parsedCMap;

        });
","        const parsedCMap = await parseCMap(

          /* cMap = */ new CMap(),

          /* lexer = */ new Lexer(encoding),

          fetchBuiltInCMap,

          useCMap

        );



        if (parsedCMap.isIdentityCMap) {

          return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);

        }

        return parsedCMap;
",2021-02-27 14:20:43+01:00
038668bf8cbf73490e06a70b4d24364499ab484e,Jonas Jenwald,"Collect all l10n fallback strings, used in the viewer, in one helper function (PR 12981 follow-up)

Rather than having to spell out the English fallback strings at *every* single `IL10n.get` call-site throughout the viewer, we can simplify things by collecting them in *one* central spot.
This provides a much better overview of the fallback l10n strings used, which makes future changes easier and ensures that fallback strings occuring in multiple places cannot accidentally get out of sync.
Furthermore, by making the `fallback` parameter of the `IL10n.get` method *optional*[1] many of the call-sites (and their surrounding code) become a lot less verbose.

---
[1] It's obviously still possible to pass in a fallback string, it's just not required.",web/password_prompt.js,https://github.com/mozilla/pdf.js/commit/038668bf8cbf73490e06a70b4d24364499ab484e,"  open() {

    this.overlayManager.open(this.overlayName).then(() => {

      if (

        !this._isViewerEmbedded ||

        this.reason === PasswordResponses.INCORRECT_PASSWORD

      ) {

        this.input.focus();

      }

      let promptString;

      if (this.reason === PasswordResponses.INCORRECT_PASSWORD) {

        promptString = this.l10n.get(

          ""password_invalid"",

          null,

          ""Invalid password. Please try again.""

        );

      } else {

        promptString = this.l10n.get(

          ""password_label"",

          null,

          ""Enter the password to open this PDF file.""

        );

      }

      promptString.then(msg => {

        this.label.textContent = msg;

      });

    });
","  async open() {

    await this.overlayManager.open(this.overlayName);

    const passwordIncorrect =

      this.reason === PasswordResponses.INCORRECT_PASSWORD;

    if (!this._isViewerEmbedded || passwordIncorrect) {

      this.input.focus();

    }

    this.label.textContent = await this.l10n.get(

      `password_${passwordIncorrect ? ""invalid"" : ""label""}`

    );
",2021-02-22 12:43:16+01:00
038668bf8cbf73490e06a70b4d24364499ab484e,Jonas Jenwald,"Collect all l10n fallback strings, used in the viewer, in one helper function (PR 12981 follow-up)

Rather than having to spell out the English fallback strings at *every* single `IL10n.get` call-site throughout the viewer, we can simplify things by collecting them in *one* central spot.
This provides a much better overview of the fallback l10n strings used, which makes future changes easier and ensures that fallback strings occuring in multiple places cannot accidentally get out of sync.
Furthermore, by making the `fallback` parameter of the `IL10n.get` method *optional*[1] many of the call-sites (and their surrounding code) become a lot less verbose.

---
[1] It's obviously still possible to pass in a fallback string, it's just not required.",web/pdf_document_properties.js,https://github.com/mozilla/pdf.js/commit/038668bf8cbf73490e06a70b4d24364499ab484e,"    if (rawName) {

      pageName = this.l10n.get(

        ""document_properties_page_size_name_"" + rawName.toLowerCase(),

        null,

        rawName

      );

    }

    return Promise.all([

        ""document_properties_page_size_unit_"" +

          (this._isNonMetricLocale ? ""inches"" : ""millimeters""),

        null,

        this._isNonMetricLocale ? ""in"" : ""mm""

      pageName,

        ""document_properties_page_size_orientation_"" +

          (isPortrait ? ""portrait"" : ""landscape""),

        null,

        isPortrait ? ""portrait"" : ""landscape""

    ]).then(([{ width, height }, unit, name, orientation]) => {

      return this.l10n.get(

        ""document_properties_page_size_dimension_"" +

          (name ? ""name_"" : """") +

          ""string"",

        {

          width: width.toLocaleString(),

          height: height.toLocaleString(),

          unit,

          name,

          orientation,

        },

        ""{{width}}  {{height}} {{unit}} ("" +

          (name ? ""{{name}}, "" : """") +

          ""{{orientation}})""

      );

    });
","    const [{ width, height }, unit, name, orientation] = await Promise.all([

        `document_properties_page_size_unit_${

          this._isNonMetricLocale ? ""inches"" : ""millimeters""

        }`

      rawName &&

        this.l10n.get(

          `document_properties_page_size_name_${rawName.toLowerCase()}`

        ),

        `document_properties_page_size_orientation_${

          isPortrait ? ""portrait"" : ""landscape""

        }`

    ]);



    return this.l10n.get(

      `document_properties_page_size_dimension_${name ? ""name_"" : """"}string`,

      {

        width: width.toLocaleString(),

        height: height.toLocaleString(),

        unit,

        name,

        orientation,

      }

    );
",2021-02-22 12:43:16+01:00
d92b77e87f9ffb1fc9916ca18be7e6f36f2009ad,Jonas Jenwald,"Ensure that printing, triggered from scripting, won't accidentally throw in `PDFScriptingManager._updateFromSandbox` (#13104)

The issue that this patch fixes is extremely unlikely, but still theoretically possible, and I really should've caught this earlier.
Note how `BaseViewer.pagesPromise` will only be defined when a document is active, see below, and that if a printing event (triggered from scripting) arrives while the document is been closed there's a small chance that the promise isn't defined.

https://github.com/mozilla/pdf.js/blob/eb92ed12f202de4cc8b0060aac1f1a06b26f83a4/web/base_viewer.js#L426-L428",web/pdf_scripting_manager.js,https://github.com/mozilla/pdf.js/commit/d92b77e87f9ffb1fc9916ca18be7e6f36f2009ad,"          this._pdfViewer.pagesPromise.then(() => {

            this._eventBus.dispatch(""print"", { source: this });

          });
","          await this._pdfViewer.pagesPromise;

          this._eventBus.dispatch(""print"", { source: this });
",2021-03-16 14:22:39+01:00
a2bc6481a081a1093fad8b638c30d5bb8d099584,Jonas Jenwald,"[api-minor] Add an option, in `PDFDocumentProxy.cleanup`, to allow fonts to remain attached to the DOM

As mentioned in the JSDoc comment, this should not be used unless you know what you're doing, since it will lead to increased memory usage. However, in some situations (e.g. SVG-rendering), we still want to be able to run general clean-up on both the main/worker-thread while keeping loaded fonts attached to the DOM.[1]

As part of these changes, `WorkerTransport.startCleanup` is converted to an async method and we'll also skip clean-up when destruction has started (since it's redundant).

---
[1] The SVG-rendering mode is obviously not officially supported, since it's both rather incomplete and inherently slower. However with recent changes, whereby we cache repeated images on the document rather than the page level, memory usage can be *a lot* worse than before if we never attempt to release e.g. cached image-data when the viewer is in SVG-rendering mode.",src/display/api.js,https://github.com/mozilla/pdf.js/commit/a2bc6481a081a1093fad8b638c30d5bb8d099584,"  startCleanup() {

    return this.messageHandler.sendWithPromise(""Cleanup"", null).then(() => {

      for (let i = 0, ii = this.pageCache.length; i < ii; i++) {

        const page = this.pageCache[i];

        if (page) {

          const cleanupSuccessful = page.cleanup();

          if (!cleanupSuccessful) {

            throw new Error(

              `startCleanup: Page ${i + 1} is currently rendering.`

            );

          }

        }

      this.commonObjs.clear();

      this._hasJSActionsPromise = null;

    });
","  async startCleanup(keepLoadedFonts = false) {

    await this.messageHandler.sendWithPromise(""Cleanup"", null);

    if (this.destroyed) {

      return; // No need to manually clean-up when destruction has started.

    }

    for (let i = 0, ii = this.pageCache.length; i < ii; i++) {

      const page = this.pageCache[i];

      if (!page) {

        continue;

      const cleanupSuccessful = page.cleanup();



      if (!cleanupSuccessful) {

        throw new Error(`startCleanup: Page ${i + 1} is currently rendering.`);

      }

    }

    this.commonObjs.clear();

    if (!keepLoadedFonts) {

    }

    this._hasJSActionsPromise = null;
",2021-04-02 12:26:39+02:00
232fbd28e1c23039bea3e2651ef4c76ae8420be4,Jonas Jenwald,Re-factor the `PDFDocumentProxy.cleanup` unit-tests to use async/await,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/232fbd28e1c23039bea3e2651ef4c76ae8420be4,"    it(""cleans up document resources"", function (done) {

      const promise = pdfDocument.cleanup();

      promise.then(function () {

        expect(true).toEqual(true);

        done();

      }, done.fail);
","    it(""cleans up document resources"", async function () {

      await pdfDocument.cleanup();



      expect(true).toEqual(true);
",2021-04-02 12:26:46+02:00
232fbd28e1c23039bea3e2651ef4c76ae8420be4,Jonas Jenwald,Re-factor the `PDFDocumentProxy.cleanup` unit-tests to use async/await,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/232fbd28e1c23039bea3e2651ef4c76ae8420be4,"    it(""cleans up document resources after rendering of page"", function (done) {

      let canvasAndCtx;

      loadingTask.promise

        .then(pdfDoc => {

          return pdfDoc.getPage(1).then(pdfPage => {

            const viewport = pdfPage.getViewport({ scale: 1 });

            canvasAndCtx = CanvasFactory.create(

              viewport.width,

              viewport.height

            );

            const renderTask = pdfPage.render({

              canvasContext: canvasAndCtx.context,

              canvasFactory: CanvasFactory,

              viewport,

            });

            return renderTask.promise.then(() => {

              return pdfDoc.cleanup();

            });

          });

        })

        .then(() => {

          expect(true).toEqual(true);

          CanvasFactory.destroy(canvasAndCtx);

          loadingTask.destroy().then(done);

        }, done.fail);

    it(""cleans up document resources during rendering of page"", function (done) {

      let canvasAndCtx;

      loadingTask.promise

        .then(pdfDoc => {

          return pdfDoc.getPage(1).then(pdfPage => {

            const viewport = pdfPage.getViewport({ scale: 1 });

            canvasAndCtx = CanvasFactory.create(

              viewport.width,

              viewport.height

            );

            const renderTask = pdfPage.render({

              canvasContext: canvasAndCtx.context,

              canvasFactory: CanvasFactory,

              viewport,

            });

            renderTask.onContinue = function (cont) {

              waitSome(cont);

            };

            return pdfDoc

              .cleanup()

              .then(

                () => {

                  throw new Error(""shall fail cleanup"");

                },

                reason => {

                  expect(reason instanceof Error).toEqual(true);

                  expect(reason.message).toEqual(

                    ""startCleanup: Page 1 is currently rendering.""

                  );

                }

              )

              .then(() => {

                return renderTask.promise;

              })

              .then(() => {

                CanvasFactory.destroy(canvasAndCtx);

                loadingTask.destroy().then(done);

              });

          });

        })

        .catch(done.fail);
","    it(""cleans up document resources after rendering of page"", async function () {

      const pdfDoc = await loadingTask.promise;

      const pdfPage = await pdfDoc.getPage(1);

      const viewport = pdfPage.getViewport({ scale: 1 });

      const canvasAndCtx = CanvasFactory.create(

        viewport.width,

        viewport.height

      );

      const renderTask = pdfPage.render({

        canvasContext: canvasAndCtx.context,

        canvasFactory: CanvasFactory,

        viewport,

      });

      await renderTask.promise;

      await pdfDoc.cleanup();



      expect(true).toEqual(true);



      CanvasFactory.destroy(canvasAndCtx);

      await loadingTask.destroy();

    it(""cleans up document resources during rendering of page"", async function () {

      const pdfDoc = await loadingTask.promise;

      const pdfPage = await pdfDoc.getPage(1);

      const viewport = pdfPage.getViewport({ scale: 1 });

      const canvasAndCtx = CanvasFactory.create(

        viewport.width,

        viewport.height

      );

      const renderTask = pdfPage.render({

        canvasContext: canvasAndCtx.context,

        canvasFactory: CanvasFactory,

        viewport,

      });

      // Ensure that clean-up runs during rendering.

      renderTask.onContinue = function (cont) {

        waitSome(cont);

      };

      try {

        await pdfDoc.cleanup();

        throw new Error(""shall fail cleanup"");

      } catch (reason) {

        expect(reason instanceof Error).toEqual(true);

        expect(reason.message).toEqual(

          ""startCleanup: Page 1 is currently rendering.""

        );

      }

      await renderTask.promise;



      CanvasFactory.destroy(canvasAndCtx);

      await loadingTask.destroy();
",2021-04-02 12:26:46+02:00
2b2234fd5a789c059c334fda44573a52ee6fbb23,Jonas Jenwald,"[api-minor] Ensure that `PDFDocumentProxy.hasJSActions` won't fail if `MissingDataException`s are thrown during the associated worker-thread parsing

With the current implementation of `PDFDocument.hasJSActions`, in the worker-thread, we're not actually handling not-yet-loaded data correctly. This can thus fail in *two* different ways:
 - The `PDFDocument.fieldObjects` getter (and its helper method), while it may *return* a Promise, still fetches all of its data synchronously and it can thus throw a `MissingDataException` during parsing.
 - The `Catalog.jsActions` getter, which is completely synchronous, can obviously throw a `MissingDataException` during parsing.

If either of these cases occur currently, the `PDFDocumentProxy.hasJSActions` method in the API can either return a *rejected* Promise (which it never should) or possibly ""hang"" and never resolve.

*Please note:* While I've not *yet* seen this error in an actual PDF document, it can happen during loading if you're unlucky enough with e.g. the structure of the PDF document and/or the download speed offered by the server.
This patch is thus based on code-inspection *and* on manually throwing a `MissingDataException` on the first access of `Catalog.jsActions` to simulate this situation.

Finally, this patch adds a couple of *API* unit-tests for this (since none existed).",src/core/document.js,https://github.com/mozilla/pdf.js/commit/2b2234fd5a789c059c334fda44573a52ee6fbb23,"    return shadow(

      this,

      ""hasJSActions"",

      this.fieldObjects.then(fieldObjects => {

        return (

          (fieldObjects !== null &&

            Object.values(fieldObjects).some(fieldObject =>

              fieldObject.some(object => object.actions !== null)

            )) ||

          !!this.catalog.jsActions

        );

      })

    );
","    const promise = this.pdfManager.ensure(this, ""_parseHasJSActions"");

    return shadow(this, ""hasJSActions"", promise);

  }



  /**

   * @private

   */

  async _parseHasJSActions() {

    const [catalogJsActions, fieldObjects] = await Promise.all([

      this.pdfManager.ensureCatalog(""jsActions""),

      this.pdfManager.ensure(this, ""fieldObjects""),

    ]);



    if (catalogJsActions) {

      return true;

    }

    if (fieldObjects) {

      return Object.values(fieldObjects).some(fieldObject =>

        fieldObject.some(object => object.actions !== null)

      );

    }

    return false;
",2021-04-13 12:30:20+02:00
a2811e925dc064b5f7832ee45dbb44871111e4f3,Tim van der Meij,Convert done callbacks to async/await in `test/unit/util_spec.js`,test/unit/util_spec.js,https://github.com/mozilla/pdf.js/commit/a2811e925dc064b5f7832ee45dbb44871111e4f3,"    it(""should resolve with correct data"", function (done) {

      promiseCapability.promise.then(function (data) {

        expect(promiseCapability.settled).toEqual(true);



        expect(data).toEqual({ test: ""abc"" });

        done();

      }, done.fail);

    it(""should reject with correct reason"", function (done) {

      promiseCapability.promise.then(done.fail, function (reason) {

        expect(promiseCapability.settled).toEqual(true);

        done();

      });
","    it(""should resolve with correct data"", async function () {

      const data = await promiseCapability.promise;

      expect(promiseCapability.settled).toEqual(true);

      expect(data).toEqual({ test: ""abc"" });

    it(""should reject with correct reason"", async function () {

      try {

        await promiseCapability.promise;

        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(promiseCapability.settled).toEqual(true);

      }
",2021-04-11 19:26:38+02:00
a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8,Tim van der Meij,Convert done callbacks to async/await in `test/unit/ui_utils_spec.js`,test/unit/ui_utils_spec.js,https://github.com/mozilla/pdf.js/commit/a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8,"        done.fail(""shall not dispatch DOM event."");

      Promise.resolve().then(() => {

        expect(count).toEqual(1);

        document.removeEventListener(""test"", domEventListener);

        done();

      });
","        // Shouldn't get here.

        expect(false).toEqual(true);

      await Promise.resolve();

      expect(count).toEqual(1);

      document.removeEventListener(""test"", domEventListener);
",2021-04-11 19:51:21+02:00
a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8,Tim van der Meij,Convert done callbacks to async/await in `test/unit/ui_utils_spec.js`,test/unit/ui_utils_spec.js,https://github.com/mozilla/pdf.js/commit/a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8,"          throw new Error(""Should reject invalid parameters."");

      Promise.all([invalidTarget, invalidName, invalidDelay]).then(

        done,

        done.fail

      );

    it(""should resolve on event, using the DOM"", function (done) {

        pending(""Document in not supported in Node.js."");
","          // Shouldn't get here.

          expect(false).toEqual(true);

      await Promise.all([invalidTarget, invalidName, invalidDelay]);

    it(""should resolve on event, using the DOM"", async function () {

        pending(""Document is not supported in Node.js."");
",2021-04-11 19:51:21+02:00
a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8,Tim van der Meij,Convert done callbacks to async/await in `test/unit/ui_utils_spec.js`,test/unit/ui_utils_spec.js,https://github.com/mozilla/pdf.js/commit/a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8,"      buttonClicked.then(function (type) {

        expect(type).toEqual(WaitOnType.EVENT);

        done();

      }, done.fail);

    it(""should resolve on timeout, using the DOM"", function (done) {

        pending(""Document in not supported in Node.js."");
","      const type = await buttonClicked;

      expect(type).toEqual(WaitOnType.EVENT);

    it(""should resolve on timeout, using the DOM"", async function () {

        pending(""Document is not supported in Node.js."");
",2021-04-11 19:51:21+02:00
a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8,Tim van der Meij,Convert done callbacks to async/await in `test/unit/ui_utils_spec.js`,test/unit/ui_utils_spec.js,https://github.com/mozilla/pdf.js/commit/a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8,"      buttonClicked.then(function (type) {

        expect(type).toEqual(WaitOnType.TIMEOUT);

        done();

      }, done.fail);

    it(""should resolve on event, using the EventBus"", function (done) {
","      const type = await buttonClicked;

      expect(type).toEqual(WaitOnType.TIMEOUT);

    it(""should resolve on event, using the EventBus"", async function () {
",2021-04-11 19:51:21+02:00
a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8,Tim van der Meij,Convert done callbacks to async/await in `test/unit/ui_utils_spec.js`,test/unit/ui_utils_spec.js,https://github.com/mozilla/pdf.js/commit/a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8,"      pageRendered.then(function (type) {

        expect(type).toEqual(WaitOnType.EVENT);

        done();

      }, done.fail);

    it(""should resolve on timeout, using the EventBus"", function (done) {
","      const type = await pageRendered;

      expect(type).toEqual(WaitOnType.EVENT);

    it(""should resolve on timeout, using the EventBus"", async function () {
",2021-04-11 19:51:21+02:00
a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8,Tim van der Meij,Convert done callbacks to async/await in `test/unit/ui_utils_spec.js`,test/unit/ui_utils_spec.js,https://github.com/mozilla/pdf.js/commit/a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8,"      pageRendered.then(function (type) {

        expect(type).toEqual(WaitOnType.TIMEOUT);

        done();

      }, done.fail);
","      const type = await pageRendered;

      expect(type).toEqual(WaitOnType.TIMEOUT);
",2021-04-11 19:51:21+02:00
99dc0d6b65ea956b6201ea0569134ab411286e3a,Tim van der Meij,Convert done callbacks to async/await in `test/unit/primitives_spec.js`,test/unit/primitives_spec.js,https://github.com/mozilla/pdf.js/commit/99dc0d6b65ea956b6201ea0569134ab411286e3a,"    it(""should asynchronously fetch unknown keys"", function (done) {

      Promise.all(keyPromises)

        .then(function (values) {

          expect(values[0]).toBeUndefined();

          expect(values[1]).toBeUndefined();

          done();

        })

        .catch(function (reason) {

          done.fail(reason);

        });

    it(""should asynchronously fetch correct values for multiple stored keys"", function (done) {

      Promise.all(keyPromises)

        .then(function (values) {

          expect(values[0]).toEqual(testFontFile3);

          expect(values[1]).toEqual(testFontFile2);

          expect(values[2]).toEqual(testFontFile);

          done();

        })

        .catch(function (reason) {

          done.fail(reason);

        });
","    it(""should asynchronously fetch unknown keys"", async function () {

      const values = await Promise.all(keyPromises);

      expect(values[0]).toBeUndefined();

      expect(values[1]).toBeUndefined();

    it(""should asynchronously fetch correct values for multiple stored keys"", async function () {

      const values = await Promise.all(keyPromises);

      expect(values[0]).toEqual(testFontFile3);

      expect(values[1]).toEqual(testFontFile2);

      expect(values[2]).toEqual(testFontFile);
",2021-04-11 19:56:58+02:00
99dc0d6b65ea956b6201ea0569134ab411286e3a,Tim van der Meij,Convert done callbacks to async/await in `test/unit/primitives_spec.js`,test/unit/primitives_spec.js,https://github.com/mozilla/pdf.js/commit/99dc0d6b65ea956b6201ea0569134ab411286e3a,"      fontDict

        .getAsync(""FontFile"", ""FontFile2"", ""FontFile3"")

        .then(function (value) {

          expect(value).toEqual(testFontFile);

          done();

        })

        .catch(function (reason) {

          done.fail(reason);

        });
","      const value = await fontDict.getAsync(

        ""FontFile"",

        ""FontFile2"",

        ""FontFile3""

      );

      expect(value).toEqual(testFontFile);
",2021-04-11 19:56:58+02:00
fcf4d02fca301705419b8b3a94319fc899d6c230,Tim van der Meij,Convert done callbacks to async/await in `test/unit/node_stream_spec.js`,test/unit/node_stream_spec.js,https://github.com/mozilla/pdf.js/commit/fcf4d02fca301705419b8b3a94319fc899d6c230,"    const readPromise = Promise.all([read1(), read2(), promise1, promise2]);

    readPromise

      .then(result => {

        expect(isStreamingSupported1).toEqual(false);

        expect(isRangeSupported1).toEqual(false);

        expect(isStreamingSupported2).toEqual(false);

        expect(isRangeSupported2).toEqual(false);

        expect(len1).toEqual(pdfLength);

        expect(len1).toEqual(len2);

        done();

      })

      .catch(reason => {

        done.fail(reason);

      });

  it(""read custom ranges for both http(s) and filesystem urls"", function (done) {
","    await Promise.all([read1(), read2(), promise1, promise2]);



    expect(isStreamingSupported1).toEqual(false);

    expect(isRangeSupported1).toEqual(false);

    expect(isStreamingSupported2).toEqual(false);

    expect(isRangeSupported2).toEqual(false);

    expect(len1).toEqual(pdfLength);

    expect(len1).toEqual(len2);

  it(""read custom ranges for both http(s) and filesystem urls"", async function () {
",2021-04-11 20:01:52+02:00
5607484402adc89d9c8f3d8a7697c86089676f80,Tim van der Meij,Convert done callbacks to async/await in `test/unit/network_spec.js`,test/unit/network_spec.js,https://github.com/mozilla/pdf.js/commit/5607484402adc89d9c8f3d8a7697c86089676f80,"    const readPromise = Promise.all([read(), promise]);



    readPromise

      .then(function (page) {

        expect(len).toEqual(pdf1Length);

        expect(count).toEqual(1);

        expect(isStreamingSupported).toEqual(false);

        expect(isRangeSupported).toEqual(false);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""read custom ranges"", function (done) {
","    await Promise.all([read(), promise]);



    expect(len).toEqual(pdf1Length);

    expect(count).toEqual(1);

    expect(isStreamingSupported).toEqual(false);

    expect(isRangeSupported).toEqual(false);

  it(""read custom ranges"", async function () {
",2021-04-11 20:03:41+02:00
5607484402adc89d9c8f3d8a7697c86089676f80,Tim van der Meij,Convert done callbacks to async/await in `test/unit/network_spec.js`,test/unit/network_spec.js,https://github.com/mozilla/pdf.js/commit/5607484402adc89d9c8f3d8a7697c86089676f80,"    const readPromises = Promise.all([

    readPromises

      .then(function () {

        expect(result1.value).toEqual(rangeSize);

        expect(result2.value).toEqual(tailSize);

        expect(isStreamingSupported).toEqual(false);

        expect(isRangeSupported).toEqual(true);

        expect(fullReaderCancelled).toEqual(true);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });
","    await Promise.all([

    expect(result1.value).toEqual(rangeSize);

    expect(result2.value).toEqual(tailSize);

    expect(isStreamingSupported).toEqual(false);

    expect(isRangeSupported).toEqual(true);

    expect(fullReaderCancelled).toEqual(true);
",2021-04-11 20:03:41+02:00
a1c1e1b9f8695617a67cbe209e237162f439d96e,Tim van der Meij,Convert done callbacks to async/await in `test/unit/fetch_stream_spec.js`,test/unit/fetch_stream_spec.js,https://github.com/mozilla/pdf.js/commit/a1c1e1b9f8695617a67cbe209e237162f439d96e,"    const readPromise = Promise.all([read(), promise]);

    readPromise

      .then(function () {

        expect(len).toEqual(pdfLength);

        expect(isStreamingSupported).toEqual(true);

        expect(isRangeSupported).toEqual(false);

        done();

      })

      .catch(done.fail);

  it(""read ranges with streaming"", function (done) {
","    await Promise.all([read(), promise]);



    expect(len).toEqual(pdfLength);

    expect(isStreamingSupported).toEqual(true);

    expect(isRangeSupported).toEqual(false);

  it(""read ranges with streaming"", async function () {
",2021-04-11 20:07:27+02:00
a1c1e1b9f8695617a67cbe209e237162f439d96e,Tim van der Meij,Convert done callbacks to async/await in `test/unit/fetch_stream_spec.js`,test/unit/fetch_stream_spec.js,https://github.com/mozilla/pdf.js/commit/a1c1e1b9f8695617a67cbe209e237162f439d96e,"    const readPromise = Promise.all([

    readPromise

      .then(function () {

        expect(isStreamingSupported).toEqual(true);

        expect(isRangeSupported).toEqual(true);

        expect(fullReaderCancelled).toEqual(true);

        expect(result1.value).toEqual(rangeSize);

        expect(result2.value).toEqual(tailSize);

        done();

      })

      .catch(done.fail);
","    await Promise.all([



    expect(isStreamingSupported).toEqual(true);

    expect(isRangeSupported).toEqual(true);

    expect(fullReaderCancelled).toEqual(true);

    expect(result1.value).toEqual(rangeSize);

    expect(result2.value).toEqual(tailSize);
",2021-04-11 20:07:27+02:00
c1e9f6025f7c530a0e81458f34eb2532b3e49f22,Tim van der Meij,Convert done callbacks to async/await in `test/unit/custom_spec.js`,test/unit/custom_spec.js,https://github.com/mozilla/pdf.js/commit/c1e9f6025f7c530a0e81458f34eb2532b3e49f22,"  beforeAll(function (done) {

    loadingTask.promise

      .then(function (doc) {

        return doc.getPage(1);

      })

      .then(function (data) {

        page = data;

        done();

      })

      .catch(done.fail);

  afterAll(function (done) {

    loadingTask.destroy().then(done);

  it(""renders to canvas with a default white background"", function (done) {
","  beforeAll(async function () {

    const doc = await loadingTask.promise;

    const data = await doc.getPage(1);

    page = data;

  afterAll(async function () {

    await loadingTask.destroy();

  it(""renders to canvas with a default white background"", async function () {
",2021-04-11 20:11:42+02:00
c1e9f6025f7c530a0e81458f34eb2532b3e49f22,Tim van der Meij,Convert done callbacks to async/await in `test/unit/custom_spec.js`,test/unit/custom_spec.js,https://github.com/mozilla/pdf.js/commit/c1e9f6025f7c530a0e81458f34eb2532b3e49f22,"    renderTask.promise

      .then(function () {

        expect(getTopLeftPixel(canvasAndCtx.context)).toEqual({

          r: 255,

          g: 255,

          b: 255,

          a: 255,

        });

        CanvasFactory.destroy(canvasAndCtx);

        done();

      })

      .catch(done.fail);

  it(""renders to canvas with a custom background"", function (done) {
","    await renderTask.promise;



    expect(getTopLeftPixel(canvasAndCtx.context)).toEqual({

      r: 255,

      g: 255,

      b: 255,

      a: 255,

    });

    CanvasFactory.destroy(canvasAndCtx);

  it(""renders to canvas with a custom background"", async function () {
",2021-04-11 20:11:42+02:00
c1e9f6025f7c530a0e81458f34eb2532b3e49f22,Tim van der Meij,Convert done callbacks to async/await in `test/unit/custom_spec.js`,test/unit/custom_spec.js,https://github.com/mozilla/pdf.js/commit/c1e9f6025f7c530a0e81458f34eb2532b3e49f22,"    renderTask.promise

      .then(function () {

        expect(getTopLeftPixel(canvasAndCtx.context)).toEqual({

          r: 255,

          g: 0,

          b: 0,

          a: 255,

        });

        CanvasFactory.destroy(canvasAndCtx);

        done();

      })

      .catch(done.fail);
","    await renderTask.promise;



    expect(getTopLeftPixel(canvasAndCtx.context)).toEqual({

      r: 255,

      g: 0,

      b: 0,

      a: 255,

    });

    CanvasFactory.destroy(canvasAndCtx);
",2021-04-11 20:11:42+02:00
bc8c0bbbfda12f8c80156097066b7b7036e6c625,Tim van der Meij,Convert done callbacks to async/await in `test/unit/display_svg_spec.js`,test/unit/display_svg_spec.js,https://github.com/mozilla/pdf.js/commit/bc8c0bbbfda12f8c80156097066b7b7036e6c625,"  beforeAll(function (done) {

    loadingTask.promise.then(function (doc) {

      doc.getPage(1).then(function (firstPage) {

        page = firstPage;

        done();

      });

    });

  afterAll(function (done) {

    loadingTask.destroy().then(done);
","

  beforeAll(async function () {

    const doc = await loadingTask.promise;

    page = await doc.getPage(1);



  afterAll(async function () {

    await loadingTask.destroy();
",2021-04-14 21:57:07+02:00
bc8c0bbbfda12f8c80156097066b7b7036e6c625,Tim van der Meij,Convert done callbacks to async/await in `test/unit/display_svg_spec.js`,test/unit/display_svg_spec.js,https://github.com/mozilla/pdf.js/commit/bc8c0bbbfda12f8c80156097066b7b7036e6c625,"    it(""should produce a reasonably small svg:image"", function (done) {

      withZlib(true, getSVGImage)

        .then(function (svgImg) {

          expect(svgImg.nodeName).toBe(""svg:image"");

          expect(svgImg.getAttributeNS(null, ""width"")).toBe(""200px"");

          expect(svgImg.getAttributeNS(null, ""height"")).toBe(""100px"");

          const imgUrl = svgImg.getAttributeNS(XLINK_NS, ""href"");

          // forceDataSchema = true, so the generated URL should be a data:-URL.

          expect(imgUrl).toMatch(/^data:image\/png;base64,/);

          // Test whether the generated image has a reasonable file size.

          // I obtained a data URL of size 366 with Node 8.1.3 and zlib 1.2.11.

          // Without zlib (uncompressed), the size of the data URL was excessive

          // (80246).

          expect(imgUrl.length).toBeLessThan(367);

        })

        .then(done, done.fail);

    it(""should be able to produce a svg:image without zlib"", function (done) {

      withZlib(false, getSVGImage)

        .then(function (svgImg) {

          expect(svgImg.nodeName).toBe(""svg:image"");

          expect(svgImg.getAttributeNS(null, ""width"")).toBe(""200px"");

          expect(svgImg.getAttributeNS(null, ""height"")).toBe(""100px"");

          const imgUrl = svgImg.getAttributeNS(XLINK_NS, ""href"");

          expect(imgUrl).toMatch(/^data:image\/png;base64,/);

          // The size of our naively generated PNG file is excessive :(

          expect(imgUrl.length).toBe(80246);

        })

        .then(done, done.fail);
","    it(""should produce a reasonably small svg:image"", async function () {

      const svgImg = await withZlib(true, getSVGImage);

      expect(svgImg.nodeName).toBe(""svg:image"");

      expect(svgImg.getAttributeNS(null, ""width"")).toBe(""200px"");

      expect(svgImg.getAttributeNS(null, ""height"")).toBe(""100px"");

      const imgUrl = svgImg.getAttributeNS(XLINK_NS, ""href"");

      // forceDataSchema = true, so the generated URL should be a data:-URL.

      expect(imgUrl).toMatch(/^data:image\/png;base64,/);

      // Test whether the generated image has a reasonable file size.

      // I obtained a data URL of size 366 with Node 8.1.3 and zlib 1.2.11.

      // Without zlib (uncompressed), the size of the data URL was excessive

      // (80246).

      expect(imgUrl.length).toBeLessThan(367);

    it(""should be able to produce a svg:image without zlib"", async function () {

      const svgImg = await withZlib(false, getSVGImage);

      expect(svgImg.nodeName).toBe(""svg:image"");

      expect(svgImg.getAttributeNS(null, ""width"")).toBe(""200px"");

      expect(svgImg.getAttributeNS(null, ""height"")).toBe(""100px"");

      const imgUrl = svgImg.getAttributeNS(XLINK_NS, ""href"");

      expect(imgUrl).toMatch(/^data:image\/png;base64,/);

      // The size of our naively generated PNG file is excessive :(

      expect(imgUrl.length).toBe(80246);
",2021-04-14 21:57:07+02:00
43eb4302ff3f77108e24a9a5a8a3b97e7c589439,Tim van der Meij,Convert done callbacks to async/await in `test/unit/message_handler_spec.js`,test/unit/message_handler_spec.js,https://github.com/mozilla/pdf.js/commit/43eb4302ff3f77108e24a9a5a8a3b97e7c589439,"      sleep(10)

        .then(() => {

          expect(log).toEqual("""");

          return reader.read();

        })

        .then(result => {

          expect(log).toEqual(""p"");

          expect(result.value).toEqual(""hi"");

          expect(result.done).toEqual(false);

          return sleep(10);

        })

        .then(() => {

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual(undefined);

          expect(result.done).toEqual(true);

          done();

        });

    it(""should not read any data when cancelled"", function (done) {
","

      await sleep(10);

      expect(log).toEqual("""");



      let result = await reader.read();

      expect(log).toEqual(""p"");

      expect(result.value).toEqual(""hi"");

      expect(result.done).toEqual(false);



      await sleep(10);

      result = await reader.read();

      expect(result.value).toEqual(undefined);

      expect(result.done).toEqual(true);

    it(""should not read any data when cancelled"", async function () {
",2021-04-14 21:52:23+02:00
43eb4302ff3f77108e24a9a5a8a3b97e7c589439,Tim van der Meij,Convert done callbacks to async/await in `test/unit/message_handler_spec.js`,test/unit/message_handler_spec.js,https://github.com/mozilla/pdf.js/commit/43eb4302ff3f77108e24a9a5a8a3b97e7c589439,"      sleep(10)

        .then(() => {

          expect(log).toEqual(""01"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual([1, 2, 3, 4]);

          expect(result.done).toEqual(false);

          return sleep(10);

        })

        .then(() => {

          expect(log).toEqual(""01p2"");

          return reader.cancel(new AbortException(""reader cancelled.""));

        })

        .then(() => {

          expect(log).toEqual(""01p2c4"");

          done();

        });

    it(""should not read when errored"", function (done) {
","      await sleep(10);

      expect(log).toEqual(""01"");



      const result = await reader.read();

      expect(result.value).toEqual([1, 2, 3, 4]);

      expect(result.done).toEqual(false);



      await sleep(10);

      expect(log).toEqual(""01p2"");



      await reader.cancel(new AbortException(""reader cancelled.""));

      expect(log).toEqual(""01p2c4"");

    it(""should not read when errored"", async function () {
",2021-04-14 21:52:23+02:00
43eb4302ff3f77108e24a9a5a8a3b97e7c589439,Tim van der Meij,Convert done callbacks to async/await in `test/unit/message_handler_spec.js`,test/unit/message_handler_spec.js,https://github.com/mozilla/pdf.js/commit/43eb4302ff3f77108e24a9a5a8a3b97e7c589439,"      sleep(10)

        .then(() => {

          expect(log).toEqual(""01"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual([1, 2, 3, 4]);

          expect(result.done).toEqual(false);

          return reader.read();

        })

        .catch(reason => {

          expect(log).toEqual(""01pe"");

          expect(reason instanceof UnknownErrorException).toEqual(true);

          expect(reason.message).toEqual(""should not read when errored"");

          done();

        });

    it(""should read data with blocking promise"", function (done) {
","      await sleep(10);

      expect(log).toEqual(""01"");

      const result = await reader.read();

      expect(result.value).toEqual([1, 2, 3, 4]);

      expect(result.done).toEqual(false);



      try {

        await reader.read();



        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(log).toEqual(""01pe"");

        expect(reason instanceof UnknownErrorException).toEqual(true);

        expect(reason.message).toEqual(""should not read when errored"");

      }

    it(""should read data with blocking promise"", async function () {
",2021-04-14 21:52:23+02:00
43eb4302ff3f77108e24a9a5a8a3b97e7c589439,Tim van der Meij,Convert done callbacks to async/await in `test/unit/message_handler_spec.js`,test/unit/message_handler_spec.js,https://github.com/mozilla/pdf.js/commit/43eb4302ff3f77108e24a9a5a8a3b97e7c589439,"      sleep(10)

        .then(() => {

          expect(log).toEqual(""01"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual([1, 2, 3, 4]);

          expect(result.done).toEqual(false);

          return sleep(10);

        })

        .then(() => {

          expect(log).toEqual(""01p2"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual([5, 6, 7, 8]);

          expect(result.done).toEqual(false);

          return sleep(10);

        })

        .then(() => {

          expect(log).toEqual(""01p2p"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual(undefined);

          expect(result.done).toEqual(true);

          done();

        });

      function (done) {
","      await sleep(10);

      expect(log).toEqual(""01"");



      let result = await reader.read();

      expect(result.value).toEqual([1, 2, 3, 4]);

      expect(result.done).toEqual(false);



      await sleep(10);

      expect(log).toEqual(""01p2"");



      result = await reader.read();

      expect(result.value).toEqual([5, 6, 7, 8]);

      expect(result.done).toEqual(false);



      await sleep(10);

      expect(log).toEqual(""01p2p"");



      result = await reader.read();

      expect(result.value).toEqual(undefined);

      expect(result.done).toEqual(true);

      async function () {
",2021-04-14 21:52:23+02:00
43eb4302ff3f77108e24a9a5a8a3b97e7c589439,Tim van der Meij,Convert done callbacks to async/await in `test/unit/message_handler_spec.js`,test/unit/message_handler_spec.js,https://github.com/mozilla/pdf.js/commit/43eb4302ff3f77108e24a9a5a8a3b97e7c589439,"        sleep(10)

          .then(() => {

            expect(log).toEqual(""012"");

            return reader.read();

          })

          .then(result => {

            expect(result.value).toEqual([1, 2, 3, 4]);

            expect(result.done).toEqual(false);

            return sleep(10);

          })

          .then(() => {

            expect(log).toEqual(""012p"");

            return reader.read();

          })

          .then(result => {

            expect(result.value).toEqual([5, 6, 7, 8]);

            expect(result.done).toEqual(false);

            return sleep(10);

          })

          .then(() => {

            expect(log).toEqual(""012p"");

            return reader.read();

          })

          .then(result => {

            expect(result.value).toEqual(undefined);

            expect(result.done).toEqual(true);

            done();

          });

    it(""should ignore any pull after close is called"", function (done) {
","        await sleep(10);

        expect(log).toEqual(""012"");

        let result = await reader.read();

        expect(result.value).toEqual([1, 2, 3, 4]);

        expect(result.done).toEqual(false);



        await sleep(10);

        expect(log).toEqual(""012p"");



        result = await reader.read();

        expect(result.value).toEqual([5, 6, 7, 8]);

        expect(result.done).toEqual(false);



        await sleep(10);

        expect(log).toEqual(""012p"");



        result = await reader.read();

        expect(result.value).toEqual(undefined);

        expect(result.done).toEqual(true);

    it(""should ignore any pull after close is called"", async function () {
",2021-04-14 21:52:23+02:00
43eb4302ff3f77108e24a9a5a8a3b97e7c589439,Tim van der Meij,Convert done callbacks to async/await in `test/unit/message_handler_spec.js`,test/unit/message_handler_spec.js,https://github.com/mozilla/pdf.js/commit/43eb4302ff3f77108e24a9a5a8a3b97e7c589439,"      sleep(10)

        .then(() => {

          expect(log).toEqual(""01"");

          capability.resolve();

          return capability.promise.then(() => {

            return reader.read();

          });

        })

        .then(result => {

          expect(result.value).toEqual([1, 2, 3, 4]);

          expect(result.done).toEqual(false);

          return sleep(10);

        })

        .then(() => {

          expect(log).toEqual(""01"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual(undefined);

          expect(result.done).toEqual(true);

          done();

        });
","      await sleep(10);

      expect(log).toEqual(""01"");

      capability.resolve();

      await capability.promise;



      let result = await reader.read();

      expect(result.value).toEqual([1, 2, 3, 4]);

      expect(result.done).toEqual(false);



      await sleep(10);

      expect(log).toEqual(""01"");



      result = await reader.read();

      expect(result.value).toEqual(undefined);

      expect(result.done).toEqual(true);
",2021-04-14 21:52:23+02:00
38ed655562c47dcac2888ecd49775bd87980f1e8,Tim van der Meij,Convert done callbacks to async/await in `test/unit/cmap_spec.js`,test/unit/cmap_spec.js,https://github.com/mozilla/pdf.js/commit/38ed655562c47dcac2888ecd49775bd87980f1e8,"  it(""parses beginbfchar"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.lookup(0x03)).toEqual(String.fromCharCode(0x00));

        expect(cmap.lookup(0x04)).toEqual(String.fromCharCode(0x01));

        expect(cmap.lookup(0x05)).toBeUndefined();

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses beginbfrange with range"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.lookup(0x05)).toBeUndefined();

        expect(cmap.lookup(0x06)).toEqual(String.fromCharCode(0x00));

        expect(cmap.lookup(0x0b)).toEqual(String.fromCharCode(0x05));

        expect(cmap.lookup(0x0c)).toBeUndefined();

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses beginbfrange with array"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.lookup(0x0c)).toBeUndefined();

        expect(cmap.lookup(0x0d)).toEqual(0x00);

        expect(cmap.lookup(0x12)).toEqual(0x05);

        expect(cmap.lookup(0x13)).toBeUndefined();

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses begincidchar"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.lookup(0x14)).toEqual(0x00);

        expect(cmap.lookup(0x15)).toBeUndefined();

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses begincidrange"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.lookup(0x15)).toBeUndefined();

        expect(cmap.lookup(0x16)).toEqual(0x00);

        expect(cmap.lookup(0x1b)).toEqual(0x05);

        expect(cmap.lookup(0x1c)).toBeUndefined();

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""decodes codespace ranges"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        const c = {};

        cmap.readCharCode(String.fromCharCode(1), 0, c);

        expect(c.charcode).toEqual(1);

        expect(c.length).toEqual(1);

        cmap.readCharCode(String.fromCharCode(0, 0, 0, 3), 0, c);

        expect(c.charcode).toEqual(3);

        expect(c.length).toEqual(4);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""decodes 4 byte codespace ranges"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        const c = {};

        cmap.readCharCode(String.fromCharCode(0x8e, 0xa1, 0xa1, 0xa1), 0, c);

        expect(c.charcode).toEqual(0x8ea1a1a1);

        expect(c.length).toEqual(4);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""read usecmap"", function (done) {

    const cmapPromise = CMapFactory.create({

    cmapPromise

      .then(function (cmap) {

        expect(cmap instanceof CMap).toEqual(true);

        expect(cmap.useCMap).not.toBeNull();

        expect(cmap.builtInCMap).toBeFalsy();

        expect(cmap.length).toEqual(0x20a7);

        expect(cmap.isIdentityCMap).toEqual(false);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses cmapname"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.name).toEqual(""Identity-H"");

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses wmode"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.vertical).toEqual(true);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""loads built in cmap"", function (done) {

    const cmapPromise = CMapFactory.create({

    cmapPromise

      .then(function (cmap) {

        expect(cmap instanceof CMap).toEqual(true);

        expect(cmap.useCMap).toBeNull();

        expect(cmap.builtInCMap).toBeTruthy();

        expect(cmap.length).toEqual(0x20a7);

        expect(cmap.isIdentityCMap).toEqual(false);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""loads built in identity cmap"", function (done) {

    const cmapPromise = CMapFactory.create({

    cmapPromise

      .then(function (cmap) {

        expect(cmap instanceof IdentityCMap).toEqual(true);

        expect(cmap.vertical).toEqual(false);

        expect(cmap.length).toEqual(0x10000);

        expect(function () {

          return cmap.isIdentityCMap;

        }).toThrow(new Error(""should not access .isIdentityCMap""));

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""attempts to load a non-existent built-in CMap"", function (done) {

    const cmapPromise = CMapFactory.create({

      encoding: Name.get(""null""),

      fetchBuiltInCMap,

      useCMap: null,

    });

    cmapPromise.then(

      function () {

        done.fail(""No CMap should be loaded"");

      },

      function (reason) {

        expect(reason instanceof Error).toEqual(true);

        expect(reason.message).toEqual(""Unknown CMap name: null"");

        done();

      }

    );

  it(""attempts to load a built-in CMap without the necessary API parameters"", function (done) {

      return CMapReaderFactory.fetch({

        name,

    }

    const cmapPromise = CMapFactory.create({

      encoding: Name.get(""Adobe-Japan1-1""),

      fetchBuiltInCMap: tmpFetchBuiltInCMap,

      useCMap: null,

    });

    cmapPromise.then(

      function () {

        done.fail(""No CMap should be loaded"");

      },

      function (reason) {

        expect(reason instanceof Error).toEqual(true);

        expect(reason.message).toEqual(

          'The CMap ""baseUrl"" parameter must be specified, ensure that ' +

            'the ""cMapUrl"" and ""cMapPacked"" API parameters are provided.'

        );

        done();

      }

    );

  it(""attempts to load a built-in CMap with inconsistent API parameters"", function (done) {

      return CMapReaderFactory.fetch({

        name,

    }

    const cmapPromise = CMapFactory.create({

      encoding: Name.get(""Adobe-Japan1-1""),

      fetchBuiltInCMap: tmpFetchBuiltInCMap,

      useCMap: null,

    });

    cmapPromise.then(

      function () {

        done.fail(""No CMap should be loaded"");

      },

      function (reason) {

        expect(reason instanceof Error).toEqual(true);

        const message = reason.message;

        expect(message.startsWith(""Unable to load CMap at: "")).toEqual(true);

        expect(message.endsWith(""/external/bcmaps/Adobe-Japan1-1"")).toEqual(

          true

        );

        done();

      }

    );
","  it(""parses beginbfchar"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    expect(cmap.lookup(0x03)).toEqual(String.fromCharCode(0x00));

    expect(cmap.lookup(0x04)).toEqual(String.fromCharCode(0x01));

    expect(cmap.lookup(0x05)).toBeUndefined();



  it(""parses beginbfrange with range"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    expect(cmap.lookup(0x05)).toBeUndefined();

    expect(cmap.lookup(0x06)).toEqual(String.fromCharCode(0x00));

    expect(cmap.lookup(0x0b)).toEqual(String.fromCharCode(0x05));

    expect(cmap.lookup(0x0c)).toBeUndefined();



  it(""parses beginbfrange with array"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    expect(cmap.lookup(0x0c)).toBeUndefined();

    expect(cmap.lookup(0x0d)).toEqual(0x00);

    expect(cmap.lookup(0x12)).toEqual(0x05);

    expect(cmap.lookup(0x13)).toBeUndefined();



  it(""parses begincidchar"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    expect(cmap.lookup(0x14)).toEqual(0x00);

    expect(cmap.lookup(0x15)).toBeUndefined();



  it(""parses begincidrange"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    expect(cmap.lookup(0x15)).toBeUndefined();

    expect(cmap.lookup(0x16)).toEqual(0x00);

    expect(cmap.lookup(0x1b)).toEqual(0x05);

    expect(cmap.lookup(0x1c)).toBeUndefined();



  it(""decodes codespace ranges"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    const c = {};

    cmap.readCharCode(String.fromCharCode(1), 0, c);

    expect(c.charcode).toEqual(1);

    expect(c.length).toEqual(1);

    cmap.readCharCode(String.fromCharCode(0, 0, 0, 3), 0, c);

    expect(c.charcode).toEqual(3);

    expect(c.length).toEqual(4);



  it(""decodes 4 byte codespace ranges"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    const c = {};

    cmap.readCharCode(String.fromCharCode(0x8e, 0xa1, 0xa1, 0xa1), 0, c);

    expect(c.charcode).toEqual(0x8ea1a1a1);

    expect(c.length).toEqual(4);



  it(""read usecmap"", async function () {

    const cmap = await CMapFactory.create({

    expect(cmap instanceof CMap).toEqual(true);

    expect(cmap.useCMap).not.toBeNull();

    expect(cmap.builtInCMap).toBeFalsy();

    expect(cmap.length).toEqual(0x20a7);

    expect(cmap.isIdentityCMap).toEqual(false);



  it(""parses cmapname"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    expect(cmap.name).toEqual(""Identity-H"");



  it(""parses wmode"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    expect(cmap.vertical).toEqual(true);



  it(""loads built in cmap"", async function () {

    const cmap = await CMapFactory.create({

    expect(cmap instanceof CMap).toEqual(true);

    expect(cmap.useCMap).toBeNull();

    expect(cmap.builtInCMap).toBeTruthy();

    expect(cmap.length).toEqual(0x20a7);

    expect(cmap.isIdentityCMap).toEqual(false);



  it(""loads built in identity cmap"", async function () {

    const cmap = await CMapFactory.create({

    expect(cmap instanceof IdentityCMap).toEqual(true);

    expect(cmap.vertical).toEqual(false);

    expect(cmap.length).toEqual(0x10000);

    expect(function () {

      return cmap.isIdentityCMap;

    }).toThrow(new Error(""should not access .isIdentityCMap""));

  it(""attempts to load a non-existent built-in CMap"", async function () {

    try {

      await CMapFactory.create({

        encoding: Name.get(""null""),

        fetchBuiltInCMap,

        useCMap: null,

      });



      // Shouldn't get here.

      expect(false).toEqual(true);

    } catch (reason) {

      expect(reason instanceof Error).toEqual(true);

      expect(reason.message).toEqual(""Unknown CMap name: null"");

    }

  it(""attempts to load a built-in CMap without the necessary API parameters"", async function () {

      return CMapReaderFactory.fetch({ name });

    }

    try {

      await CMapFactory.create({

        encoding: Name.get(""Adobe-Japan1-1""),

        fetchBuiltInCMap: tmpFetchBuiltInCMap,

        useCMap: null,

      // Shouldn't get here.

      expect(false).toEqual(true);

    } catch (reason) {

      expect(reason instanceof Error).toEqual(true);

      expect(reason.message).toEqual(

        'The CMap ""baseUrl"" parameter must be specified, ensure that ' +

          'the ""cMapUrl"" and ""cMapPacked"" API parameters are provided.'

      );

    }

  it(""attempts to load a built-in CMap with inconsistent API parameters"", async function () {

      return CMapReaderFactory.fetch({ name });

    }

    try {

      await CMapFactory.create({

        encoding: Name.get(""Adobe-Japan1-1""),

        fetchBuiltInCMap: tmpFetchBuiltInCMap,

        useCMap: null,

      // Shouldn't get here.

      expect(false).toEqual(true);

    } catch (reason) {

      expect(reason instanceof Error).toEqual(true);

      const message = reason.message;

      expect(message.startsWith(""Unable to load CMap at: "")).toEqual(true);

      expect(message.endsWith(""/external/bcmaps/Adobe-Japan1-1"")).toEqual(true);

    }
",2021-04-14 22:24:28+02:00
f560fe68756728ab33f9253e2f6da7c84b4b364f,Jonas Jenwald,"A couple of small scripting/XFA-related tweaks in the worker-code

 - Use `PDFManager.ensureDoc`, rather than `PDFManager.ensure`, in a couple of spots in the code. If there exists a short-hand format, we should obviously use it whenever possible.

 - Fix a unit-test helper, to account for the previous changes. (Also, converts a function to be `async` instead.)

 - Add one more exists-check in `PDFDocument.loadXfaFonts`, which I missed to suggest in PR 13146, to prevent any possible errors if the method is ever called in a situation where it shouldn't be.
   Also, print a warning if the actual font-loading fails since that could help future debugging. (Finally, reduce overall indentation in the loop.)

 - Slightly unrelated, but make a small tweak of a comment in `src/core/fonts.js` to reduce possible confusion.",test/unit/document_spec.js,https://github.com/mozilla/pdf.js/commit/f560fe68756728ab33f9253e2f6da7c84b4b364f,"        ensure(obj, prop, args) {

          return new Promise(function (resolve) {

            const value = obj[prop];

            if (typeof value === ""function"") {

              resolve(value.apply(obj, args));

            } else {

              resolve(value);

            }

          });
","        ensureDoc(prop, args) {

          return pdfManager.ensure(pdfDocument, prop, args);

        },

        async ensure(obj, prop, args) {

          const value = obj[prop];

          if (typeof value === ""function"") {

            return value.apply(obj, args);

          }

          return value;
",2021-04-17 10:13:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      const promises = [

      ];

      Promise.all(promises)

        .then(function (data) {

          expect(data[0].loaded / data[0].total >= 0).toEqual(true);

          expect(data[1] instanceof PDFDocumentProxy).toEqual(true);

          expect(loadingTask).toEqual(data[1].loadingTask);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""creates pdf doc from URL and aborts before worker initialized"", function (done) {

      loadingTask.promise

        .then(function (reason) {

          done.fail(""shall fail loading"");

        })

        .catch(function (reason) {

          expect(true).toEqual(true);

          destroyed.then(done);

        });

    it(""creates pdf doc from URL and aborts loading after worker initialized"", function (done) {

      destroyed

        .then(function (data) {

          expect(true).toEqual(true);

          done();

        })

        .catch(done.fail);

    it(""creates pdf doc from typed array"", function (done) {

      const typedArrayPdfPromise = DefaultFileReaderFactory.fetch({

      typedArrayPdfPromise

        .then(typedArrayPdf => {

          // Sanity check to make sure that we fetched the entire PDF file.

          expect(typedArrayPdf.length).toEqual(basicApiFileLength);

          const loadingTask = getDocument(typedArrayPdf);

          const progressReportedCapability = createPromiseCapability();

          loadingTask.onProgress = function (data) {

            progressReportedCapability.resolve(data);

          };

          return Promise.all([

            loadingTask.promise,

            progressReportedCapability.promise,

          ]).then(function (data) {

            expect(data[0] instanceof PDFDocumentProxy).toEqual(true);

            expect(data[1].loaded / data[1].total).toEqual(1);

            loadingTask.destroy().then(done);

          });

        })

        .catch(done.fail);

    it(""creates pdf doc from invalid PDF file"", function (done) {

      loadingTask.promise

        .then(function () {

          done.fail(""shall fail loading"");

        })

        .catch(function (reason) {

          expect(reason instanceof InvalidPDFException).toEqual(true);

          expect(reason.message).toEqual(""Invalid PDF structure."");

          loadingTask.destroy().then(done);

        });

    it(""creates pdf doc from non-existent URL"", function (done) {

        // re-enable https://github.com/mozilla/pdf.js/issues/13061

        pending(""Fails intermittently on linux in browsers."");

      loadingTask.promise

        .then(function (error) {

          done.fail(""shall fail loading"");

        })

        .catch(function (error) {

          expect(error instanceof MissingPDFException).toEqual(true);

          loadingTask.destroy().then(done);

        });

    it(""creates pdf doc from PDF file protected with user and owner password"", function (done) {
","      const data = await Promise.all([

      ]);



      expect(data[0].loaded / data[0].total >= 0).toEqual(true);

      expect(data[1] instanceof PDFDocumentProxy).toEqual(true);

      expect(loadingTask).toEqual(data[1].loadingTask);



      await loadingTask.destroy();



    it(""creates pdf doc from URL and aborts before worker initialized"", async function () {

      try {

        await loadingTask.promise;



        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(true).toEqual(true);

        await destroyed;

      }



    it(""creates pdf doc from URL and aborts loading after worker initialized"", async function () {



      await destroyed;

      expect(true).toEqual(true);



    it(""creates pdf doc from typed array"", async function () {

      const typedArrayPdf = await DefaultFileReaderFactory.fetch({

      // Sanity check to make sure that we fetched the entire PDF file.

      expect(typedArrayPdf.length).toEqual(basicApiFileLength);

      const loadingTask = getDocument(typedArrayPdf);

      const progressReportedCapability = createPromiseCapability();

      loadingTask.onProgress = function (data) {

        progressReportedCapability.resolve(data);

      };

      const data = await Promise.all([

        loadingTask.promise,

        progressReportedCapability.promise,

      ]);

      expect(data[0] instanceof PDFDocumentProxy).toEqual(true);

      expect(data[1].loaded / data[1].total).toEqual(1);

      await loadingTask.destroy();



    it(""creates pdf doc from invalid PDF file"", async function () {

      try {

        await loadingTask.promise;



        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(reason instanceof InvalidPDFException).toEqual(true);

        expect(reason.message).toEqual(""Invalid PDF structure."");

      }



      await loadingTask.destroy();



    it(""creates pdf doc from non-existent URL"", async function () {

        // Re-enable in https://github.com/mozilla/pdf.js/issues/13061.

        pending(""Fails intermittently on Linux in browsers."");



      try {

        await loadingTask.promise;



        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(reason instanceof MissingPDFException).toEqual(true);

      }



      await loadingTask.destroy();



    it(""creates pdf doc from PDF file protected with user and owner password"", async function () {
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      const promises = [

      ];

      Promise.all(promises)

        .then(function (data) {

          expect(data[2] instanceof PDFDocumentProxy).toEqual(true);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""creates pdf doc from PDF file protected with only a user password"", function (done) {
","      const data = await Promise.all([

      ]);

      expect(data[2] instanceof PDFDocumentProxy).toEqual(true);



      await loadingTask.destroy();



    it(""creates pdf doc from PDF file protected with only a user password"", async function () {
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      Promise.all([result1, result2, result3])

        .then(function () {

          done();

        })

        .catch(done.fail);

      function (done) {
","

      await Promise.all([result1, result2, result3]);

      async function () {
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"        Promise.all([result1, result2])

          .then(function () {

            done();

          })

          .catch(done.fail);

    it(""creates pdf doc from empty typed array"", function (done) {

      loadingTask.promise.then(

        function () {

          done.fail(""shall not open empty file"");

        },

        function (reason) {

          expect(reason instanceof InvalidPDFException);

          expect(reason.message).toEqual(

            ""The PDF file is empty, i.e. its size is zero bytes.""

          );

          loadingTask.destroy().then(done);

        }

      );

    it(""worker created or destroyed"", function (done) {

      worker.promise

        .then(function () {

          expect(worker.name).toEqual(""test1"");

          expect(!!worker.port).toEqual(true);

          expect(worker.destroyed).toEqual(false);

          expect(!!worker._webWorker).toEqual(true);

          expect(worker.port === worker._webWorker).toEqual(true);



          worker.destroy();

          expect(!!worker.port).toEqual(false);

          expect(worker.destroyed).toEqual(true);

          done();

        })

        .catch(done.fail);

    it(""worker created or destroyed by getDocument"", function (done) {
","        await Promise.all([result1, result2]);

    it(""creates pdf doc from empty typed array"", async function () {

      try {

        await loadingTask.promise;

        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(reason instanceof InvalidPDFException).toEqual(true);

        expect(reason.message).toEqual(

          ""The PDF file is empty, i.e. its size is zero bytes.""

        );

      }



      await loadingTask.destroy();

    it(""worker created or destroyed"", async function () {

      await worker.promise;

      expect(worker.name).toEqual(""test1"");

      expect(!!worker.port).toEqual(true);

      expect(worker.destroyed).toEqual(false);

      expect(!!worker._webWorker).toEqual(true);

      expect(worker.port === worker._webWorker).toEqual(true);



      worker.destroy();

      expect(!!worker.port).toEqual(false);

      expect(worker.destroyed).toEqual(true);



    it(""worker created or destroyed by getDocument"", async function () {
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      destroyPromise

        .then(function () {

          const destroyedWorker = loadingTask._worker;

          expect(!!destroyedWorker).toEqual(false);

          expect(worker.destroyed).toEqual(true);

          done();

        })

        .catch(done.fail);

    it(""worker created and can be used in getDocument"", function (done) {
","      await destroyPromise;



      const destroyedWorker = loadingTask._worker;

      expect(!!destroyedWorker).toEqual(false);

      expect(worker.destroyed).toEqual(true);



    it(""worker created and can be used in getDocument"", async function () {
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      destroyPromise

        .then(function () {

          expect(worker.destroyed).toEqual(false);

          worker.destroy();

          done();

        })

        .catch(done.fail);

    it(""creates more than one worker"", function (done) {
","      await destroyPromise;



      expect(worker.destroyed).toEqual(false);

      worker.destroy();



    it(""creates more than one worker"", async function () {
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      const ready = Promise.all([

        worker1.promise,

        worker2.promise,

        worker3.promise,

      ]);

      ready

        .then(function () {

          expect(

            worker1.port !== worker2.port &&

              worker1.port !== worker3.port &&

              worker2.port !== worker3.port

          ).toEqual(true);

          worker1.destroy();

          worker2.destroy();

          worker3.destroy();

          done();

        })

        .catch(done.fail);
","      await Promise.all([worker1.promise, worker2.promise, worker3.promise]);



      expect(

        worker1.port !== worker2.port &&

          worker1.port !== worker3.port &&

          worker2.port !== worker3.port

      ).toEqual(true);

      worker1.destroy();

      worker2.destroy();

      worker3.destroy();


",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"    beforeAll(function (done) {

      pdfLoadingTask.promise.then(function (data) {

        pdfDocument = data;

        done();

      });

    afterAll(function (done) {

      pdfLoadingTask.destroy().then(done);

    it(""gets page"", function (done) {

      const promise = pdfDocument.getPage(1);

      promise

        .then(function (data) {

          expect(data instanceof PDFPageProxy).toEqual(true);

          expect(data.pageNumber).toEqual(1);

          done();

        })

        .catch(done.fail);

    it(""gets non-existent page"", function (done) {
","

    beforeAll(async function () {

      pdfDocument = await pdfLoadingTask.promise;

    afterAll(async function () {

      await pdfLoadingTask.destroy();





    it(""gets page"", async function () {

      const data = await pdfDocument.getPage(1);

      expect(data instanceof PDFPageProxy).toEqual(true);

      expect(data.pageNumber).toEqual(1);



    it(""gets non-existent page"", async function () {
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      Promise.all([outOfRangePromise, nonIntegerPromise, nonNumberPromise])

        .then(function () {

          done();

        })

        .catch(done.fail);

    it(""gets page, from /Pages tree with circular reference"", function (done) {
","      await Promise.all([

        outOfRangePromise,

        nonIntegerPromise,

        nonNumberPromise,

      ]);

    it(""gets page, from /Pages tree with circular reference"", async function () {
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      Promise.all([page1, page2]).then(function () {

        loadingTask.destroy().then(done);

      }, done.fail);

    it(""gets page index"", function (done) {

      // reference to second page

      const ref = { num: 17, gen: 0 };

      const promise = pdfDocument.getPageIndex(ref);

      promise

        .then(function (pageIndex) {

          expect(pageIndex).toEqual(1);

          done();

        })

        .catch(done.fail);

    it(""gets invalid page index"", function (done) {

      const promise = pdfDocument.getPageIndex(ref);

      promise

        .then(function () {

          done.fail(""shall fail for invalid page reference."");

        })

        .catch(function (reason) {

          expect(reason instanceof Error).toEqual(true);

          done();

        });

    it(""gets destinations, from /Dests dictionary"", function (done) {

      const promise = pdfDocument.getDestinations();

      promise

        .then(function (data) {

          expect(data).toEqual({

            chapter1: [{ gen: 0, num: 17 }, { name: ""XYZ"" }, 0, 841.89, null],

          });

          done();

        })

        .catch(done.fail);

    it(""gets a destination, from /Dests dictionary"", function (done) {

      const promise = pdfDocument.getDestination(""chapter1"");

      promise

        .then(function (data) {

          expect(data).toEqual([

            { gen: 0, num: 17 },

            { name: ""XYZ"" },

            0,

            841.89,

            null,

          ]);

          done();

        })

        .catch(done.fail);

    it(""gets a non-existent destination, from /Dests dictionary"", function (done) {

      const promise = pdfDocument.getDestination(

      promise

        .then(function (data) {

          expect(data).toEqual(null);

          done();

        })

        .catch(done.fail);

    it(""gets destinations, from /Names (NameTree) dictionary"", function (done) {

      const promise = loadingTask.promise.then(function (pdfDoc) {

        return pdfDoc.getDestinations();

      promise

        .then(function (destinations) {

          expect(destinations).toEqual({

            ""Page.1"": [{ num: 1, gen: 0 }, { name: ""XYZ"" }, 0, 375, null],

            ""Page.2"": [{ num: 6, gen: 0 }, { name: ""XYZ"" }, 0, 375, null],

          });

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets a destination, from /Names (NameTree) dictionary"", function (done) {

      const promise = loadingTask.promise.then(function (pdfDoc) {

        return pdfDoc.getDestination(""Page.1"");

      });

      promise

        .then(function (destination) {

          expect(destination).toEqual([

            { num: 1, gen: 0 },

            { name: ""XYZ"" },

            0,

            375,

            null,

          ]);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets a non-existent destination, from /Names (NameTree) dictionary"", function (done) {

      const promise = loadingTask.promise.then(function (pdfDoc) {

        return pdfDoc.getDestination(""non-existent-named-destination"");

      });

      promise

        .then(function (destination) {

          expect(destination).toEqual(null);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets non-string destination"", function (done) {
","      await Promise.all([page1, page2]);

      await loadingTask.destroy();

    it(""gets page index"", async function () {

      const ref = { num: 17, gen: 0 }; // Reference to second page.

      const pageIndex = await pdfDocument.getPageIndex(ref);

      expect(pageIndex).toEqual(1);



    it(""gets invalid page index"", async function () {



      try {

        await pdfDocument.getPageIndex(ref);



        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(reason instanceof Error).toEqual(true);

      }

    it(""gets destinations, from /Dests dictionary"", async function () {

      const destinations = await pdfDocument.getDestinations();

      expect(destinations).toEqual({

        chapter1: [{ gen: 0, num: 17 }, { name: ""XYZ"" }, 0, 841.89, null],

      });



    it(""gets a destination, from /Dests dictionary"", async function () {

      const destination = await pdfDocument.getDestination(""chapter1"");

      expect(destination).toEqual([

        { gen: 0, num: 17 },

        { name: ""XYZ"" },

        0,

        841.89,

        null,

      ]);



    it(""gets a non-existent destination, from /Dests dictionary"", async function () {

      const destination = await pdfDocument.getDestination(

      expect(destination).toEqual(null);

    it(""gets destinations, from /Names (NameTree) dictionary"", async function () {

      const pdfDoc = await loadingTask.promise;

      const destinations = await pdfDoc.getDestinations();

      expect(destinations).toEqual({

        ""Page.1"": [{ num: 1, gen: 0 }, { name: ""XYZ"" }, 0, 375, null],

        ""Page.2"": [{ num: 6, gen: 0 }, { name: ""XYZ"" }, 0, 375, null],

      await loadingTask.destroy();



    it(""gets a destination, from /Names (NameTree) dictionary"", async function () {

      const pdfDoc = await loadingTask.promise;

      const destination = await pdfDoc.getDestination(""Page.1"");

      expect(destination).toEqual([

        { num: 1, gen: 0 },

        { name: ""XYZ"" },

        0,

        375,

        null,

      ]);

      await loadingTask.destroy();



    it(""gets a non-existent destination, from /Names (NameTree) dictionary"", async function () {

      const pdfDoc = await loadingTask.promise;

      const destination = await pdfDoc.getDestination(

        ""non-existent-named-destination""

      );

      expect(destination).toEqual(null);

      await loadingTask.destroy();

    it(""gets non-string destination"", async function () {
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      Promise.all([numberPromise, booleanPromise, arrayPromise]).then(

        done,

        done.fail

      );

    it(""gets non-existent page labels"", function (done) {

      const promise = pdfDocument.getPageLabels();

      promise

        .then(function (data) {

          expect(data).toEqual(null);

          done();

        })

        .catch(done.fail);

    it(""gets page labels"", function (done) {
","      await Promise.all([numberPromise, booleanPromise, arrayPromise]);

    it(""gets non-existent page labels"", async function () {

      const pageLabels = await pdfDocument.getPageLabels();

      expect(pageLabels).toEqual(null);



    it(""gets page labels"", async function () {
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      Promise.all([promise0, promise1, promise2, promise3])

        .then(function (pageLabels) {

          expect(pageLabels[0]).toEqual([""i"", ""ii"", ""iii"", ""1""]);

          expect(pageLabels[1]).toEqual([""Front Page1""]);

          expect(pageLabels[2]).toEqual([""1"", ""2""]);

          expect(pageLabels[3]).toEqual([""X3""]);



          Promise.all([

            loadingTask0.destroy(),

            loadingTask1.destroy(),

            loadingTask2.destroy(),

            loadingTask3.destroy(),

          ]).then(done);

        })

        .catch(done.fail);

    it(""gets default page layout"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getPageLayout();

        })

        .then(function (mode) {

          expect(mode).toEqual("""");

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    });

    it(""gets non-default page layout"", function (done) {

      pdfDocument

        .getPageLayout()

        .then(function (mode) {

          expect(mode).toEqual(""SinglePage"");

          done();

        })

        .catch(done.fail);

    it(""gets default page mode"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getPageMode();

        })

        .then(function (mode) {

          expect(mode).toEqual(""UseNone"");

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    });

    it(""gets non-default page mode"", function (done) {

      pdfDocument

        .getPageMode()

        .then(function (mode) {

          expect(mode).toEqual(""UseOutlines"");

          done();

        })

        .catch(done.fail);

    it(""gets default viewer preferences"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getViewerPreferences();

        })

        .then(function (prefs) {

          expect(prefs).toEqual(null);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    });

    it(""gets non-default viewer preferences"", function (done) {

      pdfDocument

        .getViewerPreferences()

        .then(function (prefs) {

          expect(prefs).toEqual({

            Direction: ""L2R"",

          });

          done();

        })

        .catch(done.fail);

    it(""gets default open action"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getOpenAction();

        })

        .then(function (openAction) {

          expect(openAction).toEqual(null);



          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets non-default open action (with destination)"", function (done) {

      pdfDocument

        .getOpenAction()

        .then(function (openAction) {

          expect(openAction.dest).toEqual([

            { num: 15, gen: 0 },

            { name: ""FitH"" },

            null,

          ]);

          expect(openAction.action).toBeUndefined();

          done();

        })

        .catch(done.fail);

    it(""gets non-default open action (with Print action)"", function (done) {
","      const pageLabels = await Promise.all([

        promise0,

        promise1,

        promise2,

        promise3,

      ]);

      expect(pageLabels[0]).toEqual([""i"", ""ii"", ""iii"", ""1""]);

      expect(pageLabels[1]).toEqual([""Front Page1""]);

      expect(pageLabels[2]).toEqual([""1"", ""2""]);

      expect(pageLabels[3]).toEqual([""X3""]);



      await Promise.all([

        loadingTask0.destroy(),

        loadingTask1.destroy(),

        loadingTask2.destroy(),

        loadingTask3.destroy(),

      ]);

    it(""gets default page layout"", async function () {

      const pdfDoc = await loadingTask.promise;

      const pageLayout = await pdfDoc.getPageLayout();

      expect(pageLayout).toEqual("""");

      await loadingTask.destroy();

    });

    it(""gets non-default page layout"", async function () {

      const pageLayout = await pdfDocument.getPageLayout();

      expect(pageLayout).toEqual(""SinglePage"");

    it(""gets default page mode"", async function () {

      const pdfDoc = await loadingTask.promise;

      const pageMode = await pdfDoc.getPageMode();

      expect(pageMode).toEqual(""UseNone"");

      await loadingTask.destroy();

    });

    it(""gets non-default page mode"", async function () {

      const pageMode = await pdfDocument.getPageMode();

      expect(pageMode).toEqual(""UseOutlines"");

    it(""gets default viewer preferences"", async function () {

      const pdfDoc = await loadingTask.promise;

      const prefs = await pdfDoc.getViewerPreferences();

      expect(prefs).toEqual(null);

      await loadingTask.destroy();

    });

    it(""gets non-default viewer preferences"", async function () {

      const prefs = await pdfDocument.getViewerPreferences();

      expect(prefs).toEqual({ Direction: ""L2R"" });

    it(""gets default open action"", async function () {

      const pdfDoc = await loadingTask.promise;

      const openAction = await pdfDoc.getOpenAction();

      expect(openAction).toEqual(null);

      await loadingTask.destroy();

    it(""gets non-default open action (with destination)"", async function () {

      const openAction = await pdfDocument.getOpenAction();

      expect(openAction.dest).toEqual([

        { num: 15, gen: 0 },

        { name: ""FitH"" },

        null,

      ]);

      expect(openAction.action).toBeUndefined();



    it(""gets non-default open action (with Print action)"", async function () {
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      Promise.all([promise1, promise2]).then(done, done.fail);

    it(""gets non-existent attachments"", function (done) {

      const promise = pdfDocument.getAttachments();

      promise

        .then(function (data) {

          expect(data).toEqual(null);

          done();

        })

        .catch(done.fail);

    it(""gets attachments"", function (done) {

      const promise = loadingTask.promise.then(function (pdfDoc) {

        return pdfDoc.getAttachments();

      });

      promise

        .then(function (data) {

          const attachment = data[""foo.txt""];

          expect(attachment.filename).toEqual(""foo.txt"");

          expect(attachment.content).toEqual(

            new Uint8Array([98, 97, 114, 32, 98, 97, 122, 32, 10])

          );

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets javascript"", function (done) {

      const promise = pdfDocument.getJavaScript();

      promise

        .then(function (data) {

          expect(data).toEqual(null);

          done();

        })

        .catch(done.fail);

    it(""gets javascript with printing instructions (JS action)"", function (done) {

      const promise = loadingTask.promise.then(function (pdfDoc) {

        return pdfDoc.getJavaScript();

      });

      promise

        .then(function (data) {

          expect(data).toEqual([

            ""this.print({bUI:true,bSilent:false,bShrinkToFit:true});"",

          ]);

          expect(data[0]).toMatch(AutoPrintRegExp);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);
","      await Promise.all([promise1, promise2]);

    it(""gets non-existent attachments"", async function () {

      const attachments = await pdfDocument.getAttachments();

      expect(attachments).toEqual(null);



    it(""gets attachments"", async function () {

      const pdfDoc = await loadingTask.promise;

      const attachments = await pdfDoc.getAttachments();

      const attachment = attachments[""foo.txt""];

      expect(attachment.filename).toEqual(""foo.txt"");

      expect(attachment.content).toEqual(

        new Uint8Array([98, 97, 114, 32, 98, 97, 122, 32, 10])

      );



      await loadingTask.destroy();

    it(""gets javascript"", async function () {

      const javascript = await pdfDocument.getJavaScript();

      expect(javascript).toEqual(null);



    it(""gets javascript with printing instructions (JS action)"", async function () {

      const pdfDoc = await loadingTask.promise;

      const javascript = await pdfDoc.getJavaScript();



      expect(javascript).toEqual([

        ""this.print({bUI:true,bSilent:false,bShrinkToFit:true});"",

      ]);

      expect(javascript[0]).toMatch(AutoPrintRegExp);



      await loadingTask.destroy();
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      Promise.all([promise0, promise1, promise2])

        .then(function (permissions) {

          expect(permissions[0].length).toEqual(totalPermissionCount - 1);

          expect(

            permissions[0].includes(PermissionFlag.MODIFY_CONTENTS)

          ).toBeFalsy();

          expect(permissions[1].length).toEqual(totalPermissionCount - 2);

          expect(permissions[1].includes(PermissionFlag.PRINT)).toBeFalsy();

          expect(

            permissions[1].includes(PermissionFlag.PRINT_HIGH_QUALITY)

          ).toBeFalsy();

          expect(permissions[2].length).toEqual(totalPermissionCount - 1);

          expect(permissions[2].includes(PermissionFlag.COPY)).toBeFalsy();

          Promise.all([

            loadingTask0.destroy(),

            loadingTask1.destroy(),

            loadingTask2.destroy(),

          ]).then(done);

        })

        .catch(done.fail);

    });



    it(""gets metadata"", function (done) {

      const promise = pdfDocument.getMetadata();

      promise

        .then(function ({

          info,

          metadata,

          contentDispositionFilename,

          contentLength,

        }) {

          expect(info.Title).toEqual(""Basic API Test"");

          // Custom, non-standard, information dictionary entries.

          expect(info.Custom).toEqual(undefined);

          // The following are PDF.js specific, non-standard, properties.

          expect(info.PDFFormatVersion).toEqual(""1.7"");

          expect(info.IsLinearized).toEqual(false);

          expect(info.IsAcroFormPresent).toEqual(false);

          expect(info.IsXFAPresent).toEqual(false);

          expect(info.IsCollectionPresent).toEqual(false);

          expect(info.IsSignaturesPresent).toEqual(false);



          expect(metadata instanceof Metadata).toEqual(true);

          expect(metadata.get(""dc:title"")).toEqual(""Basic API Test"");



          expect(contentDispositionFilename).toEqual(null);

          expect(contentLength).toEqual(basicApiFileLength);

          done();

        })

        .catch(done.fail);

    it(""gets metadata, with custom info dict entries"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getMetadata();

        })

        .then(function ({

          info,

          metadata,

          contentDispositionFilename,

          contentLength,

        }) {

          expect(info.Creator).toEqual(""TeX"");

          expect(info.Producer).toEqual(""pdfeTeX-1.21a"");

          expect(info.CreationDate).toEqual(""D:20090401163925-07'00'"");

          // Custom, non-standard, information dictionary entries.

          const custom = info.Custom;

          expect(typeof custom === ""object"" && custom !== null).toEqual(true);



          expect(custom[""PTEX.Fullbanner""]).toEqual(

            ""This is pdfeTeX, "" +

              ""Version 3.141592-1.21a-2.2 (Web2C 7.5.4) kpathsea version 3.5.6""

          );

          // The following are PDF.js specific, non-standard, properties.

          expect(info.PDFFormatVersion).toEqual(""1.4"");

          expect(info.IsLinearized).toEqual(false);

          expect(info.IsAcroFormPresent).toEqual(false);

          expect(info.IsXFAPresent).toEqual(false);

          expect(info.IsCollectionPresent).toEqual(false);

          expect(info.IsSignaturesPresent).toEqual(false);



          expect(metadata).toEqual(null);

          expect(contentDispositionFilename).toEqual(null);

          expect(contentLength).toEqual(1016315);



          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets metadata, with missing PDF header (bug 1606566)"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getMetadata();

        })

        .then(function ({

          info,

          metadata,

          contentDispositionFilename,

          contentLength,

        }) {

          // The following are PDF.js specific, non-standard, properties.

          expect(info.PDFFormatVersion).toEqual(null);

          expect(info.IsLinearized).toEqual(false);

          expect(info.IsAcroFormPresent).toEqual(false);

          expect(info.IsXFAPresent).toEqual(false);

          expect(info.IsCollectionPresent).toEqual(false);

          expect(info.IsSignaturesPresent).toEqual(false);



          expect(metadata).toEqual(null);

          expect(contentDispositionFilename).toEqual(null);

          expect(contentLength).toEqual(624);



          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets markInfo"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getMarkInfo();

        })

        .then(function (info) {

          expect(info.Marked).toEqual(true);

          expect(info.UserProperties).toEqual(false);

          expect(info.Suspects).toEqual(false);

          done();

        })

        .catch(done.fail);

    it(""gets data"", function (done) {

      const promise = pdfDocument.getData();

      promise

        .then(function (data) {

          expect(data instanceof Uint8Array).toEqual(true);

          expect(data.length).toEqual(basicApiFileLength);

          done();

        })

        .catch(done.fail);

    it(""gets download info"", function (done) {

      const promise = pdfDocument.getDownloadInfo();

      promise

        .then(function (data) {

          expect(data).toEqual({ length: basicApiFileLength });

          done();

        })

        .catch(done.fail);

    });

    it(""gets document stats"", function (done) {

      const promise = pdfDocument.getStats();

      promise

        .then(function (stats) {

          expect(stats).toEqual({ streamTypes: {}, fontTypes: {} });

          done();

        })

        .catch(done.fail);
","      const permissions = await Promise.all([promise0, promise1, promise2]);



      expect(permissions[0].length).toEqual(totalPermissionCount - 1);

      expect(

        permissions[0].includes(PermissionFlag.MODIFY_CONTENTS)

      ).toBeFalsy();



      expect(permissions[1].length).toEqual(totalPermissionCount - 2);

      expect(permissions[1].includes(PermissionFlag.PRINT)).toBeFalsy();

      expect(

        permissions[1].includes(PermissionFlag.PRINT_HIGH_QUALITY)

      ).toBeFalsy();



      expect(permissions[2].length).toEqual(totalPermissionCount - 1);

      expect(permissions[2].includes(PermissionFlag.COPY)).toBeFalsy();



      await Promise.all([

        loadingTask0.destroy(),

        loadingTask1.destroy(),

        loadingTask2.destroy(),

      ]);

    });

    it(""gets metadata"", async function () {

      const {

        info,

        metadata,

        contentDispositionFilename,

        contentLength,

      } = await pdfDocument.getMetadata();

      expect(info.Title).toEqual(""Basic API Test"");

      // Custom, non-standard, information dictionary entries.

      expect(info.Custom).toEqual(undefined);

      // The following are PDF.js specific, non-standard, properties.

      expect(info.PDFFormatVersion).toEqual(""1.7"");

      expect(info.IsLinearized).toEqual(false);

      expect(info.IsAcroFormPresent).toEqual(false);

      expect(info.IsXFAPresent).toEqual(false);

      expect(info.IsCollectionPresent).toEqual(false);

      expect(info.IsSignaturesPresent).toEqual(false);

      expect(metadata instanceof Metadata).toEqual(true);

      expect(metadata.get(""dc:title"")).toEqual(""Basic API Test"");



      expect(contentDispositionFilename).toEqual(null);

      expect(contentLength).toEqual(basicApiFileLength);



    it(""gets metadata, with custom info dict entries"", async function () {

      const pdfDoc = await loadingTask.promise;

      const {

        info,

        metadata,

        contentDispositionFilename,

        contentLength,

      } = await pdfDoc.getMetadata();



      expect(info.Creator).toEqual(""TeX"");

      expect(info.Producer).toEqual(""pdfeTeX-1.21a"");

      expect(info.CreationDate).toEqual(""D:20090401163925-07'00'"");

      // Custom, non-standard, information dictionary entries.

      const custom = info.Custom;

      expect(typeof custom === ""object"" && custom !== null).toEqual(true);



      expect(custom[""PTEX.Fullbanner""]).toEqual(

        ""This is pdfeTeX, "" +

          ""Version 3.141592-1.21a-2.2 (Web2C 7.5.4) kpathsea version 3.5.6""

      );

      // The following are PDF.js specific, non-standard, properties.

      expect(info.PDFFormatVersion).toEqual(""1.4"");

      expect(info.IsLinearized).toEqual(false);

      expect(info.IsAcroFormPresent).toEqual(false);

      expect(info.IsXFAPresent).toEqual(false);

      expect(info.IsCollectionPresent).toEqual(false);

      expect(info.IsSignaturesPresent).toEqual(false);



      expect(metadata).toEqual(null);

      expect(contentDispositionFilename).toEqual(null);

      expect(contentLength).toEqual(1016315);

      await loadingTask.destroy();



    it(""gets metadata, with missing PDF header (bug 1606566)"", async function () {

      const pdfDoc = await loadingTask.promise;

      const {

        info,

        metadata,

        contentDispositionFilename,

        contentLength,

      } = await pdfDoc.getMetadata();



      // The following are PDF.js specific, non-standard, properties.

      expect(info.PDFFormatVersion).toEqual(null);

      expect(info.IsLinearized).toEqual(false);

      expect(info.IsAcroFormPresent).toEqual(false);

      expect(info.IsXFAPresent).toEqual(false);

      expect(info.IsCollectionPresent).toEqual(false);

      expect(info.IsSignaturesPresent).toEqual(false);



      expect(metadata).toEqual(null);

      expect(contentDispositionFilename).toEqual(null);

      expect(contentLength).toEqual(624);

      await loadingTask.destroy();

    it(""gets markInfo"", async function () {

      const pdfDoc = await loadingTask.promise;

      const markInfo = await pdfDoc.getMarkInfo();

      expect(markInfo.Marked).toEqual(true);

      expect(markInfo.UserProperties).toEqual(false);

      expect(markInfo.Suspects).toEqual(false);

    });

    it(""gets data"", async function () {

      const data = await pdfDocument.getData();

      expect(data instanceof Uint8Array).toEqual(true);

      expect(data.length).toEqual(basicApiFileLength);

    it(""gets download info"", async function () {

      const downloadInfo = await pdfDocument.getDownloadInfo();

      expect(downloadInfo).toEqual({ length: basicApiFileLength });



    it(""gets document stats"", async function () {

      const stats = await pdfDocument.getStats();

      expect(stats).toEqual({ streamTypes: {}, fontTypes: {} });
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"    it(""checks that fingerprints are unique"", function (done) {

      Promise.all([loadingTask1.promise, loadingTask2.promise])

        .then(function (data) {

          const fingerprint1 = data[0].fingerprint;

          const fingerprint2 = data[1].fingerprint;

          expect(fingerprint1).not.toEqual(fingerprint2);

          expect(fingerprint1).toEqual(""2f695a83d6e7553c24fc08b7ac69712d"");

          expect(fingerprint2).toEqual(""04c7126b34a46b6d4d6e7a1eff7edcb6"");

          Promise.all([loadingTask1.destroy(), loadingTask2.destroy()]).then(

            done

          );

        })

        .catch(done.fail);
","    it(""checks that fingerprints are unique"", async function () {

      const data = await Promise.all([

        loadingTask1.promise,

        loadingTask2.promise,

      ]);

      const fingerprint1 = data[0].fingerprint;

      const fingerprint2 = data[1].fingerprint;

      expect(fingerprint1).not.toEqual(fingerprint2);

      expect(fingerprint1).toEqual(""2f695a83d6e7553c24fc08b7ac69712d"");

      expect(fingerprint2).toEqual(""04c7126b34a46b6d4d6e7a1eff7edcb6"");

      await Promise.all([loadingTask1.destroy(), loadingTask2.destroy()]);
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      afterEach(function (done) {

          loadingTask.destroy().then(done);

        } else {

          done();

      it(""server disallows cors"", function (done) {

        testCannotLoad(""basicapi.pdf"").then(done);

      it(""server allows cors without credentials, default withCredentials"", function (done) {

        testCanLoad(""basicapi.pdf?cors=withoutCredentials"").then(done);

      it(""server allows cors without credentials, and withCredentials=false"", function (done) {

        testCanLoad(""basicapi.pdf?cors=withoutCredentials"", {

        }).then(done);

      it(""server allows cors without credentials, but withCredentials=true"", function (done) {

        testCannotLoad(""basicapi.pdf?cors=withoutCredentials"", {

        }).then(done);

      it(""server allows cors with credentials, and withCredentials=true"", function (done) {

        testCanLoad(""basicapi.pdf?cors=withCredentials"", {

        }).then(done);

      it(""server allows cors with credentials, and withCredentials=false"", function (done) {

        testCanLoad(""basicapi.pdf?cors=withCredentials"", {

        }).then(done);

    beforeAll(function (done) {

      pdfLoadingTask.promise

        .then(function (doc) {

          pdfDocument = doc;

          pdfDocument.getPage(1).then(function (data) {

            page = data;

            done();

          });

        })

        .catch(done.fail);

    afterAll(function (done) {

      pdfLoadingTask.destroy().then(done);
","

      afterEach(async function () {

          await loadingTask.destroy();



      it(""server disallows cors"", async function () {

        await testCannotLoad(""basicapi.pdf"");



      it(""server allows cors without credentials, default withCredentials"", async function () {

        await testCanLoad(""basicapi.pdf?cors=withoutCredentials"");



      it(""server allows cors without credentials, and withCredentials=false"", async function () {

        await testCanLoad(""basicapi.pdf?cors=withoutCredentials"", {

        });



      it(""server allows cors without credentials, but withCredentials=true"", async function () {

        await testCannotLoad(""basicapi.pdf?cors=withoutCredentials"", {

        });



      it(""server allows cors with credentials, and withCredentials=true"", async function () {

        await testCanLoad(""basicapi.pdf?cors=withCredentials"", {

        });



      it(""server allows cors with credentials, and withCredentials=false"", async function () {

        await testCanLoad(""basicapi.pdf?cors=withCredentials"", {

        });



    beforeAll(async function () {

      pdfDocument = await pdfLoadingTask.promise;

      page = await pdfDocument.getPage(1);

    afterAll(async function () {

      await pdfLoadingTask.destroy();






",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      Promise.all([defaultPromise, displayPromise, printPromise])

        .then(function () {

          done();

        })

        .catch(done.fail);

    it(""gets annotations containing relative URLs (bug 766086)"", function (done) {
","

      await Promise.all([defaultPromise, displayPromise, printPromise]);

    it(""gets annotations containing relative URLs (bug 766086)"", async function () {
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      Promise.all([defaultPromise, docBaseUrlPromise, invalidDocBaseUrlPromise])

        .then(function (data) {

          const defaultAnnotations = data[0];

          const docBaseUrlAnnotations = data[1];

          const invalidDocBaseUrlAnnotations = data[2];

          expect(defaultAnnotations[0].url).toBeUndefined();

          expect(defaultAnnotations[0].unsafeUrl).toEqual(

            ""../../0021/002156/215675E.pdf#15""

          );

          expect(docBaseUrlAnnotations[0].url).toEqual(

            ""http://www.example.com/0021/002156/215675E.pdf#15""

          );

          expect(docBaseUrlAnnotations[0].unsafeUrl).toEqual(

            ""../../0021/002156/215675E.pdf#15""

          );

          expect(invalidDocBaseUrlAnnotations[0].url).toBeUndefined();

          expect(invalidDocBaseUrlAnnotations[0].unsafeUrl).toEqual(

            ""../../0021/002156/215675E.pdf#15""

          );

          Promise.all([

            defaultLoadingTask.destroy(),

            docBaseUrlLoadingTask.destroy(),

            invalidDocBaseUrlLoadingTask.destroy(),

          ]).then(done);

        })

        .catch(done.fail);

    it(""gets text content"", function (done) {

      const promises = [defaultPromise, parametersPromise];

      Promise.all(promises)

        .then(function (data) {

          expect(!!data[0].items).toEqual(true);

          expect(data[0].items.length).toEqual(7);

          expect(!!data[0].styles).toEqual(true);

          // A simple check that ensures the two `textContent` object match.

          expect(JSON.stringify(data[0])).toEqual(JSON.stringify(data[1]));

          done();

        })

        .catch(done.fail);

    it(""gets text content, with correct properties (issue 8276)"", function (done) {

      loadingTask.promise

        .then(pdfDoc => {

          pdfDoc.getPage(1).then(pdfPage => {

            pdfPage.getTextContent().then(({ items, styles }) => {

              expect(items.length).toEqual(1);

              expect(Object.keys(styles)).toEqual([""Times""]);



              expect(items[0]).toEqual({

                dir: ""ltr"",

                fontName: ""Times"",

                height: 18,

                str: ""Issue 8276"",

                transform: [18, 0, 0, 18, 441.81, 708.4499999999999],

                width: 77.49,

              });

              expect(styles.Times).toEqual({

                fontFamily: ""serif"",

                ascent: NaN,

                descent: NaN,

                vertical: false,

              });



              loadingTask.destroy().then(done);

            });

          });

        })

        .catch(done.fail);
","      const [

        defaultAnnotations,

        docBaseUrlAnnotations,

        invalidDocBaseUrlAnnotations,

      ] = await Promise.all([

        defaultPromise,

        docBaseUrlPromise,

        invalidDocBaseUrlPromise,

      ]);

      expect(defaultAnnotations[0].url).toBeUndefined();

      expect(defaultAnnotations[0].unsafeUrl).toEqual(

        ""../../0021/002156/215675E.pdf#15""

      );

      expect(docBaseUrlAnnotations[0].url).toEqual(

        ""http://www.example.com/0021/002156/215675E.pdf#15""

      );

      expect(docBaseUrlAnnotations[0].unsafeUrl).toEqual(

        ""../../0021/002156/215675E.pdf#15""

      );

      expect(invalidDocBaseUrlAnnotations[0].url).toBeUndefined();

      expect(invalidDocBaseUrlAnnotations[0].unsafeUrl).toEqual(

        ""../../0021/002156/215675E.pdf#15""

      );

      await Promise.all([

        defaultLoadingTask.destroy(),

        docBaseUrlLoadingTask.destroy(),

        invalidDocBaseUrlLoadingTask.destroy(),

      ]);

    it(""gets text content"", async function () {

      const data = await Promise.all([defaultPromise, parametersPromise]);

      expect(!!data[0].items).toEqual(true);

      expect(data[0].items.length).toEqual(7);

      expect(!!data[0].styles).toEqual(true);

      // A simple check that ensures the two `textContent` object match.

      expect(JSON.stringify(data[0])).toEqual(JSON.stringify(data[1]));

    it(""gets text content, with correct properties (issue 8276)"", async function () {

      const pdfDoc = await loadingTask.promise;

      const pdfPage = await pdfDoc.getPage(1);

      const { items, styles } = await pdfPage.getTextContent();

      expect(items.length).toEqual(1);

      expect(Object.keys(styles)).toEqual([""Times""]);



      expect(items[0]).toEqual({

        dir: ""ltr"",

        fontName: ""Times"",

        height: 18,

        str: ""Issue 8276"",

        transform: [18, 0, 0, 18, 441.81, 708.4499999999999],

        width: 77.49,

      });

      expect(styles.Times).toEqual({

        fontFamily: ""serif"",

        ascent: NaN,

        descent: NaN,

        vertical: false,

      });

      await loadingTask.destroy();
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"    it(""gets operator list"", function (done) {

      const promise = page.getOperatorList();

      promise

        .then(function (oplist) {

          expect(!!oplist.fnArray).toEqual(true);

          expect(!!oplist.argsArray).toEqual(true);

          expect(oplist.lastChunk).toEqual(true);

          done();

        })

        .catch(done.fail);

    it(""gets operatorList with JPEG image (issue 4888)"", function (done) {

      loadingTask.promise

        .then(pdfDoc => {

          pdfDoc.getPage(1).then(pdfPage => {

            pdfPage.getOperatorList().then(opList => {

              const imgIndex = opList.fnArray.indexOf(OPS.paintImageXObject);

              const imgArgs = opList.argsArray[imgIndex];

              const { data } = pdfPage.objs.get(imgArgs[0]);

              expect(data instanceof Uint8ClampedArray).toEqual(true);

              expect(data.length).toEqual(90000);

              loadingTask.destroy().then(done);

            });

          });

        })

        .catch(done.fail);

      function (done) {
","    it(""gets operator list"", async function () {

      const operatorList = await page.getOperatorList();

      expect(!!operatorList.fnArray).toEqual(true);

      expect(!!operatorList.argsArray).toEqual(true);

      expect(operatorList.lastChunk).toEqual(true);

    it(""gets operatorList with JPEG image (issue 4888)"", async function () {

      const pdfDoc = await loadingTask.promise;

      const pdfPage = await pdfDoc.getPage(1);

      const operatorList = await pdfPage.getOperatorList();

      const imgIndex = operatorList.fnArray.indexOf(OPS.paintImageXObject);

      const imgArgs = operatorList.argsArray[imgIndex];

      const { data } = pdfPage.objs.get(imgArgs[0]);

      expect(data instanceof Uint8ClampedArray).toEqual(true);

      expect(data.length).toEqual(90000);



      await loadingTask.destroy();

      async function () {
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      renderTask.promise

        .then(function () {

          done.fail(""shall cancel rendering"");

        })

        .catch(function (error) {

          expect(error instanceof RenderingCancelledException).toEqual(true);

          expect(error.message).toEqual(""Rendering cancelled, page 1"");

          expect(error.type).toEqual(""canvas"");

          CanvasFactory.destroy(canvasAndCtx);

          done();

        });

    it(""re-render page, using the same canvas, after cancelling rendering"", function (done) {
","      try {

        await renderTask.promise;

        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(reason instanceof RenderingCancelledException).toEqual(true);

        expect(reason.message).toEqual(""Rendering cancelled, page 1"");

        expect(reason.type).toEqual(""canvas"");

      }



      CanvasFactory.destroy(canvasAndCtx);

    it(""re-render page, using the same canvas, after cancelling rendering"", async function () {
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      renderTask.promise

        .then(

          () => {

            throw new Error(""shall cancel rendering"");

          },

          reason => {

            expect(reason instanceof RenderingCancelledException).toEqual(true);

          }

        )

        .then(() => {

          const reRenderTask = page.render({

            canvasContext: canvasAndCtx.context,

            canvasFactory: CanvasFactory,

            viewport,

          });

          return reRenderTask.promise;

        })

        .then(() => {

          CanvasFactory.destroy(canvasAndCtx);

          done();

        }, done.fail);

    it(""multiple render() on the same canvas"", function (done) {
","      try {

        await renderTask.promise;



        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(reason instanceof RenderingCancelledException).toEqual(true);

      }



      const reRenderTask = page.render({

        canvasContext: canvasAndCtx.context,

        canvasFactory: CanvasFactory,

        viewport,

      });

      await reRenderTask.promise;



      CanvasFactory.destroy(canvasAndCtx);

    it(""multiple render() on the same canvas"", async function () {
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"      Promise.all([

            done.fail(""shall fail rendering"");

            /* it fails because we already using this canvas */

      ]).then(done);
","      await Promise.all([

            // Shouldn't get here.

            expect(false).toEqual(true);

            // It fails because we are already using this canvas.

      ]);
",2021-04-16 21:48:42+02:00
c2f3a71eca40fe5e2ebe39431aba20c3830f7946,Tim van der Meij,Convert done callbacks to async/await in `test/unit/api_spec.js`,test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/c2f3a71eca40fe5e2ebe39431aba20c3830f7946,"    afterEach(function (done) {

      Promise.all(destroyPromises).then(done);

    it(""should correctly render PDFs in parallel"", function (done) {
","    afterEach(async function () {

      await Promise.all(destroyPromises);

    it(""should correctly render PDFs in parallel"", async function () {
",2021-04-16 21:48:42+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.id).toEqual(""10R"");

        done();

      }, done.fail);

      function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.id).toEqual(""10R"");

      async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"        Promise.all([annotation1, annotation2]).then(done, done.fail);

    it(""should handle missing /Subtype"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toBeUndefined();

        done();

      }, done.fail);
","        await Promise.all([annotation1, annotation2]);

    it(""should handle missing /Subtype"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toBeUndefined();
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"    it(""should not parse IRT/RT when not defined"", function (done) {



      AnnotationFactory.create(xref, ref, pdfManagerMock, idFactoryMock).then(

        ({ data }) => {

          expect(data.inReplyTo).toBeUndefined();

          expect(data.replyType).toBeUndefined();

          done();

        },

        done.fail

    it(""should parse IRT and set default RT when not defined."", function (done) {
","    it(""should not parse IRT/RT when not defined"", async function () {

      const { data } = await AnnotationFactory.create(

        xref,

        ref,

        pdfManagerMock,

        idFactoryMock

      expect(data.inReplyTo).toBeUndefined();

      expect(data.replyType).toBeUndefined();

    it(""should parse IRT and set default RT when not defined"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.inReplyTo).toEqual(annotationRef.toString());

        expect(data.replyType).toEqual(""R"");

        done();

      }, done.fail);

    it(""should parse IRT/RT for a group type"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.inReplyTo).toEqual(annotationRef.toString());

      expect(data.replyType).toEqual(""R"");

    it(""should parse IRT/RT for a group type"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.inReplyTo).toEqual(annotationRef.toString());

        expect(data.replyType).toEqual(""Group"");

        expect(data.title).toEqual(""ParentTitle"");

        expect(data.contents).toEqual(""ParentText"");

        expect(data.creationDate).toEqual(""D:20180423"");

        expect(data.modificationDate).toEqual(""D:20190423"");

        expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

        expect(data.hasPopup).toEqual(true);

        done();

      }, done.fail);

    it(""should parse IRT/RT for a reply type"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.inReplyTo).toEqual(annotationRef.toString());

      expect(data.replyType).toEqual(""Group"");

      expect(data.title).toEqual(""ParentTitle"");

      expect(data.contents).toEqual(""ParentText"");

      expect(data.creationDate).toEqual(""D:20180423"");

      expect(data.modificationDate).toEqual(""D:20190423"");

      expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

      expect(data.hasPopup).toEqual(true);

    it(""should parse IRT/RT for a reply type"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.inReplyTo).toEqual(annotationRef.toString());

        expect(data.replyType).toEqual(""R"");

        expect(data.title).toEqual(""ReplyTitle"");

        expect(data.contents).toEqual(""ReplyText"");

        expect(data.creationDate).toEqual(""D:20180523"");

        expect(data.modificationDate).toEqual(""D:20190523"");

        expect(data.color).toEqual(new Uint8ClampedArray([102, 102, 102]));

        expect(data.hasPopup).toEqual(false);

        done();

      }, done.fail);

    it(""should not parse state model and state when not defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.inReplyTo).toEqual(annotationRef.toString());

      expect(data.replyType).toEqual(""R"");

      expect(data.title).toEqual(""ReplyTitle"");

      expect(data.contents).toEqual(""ReplyText"");

      expect(data.creationDate).toEqual(""D:20180523"");

      expect(data.modificationDate).toEqual(""D:20190523"");

      expect(data.color).toEqual(new Uint8ClampedArray([102, 102, 102]));

      expect(data.hasPopup).toEqual(false);

    it(""should not parse state model and state when not defined"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.stateModel).toBeNull();

        expect(data.state).toBeNull();

        done();

      }, done.fail);

    it(""should correctly parse state model and state when defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.stateModel).toBeNull();

      expect(data.state).toBeNull();

    it(""should correctly parse state model and state when defined"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.stateModel).toEqual(""Review"");

        expect(data.state).toEqual(""Rejected"");

        done();

      }, done.fail);

    it(""should correctly parse a URI action"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.stateModel).toEqual(""Review"");

      expect(data.state).toEqual(""Rejected"");

    it(""should correctly parse a URI action"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(""http://www.ctan.org/tex-archive/info/lshort"");

        expect(data.unsafeUrl).toEqual(

          ""http://www.ctan.org/tex-archive/info/lshort""

        );

        expect(data.dest).toBeUndefined();

        done();

      }, done.fail);

      function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.url).toEqual(""http://www.ctan.org/tex-archive/info/lshort"");

      expect(data.unsafeUrl).toEqual(

        ""http://www.ctan.org/tex-archive/info/lshort""

      );

      expect(data.dest).toBeUndefined();

      async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toEqual(""http://www.hmrc.gov.uk/"");

          expect(data.unsafeUrl).toEqual(""http://www.hmrc.gov.uk"");

          expect(data.dest).toBeUndefined();

          done();

        }, done.fail);

      function (done) {
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(""http://www.hmrc.gov.uk/"");

        expect(data.unsafeUrl).toEqual(""http://www.hmrc.gov.uk"");

        expect(data.dest).toBeUndefined();

      async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toEqual(

            new URL(

              stringToUTF8String(

                ""http://www.example.com/\xC3\xBC\xC3\xB6\xC3\xA4""

              )

            ).href

          );

          expect(data.unsafeUrl).toEqual(

          );

          expect(data.dest).toBeUndefined();

          done();

        }, done.fail);

    it(""should correctly parse a GoTo action"", function (done) {
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(

          new URL(

          ).href

        );

        expect(data.unsafeUrl).toEqual(

          stringToUTF8String(""http://www.example.com/\xC3\xBC\xC3\xB6\xC3\xA4"")

        );

        expect(data.dest).toBeUndefined();

    it(""should correctly parse a GoTo action"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toBeUndefined();

        expect(data.dest).toEqual(""page.157"");

        done();

      }, done.fail);

      function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.url).toBeUndefined();

      expect(data.unsafeUrl).toBeUndefined();

      expect(data.dest).toEqual(""page.157"");

      async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toBeUndefined();

          expect(data.unsafeUrl).toEqual(""../../0013/001346/134685E.pdf#4.3"");

          expect(data.dest).toBeUndefined();

          expect(data.newWindow).toEqual(true);

          done();

        }, done.fail);

      function (done) {
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toEqual(""../../0013/001346/134685E.pdf#4.3"");

        expect(data.dest).toBeUndefined();

        expect(data.newWindow).toEqual(true);

      async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toEqual(

            ""http://www.example.com/0013/001346/134685E.pdf#4.3""

          );

          expect(data.unsafeUrl).toEqual(""../../0013/001346/134685E.pdf#4.3"");

          expect(data.dest).toBeUndefined();

          done();

        }, done.fail);

    it(""should correctly parse a GoToR action, with named destination"", function (done) {
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(

          ""http://www.example.com/0013/001346/134685E.pdf#4.3""

        );

        expect(data.unsafeUrl).toEqual(""../../0013/001346/134685E.pdf#4.3"");

        expect(data.dest).toBeUndefined();

    it(""should correctly parse a GoToR action, with named destination"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(""http://www.example.com/test.pdf#15"");

        expect(data.unsafeUrl).toEqual(""http://www.example.com/test.pdf#15"");

        expect(data.dest).toBeUndefined();

        expect(data.newWindow).toBeFalsy();

        done();

      }, done.fail);

    it(""should correctly parse a GoToR action, with explicit destination array"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.url).toEqual(""http://www.example.com/test.pdf#15"");

      expect(data.unsafeUrl).toEqual(""http://www.example.com/test.pdf#15"");

      expect(data.dest).toBeUndefined();

      expect(data.newWindow).toBeFalsy();

    it(""should correctly parse a GoToR action, with explicit destination array"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(

          new URL(

            ""http://www.example.com/test.pdf#"" +

              '[14,{""name"":""XYZ""},null,298.043,null]'

          ).href

        );

        expect(data.unsafeUrl).toEqual(

        );

        expect(data.dest).toBeUndefined();

        expect(data.newWindow).toBeFalsy();

        done();

      }, done.fail);

      function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.url).toEqual(

        new URL(

        ).href

      );

      expect(data.unsafeUrl).toEqual(

        ""http://www.example.com/test.pdf#"" +

          '[14,{""name"":""XYZ""},null,298.043,null]'

      );

      expect(data.dest).toBeUndefined();

      expect(data.newWindow).toBeFalsy();

      async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toEqual(

            new URL(""http://www.example.com/test/pdfs/Part II/Part II.pdf"").href

          );

          expect(data.unsafeUrl).toEqual(""Part II/Part II.pdf"");

          expect(data.dest).toBeUndefined();

          expect(data.newWindow).toEqual(true);

          done();

        }, done.fail);

      function (done) {
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(

          new URL(""http://www.example.com/test/pdfs/Part II/Part II.pdf"").href

        );

        expect(data.unsafeUrl).toEqual(""Part II/Part II.pdf"");

        expect(data.dest).toBeUndefined();

        expect(data.newWindow).toEqual(true);

      async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"        Promise.all([annotation1, annotation2, annotation3]).then(

          done,

          done.fail

        );

    it(""should correctly parse a Named action"", function (done) {
","        await Promise.all([annotation1, annotation2, annotation3]);

    it(""should correctly parse a Named action"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toBeUndefined();

        expect(data.action).toEqual(""GoToPage"");

        done();

      }, done.fail);

    it(""should correctly parse a simple Dest"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.url).toBeUndefined();

      expect(data.unsafeUrl).toBeUndefined();

      expect(data.action).toEqual(""GoToPage"");

    it(""should correctly parse a simple Dest"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toBeUndefined();

        expect(data.dest).toEqual(""LI0"");

        done();

      }, done.fail);

    it(""should correctly parse a simple Dest, with explicit destination array"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.url).toBeUndefined();

      expect(data.unsafeUrl).toBeUndefined();

      expect(data.dest).toEqual(""LI0"");

    it(""should correctly parse a simple Dest, with explicit destination array"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toBeUndefined();

        expect(data.dest).toEqual([

          { num: 17, gen: 0 },

          { name: ""XYZ"" },

          0,

          841.89,

          null,

        ]);

        done();

      }, done.fail);

      function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.url).toBeUndefined();

      expect(data.unsafeUrl).toBeUndefined();

      expect(data.dest).toEqual([

        { num: 17, gen: 0 },

        { name: ""XYZ"" },

        0,

        841.89,

        null,

      ]);

      async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toBeUndefined();

          expect(data.unsafeUrl).toBeUndefined();

          expect(data.dest).toEqual(""page.157"");

          done();

        }, done.fail);

    it(""should not set quadpoints if not defined"", function (done) {
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toBeUndefined();

        expect(data.dest).toEqual(""page.157"");

    it(""should not set quadpoints if not defined"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.quadPoints).toBeUndefined();

        done();

      }, done.fail);

    it(""should set quadpoints if defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.quadPoints).toBeUndefined();

    it(""should set quadpoints if defined"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.quadPoints).toEqual([

          [

            { x: 10, y: 20 },

            { x: 20, y: 20 },

            { x: 10, y: 10 },

            { x: 20, y: 10 },

          ],

        ]);

        done();

      }, done.fail);
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.quadPoints).toEqual([

        [

          { x: 10, y: 20 },

          { x: 20, y: 20 },

          { x: 10, y: 10 },

          { x: 20, y: 10 },

        ],

      ]);
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"    it(""should handle unknown field names"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.fieldName).toEqual("""");

        done();

      }, done.fail);

    it(""should construct the field name when there are no ancestors"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.fieldName).toEqual(""foo"");

        done();

      }, done.fail);

    it(""should construct the field name when there are ancestors"", function (done) {
","    it(""should handle unknown field names"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.fieldName).toEqual("""");

    it(""should construct the field name when there are no ancestors"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.fieldName).toEqual(""foo"");

    it(""should construct the field name when there are ancestors"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.fieldName).toEqual(""foo.bar.baz"");

        done();

      }, done.fail);

      function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.fieldName).toEqual(""foo.bar.baz"");

      async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.WIDGET);

          expect(data.fieldName).toEqual(""foo.bar"");

          done();

        }, done.fail);
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.fieldName).toEqual(""foo.bar"");
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"    it(""should handle unknown text alignment, maximum length and flags"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.textAlignment).toEqual(null);

        expect(data.maxLen).toEqual(null);

        expect(data.readOnly).toEqual(false);

        expect(data.hidden).toEqual(false);

        expect(data.multiLine).toEqual(false);

        expect(data.comb).toEqual(false);

        expect(data.defaultFieldValue).toEqual(""foo"");

        done();

      }, done.fail);

    });



    it(""should not set invalid text alignment, maximum length and flags"", function (done) {
","    it(""should handle unknown text alignment, maximum length and flags"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.textAlignment).toEqual(null);

      expect(data.maxLen).toEqual(null);

      expect(data.readOnly).toEqual(false);

      expect(data.hidden).toEqual(false);

      expect(data.multiLine).toEqual(false);

      expect(data.comb).toEqual(false);

      expect(data.defaultFieldValue).toEqual(""foo"");

    });



    it(""should not set invalid text alignment, maximum length and flags"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.textAlignment).toEqual(null);

        expect(data.maxLen).toEqual(null);

        expect(data.readOnly).toEqual(false);

        expect(data.hidden).toEqual(false);

        expect(data.multiLine).toEqual(false);

        expect(data.comb).toEqual(false);

        done();

      }, done.fail);

    it(""should set valid text alignment, maximum length and flags"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.textAlignment).toEqual(null);

      expect(data.maxLen).toEqual(null);

      expect(data.readOnly).toEqual(false);

      expect(data.hidden).toEqual(false);

      expect(data.multiLine).toEqual(false);

      expect(data.comb).toEqual(false);

    it(""should set valid text alignment, maximum length and flags"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.textAlignment).toEqual(1);

        expect(data.maxLen).toEqual(20);

        expect(data.readOnly).toEqual(true);

        expect(data.hidden).toEqual(false);

        expect(data.multiLine).toEqual(true);

        done();

      }, done.fail);

    it(""should reject comb fields without a maximum length"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.comb).toEqual(false);

        done();

      }, done.fail);

    it(""should accept comb fields with a maximum length"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.comb).toEqual(true);

        done();

      }, done.fail);

    it(""should only accept comb fields when the flags are valid"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.textAlignment).toEqual(1);

      expect(data.maxLen).toEqual(20);

      expect(data.readOnly).toEqual(true);

      expect(data.hidden).toEqual(false);

      expect(data.multiLine).toEqual(true);

    it(""should reject comb fields without a maximum length"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.comb).toEqual(false);

    it(""should accept comb fields with a maximum length"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.comb).toEqual(true);

    it(""should only accept comb fields when the flags are valid"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      promise.then(done, done.fail);

    it(""should render regular text for printing"", function (done) {
","      await promise;

    it(""should render regular text for printing"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""test\\print"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm"" +

              "" 2.00 2.00 Td (test\\\\print) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should render regular text in Japanese for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""test\\print"" });



      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm"" +

          "" 2.00 2.00 Td (test\\\\print) Tj ET Q EMC""

      );

    });



    it(""should render regular text in Japanese for printing"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value: """",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          const utf16String =

            ""\x30\x53\x30\x93\x30\x6b\x30\x61"" +

            ""\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm"" +

              ` 2.00 2.00 Td (${utf16String}) Tj ET Q EMC`

          );

          done();

        }, done.fail);

    });



    it(""should render regular text for printing using normal appearance"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, {

        value: """",

      });

      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      const utf16String =

        ""\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm"" +

          ` 2.00 2.00 Td (${utf16String}) Tj ET Q EMC`

      );

    });



    it(""should render regular text for printing using normal appearance"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          done();

        })

        .catch(done.fail);

    it(""should render auto-sized text for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();



      const operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(3);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.setFillRGBColor,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[1]).toEqual(

        new Uint8ClampedArray([26, 51, 76])

      );

    it(""should render auto-sized text for printing"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""test (print)"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 8 Tf 0 g 1 0 0 1 0 0 Tm"" +

              "" 2.00 2.00 Td (test \\(print\\)) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should render auto-sized text in Japanese for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""test (print)"" });



      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Helv 8 Tf 0 g 1 0 0 1 0 0 Tm"" +

          "" 2.00 2.00 Td (test \\(print\\)) Tj ET Q EMC""

      );

    });



    it(""should render auto-sized text in Japanese for printing"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value: """",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          const utf16String =

            ""\x30\x53\x30\x93\x30\x6b\x30\x61"" +

            ""\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Goth 8 Tf 0 g 1 0 0 1 0 0 Tm"" +

              ` 2.00 2.00 Td (${utf16String}) Tj ET Q EMC`

          );

          done();

        }, done.fail);

    });



    it(""should not render a password for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, {

        value: """",

      });



      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      const utf16String =

        ""\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Goth 8 Tf 0 g 1 0 0 1 0 0 Tm"" +

          ` 2.00 2.00 Td (${utf16String}) Tj ET Q EMC`

      );

    });

    it(""should not render a password for printing"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""mypassword"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(null);

          done();

        }, done.fail);

    });



    it(""should render multiline text for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""mypassword"" });



      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(null);

    });



    it(""should render multiline text for printing"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value:

              ""a aa aaa aaaa aaaaa aaaaaa "" +

              ""pneumonoultramicroscopicsilicovolcanoconiosis"",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 10 Tm "" +

              ""2.00 -5.00 Td (a aa aaa ) Tj\n"" +

              ""0.00 -5.00 Td (aaaa aaaaa ) Tj\n"" +

              ""0.00 -5.00 Td (aaaaaa ) Tj\n"" +

              ""0.00 -5.00 Td (pneumonoultr) Tj\n"" +

              ""0.00 -5.00 Td (amicroscopi) Tj\n"" +

              ""0.00 -5.00 Td (csilicovolca) Tj\n"" +

              ""0.00 -5.00 Td (noconiosis) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should render multiline text in Japanese for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, {

        value:

          ""a aa aaa aaaa aaaaa aaaaaa "" +

          ""pneumonoultramicroscopicsilicovolcanoconiosis"",

      });

      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 10 Tm "" +

          ""2.00 -5.00 Td (a aa aaa ) Tj\n"" +

          ""0.00 -5.00 Td (aaaa aaaaa ) Tj\n"" +

          ""0.00 -5.00 Td (aaaaaa ) Tj\n"" +

          ""0.00 -5.00 Td (pneumonoultr) Tj\n"" +

          ""0.00 -5.00 Td (amicroscopi) Tj\n"" +

          ""0.00 -5.00 Td (csilicovolca) Tj\n"" +

          ""0.00 -5.00 Td (noconiosis) Tj ET Q EMC""

      );

    });



    it(""should render multiline text in Japanese for printing"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value: """",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 10 Tm "" +

              ""2.00 -5.00 Td (\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f) Tj\n"" +

              ""0.00 -5.00 Td (\x4e\x16\x75\x4c\x30\x6e) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should render multiline text with various EOL for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, {

        value: """",

      });

      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 10 Tm "" +

          ""2.00 -5.00 Td (\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f) Tj\n"" +

          ""0.00 -5.00 Td (\x4e\x16\x75\x4c\x30\x6e) Tj ET Q EMC""

      );

    });



    it(""should render multiline text with various EOL for printing"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value:

              ""Lorem ipsum dolor sit amet, consectetur adipiscing elit.\r"" +

              ""Aliquam vitae felis ac lectus bibendum ultricies quis non diam.\n"" +

              ""Morbi id porttitor quam, a iaculis dui.\r\n"" +

              ""Pellentesque habitant morbi tristique senectus et "" +

              ""netus et malesuada fames ac turpis egestas.\n\r\n\r"" +

              ""Nulla consectetur, ligula in tincidunt placerat, "" +

              ""velit augue consectetur orci, sed mattis libero nunc ut massa.\r"" +

              ""Etiam facilisis tempus interdum."",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(expectedAppearance);

          done();

        }, done.fail);

    it(""should render comb for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, {

        value:

          ""Lorem ipsum dolor sit amet, consectetur adipiscing elit.\r"" +

          ""Aliquam vitae felis ac lectus bibendum ultricies quis non diam.\n"" +

          ""Morbi id porttitor quam, a iaculis dui.\r\n"" +

          ""Pellentesque habitant morbi tristique senectus et "" +

          ""netus et malesuada fames ac turpis egestas.\n\r\n\r"" +

          ""Nulla consectetur, ligula in tincidunt placerat, "" +

          ""velit augue consectetur orci, sed mattis libero nunc ut massa.\r"" +

          ""Etiam facilisis tempus interdum."",

      });

      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(expectedAppearance);

    it(""should render comb for printing"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""aa(aa)a\\"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 2 2 Tm"" +

              "" (a) Tj 8.00 0 Td (a) Tj 8.00 0 Td (\\() Tj"" +

              "" 8.00 0 Td (a) Tj 8.00 0 Td (a) Tj"" +

              "" 8.00 0 Td (\\)) Tj 8.00 0 Td (a) Tj"" +

              "" 8.00 0 Td (\\\\) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should render comb with Japanese text for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""aa(aa)a\\"" });



      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 2 2 Tm"" +

          "" (a) Tj 8.00 0 Td (a) Tj 8.00 0 Td (\\() Tj"" +

          "" 8.00 0 Td (a) Tj 8.00 0 Td (a) Tj"" +

          "" 8.00 0 Td (\\)) Tj 8.00 0 Td (a) Tj"" +

          "" 8.00 0 Td (\\\\) Tj ET Q EMC""

      );

    });



    it(""should render comb with Japanese text for printing"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value: """",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 2 2 Tm"" +

              "" (\x30\x53) Tj 8.00 0 Td (\x30\x93) Tj 8.00 0 Td (\x30\x6b) Tj"" +

              "" 8.00 0 Td (\x30\x61) Tj 8.00 0 Td (\x30\x6f) Tj"" +

              "" 8.00 0 Td (\x4e\x16) Tj 8.00 0 Td (\x75\x4c) Tj"" +

              "" 8.00 0 Td (\x30\x6e) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should save text"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, {

        value: """",

      });

      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 2 2 Tm"" +

          "" (\x30\x53) Tj 8.00 0 Td (\x30\x93) Tj 8.00 0 Td (\x30\x6b) Tj"" +

          "" 8.00 0 Td (\x30\x61) Tj 8.00 0 Td (\x30\x6f) Tj"" +

          "" 8.00 0 Td (\x4e\x16) Tj 8.00 0 Td (\x75\x4c) Tj"" +

          "" 8.00 0 Td (\x30\x6e) Tj ET Q EMC""

      );

    });



    it(""should save text"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""hello world"" });



          return annotation.save(partialEvaluator, task, annotationStorage);

        }, done.fail)

        .then(data => {

          expect(data.length).toEqual(2);

          const [oldData, newData] = data;

          expect(oldData.ref).toEqual(Ref.get(123, 0));

          expect(newData.ref).toEqual(Ref.get(2, 0));



          oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(oldData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Helv 5 Tf) /DR "" +

              ""<< /Font << /Helv 314 0 R>>>> /Rect [0 0 32 10] "" +

              ""/V (hello world) /AP << /N 2 0 R>> /M (date)>>\nendobj\n""

          );

          expect(newData.data).toEqual(

            ""2 0 obj\n<< /Length 77 /Subtype /Form /Resources "" +

              ""<< /Font << /Helv 314 0 R>>>> /BBox [0 0 32 10]>> stream\n"" +

              ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (hello world) Tj "" +

              ""ET Q EMC\nendstream\nendobj\n""

          );

          done();

        }, done.fail);

    });



    it(""should get field object for usage in JS sandbox"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""hello world"" });



      const data = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(data.length).toEqual(2);

      const [oldData, newData] = data;

      expect(oldData.ref).toEqual(Ref.get(123, 0));

      expect(newData.ref).toEqual(Ref.get(2, 0));



      oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

      expect(oldData.data).toEqual(

        ""123 0 obj\n"" +

          ""<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Helv 5 Tf) /DR "" +

          ""<< /Font << /Helv 314 0 R>>>> /Rect [0 0 32 10] "" +

          ""/V (hello world) /AP << /N 2 0 R>> /M (date)>>\nendobj\n""

      );

      expect(newData.data).toEqual(

        ""2 0 obj\n<< /Length 77 /Subtype /Form /Resources "" +

          ""<< /Font << /Helv 314 0 R>>>> /BBox [0 0 32 10]>> stream\n"" +

          ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (hello world) Tj "" +

          ""ET Q EMC\nendstream\nendobj\n""

      );

    });



    it(""should get field object for usage in JS sandbox"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          return annotation.getFieldObject();

        })

        .then(object => {

          const actions = object.actions;

          expect(actions[""Mouse Enter""]).toEqual([""hello()""]);

          expect(actions[""Mouse Exit""]).toEqual([

            ""world()"",

            ""olleh()"",

            ""foo()"",

            ""dlrow()"",

            ""oof()"",

          ]);

          expect(actions[""Mouse Down""]).toEqual([""bar()""]);

          done();

        }, done.fail);

    it(""should save Japanese text"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const fieldObject = await annotation.getFieldObject();

      const actions = fieldObject.actions;

      expect(actions[""Mouse Enter""]).toEqual([""hello()""]);

      expect(actions[""Mouse Exit""]).toEqual([

        ""world()"",

        ""olleh()"",

        ""foo()"",

        ""dlrow()"",

        ""oof()"",

      ]);

      expect(actions[""Mouse Down""]).toEqual([""bar()""]);

    it(""should save Japanese text"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value: """",

          });

          return annotation.save(partialEvaluator, task, annotationStorage);

        }, done.fail)

        .then(data => {

          const utf16String =

            ""\x30\x53\x30\x93\x30\x6b\x30\x61"" +

            ""\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

          expect(data.length).toEqual(2);

          const [oldData, newData] = data;

          expect(oldData.ref).toEqual(Ref.get(123, 0));

          expect(newData.ref).toEqual(Ref.get(2, 0));



          oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(oldData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Goth 5 Tf) /DR "" +

              ""<< /Font << /Helv 314 0 R /Goth 159 0 R>>>> /Rect [0 0 32 10] "" +

              `/V (\xfe\xff${utf16String}) /AP << /N 2 0 R>> /M (date)>>\nendobj\n`

          );

          expect(newData.data).toEqual(

            ""2 0 obj\n<< /Length 82 /Subtype /Form /Resources "" +

              ""<< /Font << /Helv 314 0 R /Goth 159 0 R>>>> /BBox [0 0 32 10]>> stream\n"" +

              `/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (${utf16String}) Tj ` +

              ""ET Q EMC\nendstream\nendobj\n""

          );

          done();

        }, done.fail);
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, {

        value: """",

      });

      const data = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      const utf16String =

        ""\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

      expect(data.length).toEqual(2);

      const [oldData, newData] = data;

      expect(oldData.ref).toEqual(Ref.get(123, 0));

      expect(newData.ref).toEqual(Ref.get(2, 0));



      oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

      expect(oldData.data).toEqual(

        ""123 0 obj\n"" +

          ""<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Goth 5 Tf) /DR "" +

          ""<< /Font << /Helv 314 0 R /Goth 159 0 R>>>> /Rect [0 0 32 10] "" +

          `/V (\xfe\xff${utf16String}) /AP << /N 2 0 R>> /M (date)>>\nendobj\n`

      );

      expect(newData.data).toEqual(

        ""2 0 obj\n<< /Length 82 /Subtype /Form /Resources "" +

          ""<< /Font << /Helv 314 0 R /Goth 159 0 R>>>> /BBox [0 0 32 10]>> stream\n"" +

          `/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (${utf16String}) Tj ` +

          ""ET Q EMC\nendstream\nendobj\n""

      );
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(true);

        expect(data.fieldValue).toEqual(""1"");

        expect(data.defaultFieldValue).toEqual(""2"");

        expect(data.radioButton).toEqual(false);

        expect(data.exportValue).toEqual(""Checked"");

        done();

      }, done.fail);

    it(""should handle checkboxes without export value"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.checkBox).toEqual(true);

      expect(data.fieldValue).toEqual(""1"");

      expect(data.defaultFieldValue).toEqual(""2"");

      expect(data.radioButton).toEqual(false);

      expect(data.exportValue).toEqual(""Checked"");

    it(""should handle checkboxes without export value"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(true);

        expect(data.fieldValue).toEqual(""1"");

        expect(data.defaultFieldValue).toEqual(""2"");

        expect(data.radioButton).toEqual(false);

        done();

      }, done.fail);

    it(""should handle checkboxes without /Off appearance"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.checkBox).toEqual(true);

      expect(data.fieldValue).toEqual(""1"");

      expect(data.defaultFieldValue).toEqual(""2"");

      expect(data.radioButton).toEqual(false);

    it(""should handle checkboxes without /Off appearance"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(true);

        expect(data.fieldValue).toEqual(""1"");

        expect(data.defaultFieldValue).toEqual(""2"");

        expect(data.radioButton).toEqual(false);

        expect(data.exportValue).toEqual(""Checked"");

        done();

      }, done.fail);

    it(""should render checkbox with fallback font for printing"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.checkBox).toEqual(true);

      expect(data.fieldValue).toEqual(""1"");

      expect(data.defaultFieldValue).toEqual(""2"");

      expect(data.radioButton).toEqual(false);

      expect(data.exportValue).toEqual(""Checked"");

    it(""should render checkbox with fallback font for printing"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(5);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.dependency,

            OPS.setFont,

            OPS.showText,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[3][0][0].fontChar).toEqual("""");

          done();

        })

        .catch(done.fail);

    it(""should render checkboxes for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: true });



      const operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(5);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.dependency,

        OPS.setFont,

        OPS.showText,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[3][0][0].fontChar).toEqual("""");

    it(""should render checkboxes for printing"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.getOperatorList(

              partialEvaluator,

              task,

              false,

              annotationStorage

            ),

          ]);

        }, done.fail)

        .then(([annotation, opList]) => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          return annotation;

        }, done.fail)

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: false });



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        }, done.fail)

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([76, 51, 26])

          );

          done();

        }, done.fail);

    it(""should render checkboxes for printing two times"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: true });



      let operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(3);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.setFillRGBColor,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[1]).toEqual(

        new Uint8ClampedArray([26, 51, 76])

      );



      annotationStorage.set(annotation.data.id, { value: false });



      operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(3);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.setFillRGBColor,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[1]).toEqual(

        new Uint8ClampedArray([76, 51, 26])

      );

    it(""should render checkboxes for printing twice"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.getOperatorList(

              partialEvaluator,

              task,

              false,

              annotationStorage

            ),

          ]);

        })

        .then(([annotation, opList]) => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          return annotation;

        })

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          done();

        })

        .catch(done.fail);

    it(""should render checkboxes for printing using normal appearance"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();



      for (let i = 0; i < 2; i++) {

        annotationStorage.set(annotation.data.id, { value: true });



        const operatorList = await annotation.getOperatorList(

          partialEvaluator,

          task,

          false,

          annotationStorage

        );

        expect(operatorList.argsArray.length).toEqual(3);

        expect(operatorList.fnArray).toEqual([

          OPS.beginAnnotation,

          OPS.setFillRGBColor,

          OPS.endAnnotation,

        ]);

        expect(operatorList.argsArray[1]).toEqual(

          new Uint8ClampedArray([26, 51, 76])

        );

      }

    it(""should render checkboxes for printing using normal appearance"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          done();

        })

        .catch(done.fail);

    it(""should save checkboxes"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();



      const operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(3);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.setFillRGBColor,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[1]).toEqual(

        new Uint8ClampedArray([26, 51, 76])

      );

    it(""should save checkboxes"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.save(partialEvaluator, task, annotationStorage),

          ]);

        }, done.fail)

        .then(([annotation, [oldData]]) => {

          oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(oldData.ref).toEqual(Ref.get(123, 0));

          expect(oldData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Btn "" +

              ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" +

              ""/V /Checked /AS /Checked /M (date)>>\nendobj\n""

          );

          return annotation;

        }, done.fail)

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: false });



          return annotation.save(partialEvaluator, task, annotationStorage);

        }, done.fail)

        .then(data => {

          expect(data).toEqual(null);

          done();

        }, done.fail);

    });



    it(""should handle radio buttons with a field value"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: true });



      const [oldData] = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

      expect(oldData.ref).toEqual(Ref.get(123, 0));

      expect(oldData.data).toEqual(

        ""123 0 obj\n"" +

          ""<< /Type /Annot /Subtype /Widget /FT /Btn "" +

          ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" +

          ""/V /Checked /AS /Checked /M (date)>>\nendobj\n""

      );



      annotationStorage.set(annotation.data.id, { value: false });



      const data = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(data).toEqual(null);

    });



    it(""should handle radio buttons with a field value"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(false);

        expect(data.radioButton).toEqual(true);

        expect(data.fieldValue).toEqual(""1"");

        expect(data.buttonValue).toEqual(""2"");

        done();

      }, done.fail);

    it(""should handle radio buttons with a field value not an ascii string"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.checkBox).toEqual(false);

      expect(data.radioButton).toEqual(true);

      expect(data.fieldValue).toEqual(""1"");

      expect(data.buttonValue).toEqual(""2"");

    it(""should handle radio buttons with a field value that's not an ASCII string"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(false);

        expect(data.radioButton).toEqual(true);

        expect(data.fieldValue).toEqual(""I=e3"");

        expect(data.buttonValue).toEqual(""I=e3"");

        done();

      }, done.fail);

    it(""should handle radio buttons without a field value"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.checkBox).toEqual(false);

      expect(data.radioButton).toEqual(true);

      expect(data.fieldValue).toEqual(""I=e3"");

      expect(data.buttonValue).toEqual(""I=e3"");

    it(""should handle radio buttons without a field value"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(false);

        expect(data.radioButton).toEqual(true);

        expect(data.fieldValue).toEqual(null);

        expect(data.buttonValue).toEqual(""2"");

        done();

      }, done.fail);

    it(""should render radio buttons for printing"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.checkBox).toEqual(false);

      expect(data.radioButton).toEqual(true);

      expect(data.fieldValue).toEqual(null);

      expect(data.buttonValue).toEqual(""2"");

    it(""should render radio buttons for printing"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.getOperatorList(

              partialEvaluator,

              task,

              false,

              annotationStorage

            ),

          ]);

        }, done.fail)

        .then(([annotation, opList]) => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          return annotation;

        }, done.fail)

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: false });



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        }, done.fail)

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([76, 51, 26])

          );

          done();

        }, done.fail);

    it(""should render radio buttons for printing using normal appearance"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: true });



      let operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(3);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.setFillRGBColor,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[1]).toEqual(

        new Uint8ClampedArray([26, 51, 76])

      );



      annotationStorage.set(annotation.data.id, { value: false });



      operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(3);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.setFillRGBColor,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[1]).toEqual(

        new Uint8ClampedArray([76, 51, 26])

      );

    it(""should render radio buttons for printing using normal appearance"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([76, 51, 26])

          );

          done();

        })

        .catch(done.fail);

    it(""should save radio buttons"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();



      const operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(3);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.setFillRGBColor,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[1]).toEqual(

        new Uint8ClampedArray([76, 51, 26])

      );

    it(""should save radio buttons"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.save(partialEvaluator, task, annotationStorage),

          ]);

        }, done.fail)

        .then(([annotation, data]) => {

          expect(data.length).toEqual(2);

          const [radioData, parentData] = data;

          radioData.data = radioData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(radioData.ref).toEqual(Ref.get(123, 0));

          expect(radioData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Btn /Ff 32768 "" +

              ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" +

              ""/Parent 456 0 R /AS /Checked /M (date)>>\nendobj\n""

          );

          expect(parentData.ref).toEqual(Ref.get(456, 0));

          expect(parentData.data).toEqual(

            ""456 0 obj\n<< /V /Checked /Kids [123 0 R]>>\nendobj\n""

          );



          return annotation;

        }, done.fail)

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: false });



          return annotation.save(partialEvaluator, task, annotationStorage);

        }, done.fail)

        .then(data => {

          expect(data).toEqual(null);

          done();

        }, done.fail);

    });



    it(""should save radio buttons without a field value"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: true });



      let data = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(data.length).toEqual(2);

      const [radioData, parentData] = data;

      radioData.data = radioData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

      expect(radioData.ref).toEqual(Ref.get(123, 0));

      expect(radioData.data).toEqual(

        ""123 0 obj\n"" +

          ""<< /Type /Annot /Subtype /Widget /FT /Btn /Ff 32768 "" +

          ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" +

          ""/Parent 456 0 R /AS /Checked /M (date)>>\nendobj\n""

      );

      expect(parentData.ref).toEqual(Ref.get(456, 0));

      expect(parentData.data).toEqual(

        ""456 0 obj\n<< /V /Checked /Kids [123 0 R]>>\nendobj\n""

      );



      annotationStorage.set(annotation.data.id, { value: false });



      data = await annotation.save(partialEvaluator, task, annotationStorage);

      expect(data).toEqual(null);

    });



    it(""should save radio buttons without a field value"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.save(partialEvaluator, task, annotationStorage),

          ]);

        })

        .then(([annotation, data]) => {

          expect(data.length).toEqual(2);

          const [radioData, parentData] = data;

          radioData.data = radioData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(radioData.ref).toEqual(Ref.get(123, 0));

          expect(radioData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Btn /Ff 32768 "" +

              ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" +

              ""/Parent 456 0 R /AS /Checked /M (date)>>\nendobj\n""

          );

          expect(parentData.ref).toEqual(Ref.get(456, 0));

          expect(parentData.data).toEqual(

            ""456 0 obj\n<< /Kids [123 0 R] /V /Checked>>\nendobj\n""

          );

          done();

        })

        .catch(done.fail);

    });



    it(""should save nothing"", function (done) {

      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          return annotation.save(partialEvaluator, task, annotationStorage);

        })

        .then(data => {

          expect(data).toEqual(null);

          done();

        })

        .catch(done.fail);

    it(""should handle push buttons"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: true });



      const data = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(data.length).toEqual(2);

      const [radioData, parentData] = data;

      radioData.data = radioData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

      expect(radioData.ref).toEqual(Ref.get(123, 0));

      expect(radioData.data).toEqual(

        ""123 0 obj\n"" +

          ""<< /Type /Annot /Subtype /Widget /FT /Btn /Ff 32768 "" +

          ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" +

          ""/Parent 456 0 R /AS /Checked /M (date)>>\nendobj\n""

      );

      expect(parentData.ref).toEqual(Ref.get(456, 0));

      expect(parentData.data).toEqual(

        ""456 0 obj\n<< /Kids [123 0 R] /V /Checked>>\nendobj\n""

      );

    });



    it(""should save nothing"", async function () {

      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      const data = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(data).toEqual(null);

    it(""should handle push buttons"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.pushButton).toEqual(true);

        expect(data.actions.Action).toEqual([""do_something();""]);

        done();

      }, done.fail);

    it(""should handle push buttons that act as a tooltip only"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.pushButton).toEqual(true);

      expect(data.actions.Action).toEqual([""do_something();""]);

    it(""should handle push buttons that act as a tooltip only"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.pushButton).toEqual(true);

        expect(data.alternativeText).toEqual(""An alternative text"");

        done();

      }, done.fail);

    it(""should handle URL in A dict in push buttons"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.pushButton).toEqual(true);

      expect(data.alternativeText).toEqual(""An alternative text"");

    it(""should handle URL in A dict in push buttons"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.url).toEqual(""https://developer.mozilla.org/en-US/"");

        done();

      }, done.fail);

    it(""should handle URL in AA dict in push buttons"", function (done) {

      // D stands for MouseDown
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.url).toEqual(""https://developer.mozilla.org/en-US/"");

    it(""should handle URL in AA dict in push buttons"", async function () {

      // D stands for MouseDown.
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.url).toEqual(""https://developer.mozilla.org/en-US/"");

        done();

      }, done.fail);
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.url).toEqual(""https://developer.mozilla.org/en-US/"");
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"    it(""should handle missing option arrays"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.options).toEqual([]);

        done();

      }, done.fail);

    it(""should handle option arrays with array elements"", function (done) {
","    it(""should handle missing option arrays"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.options).toEqual([]);

    it(""should handle option arrays with array elements"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.options).toEqual(expected);

        done();

      }, done.fail);

    it(""should handle option arrays with string elements"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.options).toEqual(expected);

    it(""should handle option arrays with string elements"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.options).toEqual(expected);

        done();

      }, done.fail);

    it(""should handle inherited option arrays (issue 8094)"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.options).toEqual(expected);

    it(""should handle inherited option arrays (issue 8094)"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.options).toEqual(expected);

        done();

      }, done.fail);

    it(""should decode form values"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.options).toEqual(expected);

    it(""should decode form values"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.fieldValue).toEqual([decodedString]);

        expect(data.defaultFieldValue).toEqual(""foo"");

        expect(data.options).toEqual([

          { exportValue: decodedString, displayValue: decodedString },

        ]);

        done();

      }, done.fail);

    it(""should convert the field value to an array"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.fieldValue).toEqual([decodedString]);

      expect(data.defaultFieldValue).toEqual(""foo"");

      expect(data.options).toEqual([

        { exportValue: decodedString, displayValue: decodedString },

      ]);

    it(""should convert the field value to an array"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      promise.then(done, done.fail);

    it(""should handle unknown flags"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.readOnly).toEqual(false);

        expect(data.hidden).toEqual(false);

        expect(data.combo).toEqual(false);

        expect(data.multiSelect).toEqual(false);

        done();

      }, done.fail);

    it(""should not set invalid flags"", function (done) {
","      await promise;

    it(""should handle unknown flags"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.readOnly).toEqual(false);

      expect(data.hidden).toEqual(false);

      expect(data.combo).toEqual(false);

      expect(data.multiSelect).toEqual(false);

    it(""should not set invalid flags"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.readOnly).toEqual(false);

        expect(data.hidden).toEqual(false);

        expect(data.combo).toEqual(false);

        expect(data.multiSelect).toEqual(false);

        done();

      }, done.fail);

    it(""should set valid flags"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.readOnly).toEqual(false);

      expect(data.hidden).toEqual(false);

      expect(data.combo).toEqual(false);

      expect(data.multiSelect).toEqual(false);

    it(""should set valid flags"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.readOnly).toEqual(true);

        expect(data.hidden).toEqual(false);

        expect(data.combo).toEqual(true);

        expect(data.multiSelect).toEqual(true);

        done();

      }, done.fail);

    it(""should render choice for printing"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.readOnly).toEqual(true);

      expect(data.hidden).toEqual(false);

      expect(data.combo).toEqual(true);

      expect(data.multiSelect).toEqual(true);

    it(""should render choice for printing"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""a value"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm"" +

              "" 2.00 2.00 Td (a value) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should save choice"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""a value"" });



      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm"" +

          "" 2.00 2.00 Td (a value) Tj ET Q EMC""

      );

    });



    it(""should save choice"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""C"" });



          return annotation.save(partialEvaluator, task, annotationStorage);

        }, done.fail)

        .then(data => {

          expect(data.length).toEqual(2);

          const [oldData, newData] = data;

          expect(oldData.ref).toEqual(Ref.get(123, 0));

          expect(newData.ref).toEqual(Ref.get(1, 0));



          oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(oldData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Ch /DA (/Helv 5 Tf) /DR "" +

              ""<< /Font << /Helv 314 0 R>>>> "" +

              ""/Rect [0 0 32 10] /Opt [(A) (B) (C)] /V (C) "" +

              ""/AP << /N 1 0 R>> /M (date)>>\nendobj\n""

          );

          expect(newData.data).toEqual(

            ""1 0 obj\n"" +

              ""<< /Length 67 /Subtype /Form /Resources << /Font << /Helv 314 0 R>>>> "" +

              ""/BBox [0 0 32 10]>> stream\n"" +

              ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (C) Tj ET Q EMC\n"" +

              ""endstream\nendobj\n""

          );

          done();

        }, done.fail);

    it(""should set the line coordinates"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""C"" });



      const data = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(data.length).toEqual(2);

      const [oldData, newData] = data;

      expect(oldData.ref).toEqual(Ref.get(123, 0));

      expect(newData.ref).toEqual(Ref.get(1, 0));



      oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

      expect(oldData.data).toEqual(

        ""123 0 obj\n"" +

          ""<< /Type /Annot /Subtype /Widget /FT /Ch /DA (/Helv 5 Tf) /DR "" +

          ""<< /Font << /Helv 314 0 R>>>> "" +

          ""/Rect [0 0 32 10] /Opt [(A) (B) (C)] /V (C) "" +

          ""/AP << /N 1 0 R>> /M (date)>>\nendobj\n""

      );

      expect(newData.data).toEqual(

        ""1 0 obj\n"" +

          ""<< /Length 67 /Subtype /Form /Resources << /Font << /Helv 314 0 R>>>> "" +

          ""/BBox [0 0 32 10]>> stream\n"" +

          ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (C) Tj ET Q EMC\n"" +

          ""endstream\nendobj\n""

      );

    it(""should set the line coordinates"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINE);

        expect(data.lineCoordinates).toEqual([1, 2, 3, 4]);

        done();

      }, done.fail);

    it(""should correctly parse a file attachment"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINE);

      expect(data.lineCoordinates).toEqual([1, 2, 3, 4]);

    it(""should correctly parse a file attachment"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.FILEATTACHMENT);

        expect(data.file.filename).toEqual(""Test.txt"");

        expect(data.file.content).toEqual(stringToBytes(""Test attachment""));

        done();

      }, done.fail);

    it(""should inherit properties from its parent"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.FILEATTACHMENT);

      expect(data.file.filename).toEqual(""Test.txt"");

      expect(data.file.content).toEqual(stringToBytes(""Test attachment""));

    it(""should inherit properties from its parent"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data, viewable }) => {

        expect(data.annotationType).toEqual(AnnotationType.POPUP);

        expect(data.modificationDate).toEqual(""D:20190423"");

        expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

        done();

      }, done.fail);

    it(""should handle missing parent properties"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.POPUP);

      expect(data.modificationDate).toEqual(""D:20190423"");

      expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

    it(""should handle missing parent properties"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data, viewable }) => {

        expect(data.annotationType).toEqual(AnnotationType.POPUP);

        expect(data.modificationDate).toEqual(null);

        expect(data.color).toEqual(null);

        done();

      }, done.fail);

      function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.POPUP);

      expect(data.modificationDate).toEqual(null);

      expect(data.color).toEqual(null);

      async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"        AnnotationFactory.create(

        ).then(({ data, viewable }) => {

          expect(data.annotationType).toEqual(AnnotationType.POPUP);

          // We should not modify the `annotationFlags` returned through

          // e.g., the API.

          expect(data.annotationFlags).toEqual(25);

          // The popup should inherit the `viewable` property of the parent.

          expect(viewable).toEqual(true);

          done();

        }, done.fail);

      function (done) {
","        const { data, viewable } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.POPUP);

        // We should not modify the `annotationFlags` returned through

        // e.g., the API.

        expect(data.annotationFlags).toEqual(25);

        // The popup should inherit the `viewable` property of the parent.

        expect(viewable).toEqual(true);

      async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.title).toEqual(""Correct Title"");

          expect(data.contents).toEqual(""Correct Text"");

          expect(data.modificationDate).toEqual(""D:20190423"");

          expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

          done();

        }, done.fail);

    it(""should handle a single ink list"", function (done) {
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.title).toEqual(""Correct Title"");

        expect(data.contents).toEqual(""Correct Text"");

        expect(data.modificationDate).toEqual(""D:20190423"");

        expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

    it(""should handle a single ink list"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.INK);

        expect(data.inkLists.length).toEqual(1);

        expect(data.inkLists[0]).toEqual([

          { x: 1, y: 1 },

          { x: 1, y: 2 },

          { x: 2, y: 2 },

          { x: 3, y: 3 },

        ]);

        done();

      }, done.fail);

    it(""should handle multiple ink lists"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.INK);

      expect(data.inkLists.length).toEqual(1);

      expect(data.inkLists[0]).toEqual([

        { x: 1, y: 1 },

        { x: 1, y: 2 },

        { x: 2, y: 2 },

        { x: 3, y: 3 },

      ]);

    it(""should handle multiple ink lists"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.INK);

        expect(data.inkLists.length).toEqual(2);

        expect(data.inkLists[0]).toEqual([

          { x: 1, y: 1 },

          { x: 1, y: 2 },

        ]);

        expect(data.inkLists[1]).toEqual([

          { x: 3, y: 3 },

          { x: 4, y: 5 },

        ]);

        done();

      }, done.fail);

    it(""should set quadpoints to null if not defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.INK);

      expect(data.inkLists.length).toEqual(2);

      expect(data.inkLists[0]).toEqual([

        { x: 1, y: 1 },

        { x: 1, y: 2 },

      ]);

      expect(data.inkLists[1]).toEqual([

        { x: 3, y: 3 },

        { x: 4, y: 5 },

      ]);

    it(""should set quadpoints to null if not defined"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);

        expect(data.quadPoints).toEqual(null);

        done();

      }, done.fail);

    it(""should set quadpoints if defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);

      expect(data.quadPoints).toEqual(null);

    it(""should set quadpoints if defined"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);

        expect(data.quadPoints).toEqual([

          [

            { x: 10, y: 20 },

            { x: 20, y: 20 },

            { x: 10, y: 10 },

            { x: 20, y: 10 },

          ],

        ]);

        done();

      }, done.fail);

    it(""should set quadpoints to null when empty"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);

      expect(data.quadPoints).toEqual([

        [

          { x: 10, y: 20 },

          { x: 20, y: 20 },

          { x: 10, y: 10 },

          { x: 20, y: 10 },

        ],

      ]);

    it(""should set quadpoints to null when empty"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);

        expect(data.quadPoints).toEqual(null);

        done();

      }, done.fail);

    it(""should set quadpoints to null if not defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);

      expect(data.quadPoints).toEqual(null);

    it(""should set quadpoints to null if not defined"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.UNDERLINE);

        expect(data.quadPoints).toEqual(null);

        done();

      }, done.fail);

    it(""should set quadpoints if defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.UNDERLINE);

      expect(data.quadPoints).toEqual(null);

    it(""should set quadpoints if defined"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.UNDERLINE);

        expect(data.quadPoints).toEqual([

          [

            { x: 10, y: 20 },

            { x: 20, y: 20 },

            { x: 10, y: 10 },

            { x: 20, y: 10 },

          ],

        ]);

        done();

      }, done.fail);

    it(""should set quadpoints to null if not defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.UNDERLINE);

      expect(data.quadPoints).toEqual([

        [

          { x: 10, y: 20 },

          { x: 20, y: 20 },

          { x: 10, y: 10 },

          { x: 20, y: 10 },

        ],

      ]);

    it(""should set quadpoints to null if not defined"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);

        expect(data.quadPoints).toEqual(null);

        done();

      }, done.fail);

    it(""should set quadpoints if defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);

      expect(data.quadPoints).toEqual(null);

    it(""should set quadpoints if defined"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);

        expect(data.quadPoints).toEqual([

          [

            { x: 10, y: 20 },

            { x: 20, y: 20 },

            { x: 10, y: 10 },

            { x: 20, y: 10 },

          ],

        ]);

        done();

      }, done.fail);

    it(""should set quadpoints to null if not defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);

      expect(data.quadPoints).toEqual([

        [

          { x: 10, y: 20 },

          { x: 20, y: 20 },

          { x: 10, y: 10 },

          { x: 20, y: 10 },

        ],

      ]);

    it(""should set quadpoints to null if not defined"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);

        expect(data.quadPoints).toEqual(null);

        done();

      }, done.fail);

    it(""should set quadpoints if defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);

      expect(data.quadPoints).toEqual(null);

    it(""should set quadpoints if defined"", async function () {
",2021-04-17 18:23:40+02:00
f4237d3a09ced37f67d4859b12d5fb60bc986548,Tim van der Meij,Convert done callbacks to async/await in `test/unit/annotation_spec.js`,test/unit/annotation_spec.js,https://github.com/mozilla/pdf.js/commit/f4237d3a09ced37f67d4859b12d5fb60bc986548,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);

        expect(data.quadPoints).toEqual([

          [

            { x: 10, y: 20 },

            { x: 20, y: 20 },

            { x: 10, y: 10 },

            { x: 20, y: 10 },

          ],

        ]);

        done();

      }, done.fail);
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);

      expect(data.quadPoints).toEqual([

        [

          { x: 10, y: 20 },

          { x: 20, y: 20 },

          { x: 10, y: 10 },

          { x: 20, y: 10 },

        ],

      ]);
",2021-04-17 18:23:40+02:00
d42f3d0bfe76756b4ad233b7e1e03859009479b2,Tim van der Meij,Convert done callbacks to async/await in `test/unit/evaluator_spec.js`,test/unit/evaluator_spec.js,https://github.com/mozilla/pdf.js/commit/d42f3d0bfe76756b4ad233b7e1e03859009479b2,"  function runOperatorListCheck(evaluator, stream, resources, callback) {

    const result = new OperatorList();

    evaluator

      .getOperatorList({

        stream,

        task,

        resources,

        operatorList: result,

      })

      .then(

        function () {

          callback(result);

        },

        function (reason) {

          callback(reason);

        }

      );
","  async function runOperatorListCheck(evaluator, stream, resources) {

    const operatorList = new OperatorList();

    await evaluator.getOperatorList({

      stream,

      task,

      resources,

      operatorList,

    });

    return operatorList;
",2021-04-17 19:47:56+02:00
3d55b2b10eb9bc0201490184a05fc5ed209521a6,Jonas Jenwald,Replace `done` callbacks in the font-tests with async/await instead,test/font/font_fpgm_spec.js,https://github.com/mozilla/pdf.js/commit/3d55b2b10eb9bc0201490184a05fc5ed209521a6,"    it(""table was truncated in the middle of functions"", function (done) {

      CMapFactory.create({

      }).then(function (cMap) {

        const font = new Font(""font"", new Stream(font2324), {

          loadedName: ""font"",

          type: ""CIDFontType2"",

          differences: [],

          defaultEncoding: [],

          cMap,

          toUnicode: new ToUnicodeMap([]),

        });

        ttx(font.data, function (output) {

          verifyTtxOutput(output);

          expect(

            /(ENDF\[ \]|SVTCA\[0\])\s*<\/assembly>\s*<\/fpgm>/.test(output)

          ).toEqual(true);

          done();

        });
","    it(""table was truncated in the middle of functions"", async function () {

      const cMap = await CMapFactory.create({

      const font = new Font(""font"", new Stream(font2324), {

        loadedName: ""font"",

        type: ""CIDFontType2"",

        differences: [],

        defaultEncoding: [],

        cMap,

        toUnicode: new ToUnicodeMap([]),

      });

      const output = await ttx(font.data);



      verifyTtxOutput(output);

      expect(

        /(ENDF\[ \]|SVTCA\[0\])\s*<\/assembly>\s*<\/fpgm>/.test(output)

      ).toEqual(true);
",2021-04-19 13:26:39+02:00
3d55b2b10eb9bc0201490184a05fc5ed209521a6,Jonas Jenwald,Replace `done` callbacks in the font-tests with async/await instead,test/font/font_os2_spec.js,https://github.com/mozilla/pdf.js/commit/3d55b2b10eb9bc0201490184a05fc5ed209521a6,"      ttx(font.data, function (output) {

        verifyTtxOutput(output);

        expect(/<OS_2>\s*<version value=""3""\/>/.test(output)).toEqual(true);

        done();

      });

    it(""has invalid selection attributes presence"", function (done) {

      CMapFactory.create({

      }).then(function (cMap) {

        const font = new Font(""font"", new Stream(font1282), {

          loadedName: ""font"",

          type: ""CIDFontType2"",

          differences: [],

          defaultEncoding: [],

          cMap,

          toUnicode: new ToUnicodeMap([]),

        });

        ttx(font.data, function (output) {

          verifyTtxOutput(output);

          expect(/<OS_2>\s*<version value=""3""\/>/.test(output)).toEqual(true);

          done();

        });
","      const output = await ttx(font.data);



      verifyTtxOutput(output);

      expect(/<OS_2>\s*<version value=""3""\/>/.test(output)).toEqual(true);

    it(""has invalid selection attributes presence"", async function () {

      const cMap = await CMapFactory.create({

      const font = new Font(""font"", new Stream(font1282), {

        loadedName: ""font"",

        type: ""CIDFontType2"",

        differences: [],

        defaultEncoding: [],

        cMap,

        toUnicode: new ToUnicodeMap([]),

      });

      const output = await ttx(font.data);



      verifyTtxOutput(output);

      expect(/<OS_2>\s*<version value=""3""\/>/.test(output)).toEqual(true);
",2021-04-19 13:26:39+02:00
3d55b2b10eb9bc0201490184a05fc5ed209521a6,Jonas Jenwald,Replace `done` callbacks in the font-tests with async/await instead,test/font/font_post_spec.js,https://github.com/mozilla/pdf.js/commit/3d55b2b10eb9bc0201490184a05fc5ed209521a6,"    it(""has invalid version number"", function (done) {

      CMapFactory.create({

      }).then(function (cMap) {

        const font = new Font(""font"", new Stream(font2109), {

          loadedName: ""font"",

          type: ""CIDFontType2"",

          differences: [],

          defaultEncoding: [],

          cMap,

          toUnicode: new ToUnicodeMap([]),

        });

        ttx(font.data, function (output) {

          verifyTtxOutput(output);

          expect(/<post>\s*<formatType value=""3\.0""\/>/.test(output)).toEqual(

            true

          );

          done();

        });

    it(""has invalid glyph name indexes"", function (done) {
","    it(""has invalid version number"", async function () {

      const cMap = await CMapFactory.create({

      const font = new Font(""font"", new Stream(font2109), {

        loadedName: ""font"",

        type: ""CIDFontType2"",

        differences: [],

        defaultEncoding: [],

        cMap,

        toUnicode: new ToUnicodeMap([]),

      });

      const output = await ttx(font.data);



      verifyTtxOutput(output);

      expect(/<post>\s*<formatType value=""3\.0""\/>/.test(output)).toEqual(true);

    it(""has invalid glyph name indexes"", async function () {
",2021-04-19 13:26:39+02:00
7b8d2495cab70336858f94b40d8815617a3cc23c,Jonas Jenwald,"Convert the font-test `ttx` helper function to use the Fetch API

By replacing `XMLHttpRequest` with a `fetch` call, the helper function can be modernized to use async/await instead.
Note that the headers doesn't seem necessary to set now, since:
 - The Fetch API provides a method for accessing the response as *text*, which renders the ""Content-type"" header unnecessary.
 - According to https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name, the ""Content-length"" header isn't necessary.",test/font/fontutils.js,https://github.com/mozilla/pdf.js/commit/7b8d2495cab70336858f94b40d8815617a3cc23c,"function ttx(data) {

  return new Promise((resolve, reject) => {

    const xhr = new XMLHttpRequest();

    xhr.open(""POST"", ""/ttx"");



    const encodedData = encodeFontData(data);

    xhr.setRequestHeader(""Content-type"", ""text/plain"");

    xhr.setRequestHeader(""Content-length"", encodedData.length);



    xhr.onreadystatechange = function getPdfOnreadystatechange(e) {

      if (xhr.readyState === 4) {

        if (xhr.status === 200) {

          resolve(xhr.responseText);

        } else {

          reject(new Error(xhr.statusText));

        }

      }

    };

    xhr.send(encodedData);
","async function ttx(data) {

  const response = await fetch(""/ttx"", {

    method: ""POST"",

    body: encodeFontData(data),



  if (!response.ok) {

    throw new Error(response.statusText);

  }

  return response.text();
",2021-04-20 23:35:25+02:00
ddea90b8f6fbeca189bb81254c63f406675dd973,Jonas Jenwald,"Remove the `isFetchSupported` function since the Fetch API is available in all supported browsers

The currently supported browsers, note the minimum versions [listed here](https://github.com/mozilla/pdf.js/blob/5a4e06af2d1f5bf1a4281b4ec3ec18bccd2adebb/gulpfile.js#L78-L88), should now have native support for all of the features checked in the `isFetchSupported` function:

 - https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#browser_compatibility
 - https://developer.mozilla.org/en-US/docs/Web/API/Response#browser_compatibility
 - https://developer.mozilla.org/en-US/docs/Web/API/Body/body#browser_compatibility
 - https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream#browser_compatibility

Hence this function can now be removed, and the code can thus be simplified a little bit.",src/pdf.js,https://github.com/mozilla/pdf.js/commit/ddea90b8f6fbeca189bb81254c63f406675dd973,"  setPDFNetworkStreamFactory(params => {

    return streamsPromise.then(streams => {

      const [{ PDFNetworkStream }, { PDFFetchStream }] = streams;

      if (isFetchSupported() && isValidFetchUrl(params.url)) {

        return new PDFFetchStream(params);

      }

      return new PDFNetworkStream(params);

    });

} else if (PDFJSDev.test(""GENERIC"")) {

  const { isNodeJS } = require(""./shared/is_node.js"");

  if (isNodeJS) {

    const PDFNodeStream = require(""./display/node_stream.js"").PDFNodeStream;

    const PDFNetworkStream = require(""./display/network.js"").PDFNetworkStream;

    let PDFFetchStream;

    if (isFetchSupported()) {

      PDFFetchStream = require(""./display/fetch_stream.js"").PDFFetchStream;

    }

      if (PDFFetchStream && isValidFetchUrl(params.url)) {

} else if (PDFJSDev.test(""CHROME"")) {

  const PDFNetworkStream = require(""./display/network.js"").PDFNetworkStream;

  let PDFFetchStream;

  const isChromeWithFetchCredentials = function () {

    // fetch does not include credentials until Chrome 61.0.3138.0 and later.

    // https://chromium.googlesource.com/chromium/src/+/2e231cf052ca5e68e22baf0008ac9e5e29121707

    try {

      // Indexed properties on window are read-only in Chrome 61.0.3151.0+

      // https://chromium.googlesource.com/chromium/src.git/+/58ab4a971b06dec13e4edf9de8382ca6847f6190

      window[999] = 123; // should throw. Note: JS strict mode MUST be enabled.

      delete window[999];

      return false;

    } catch (e) {

      return true;

    }

  };

  if (isFetchSupported() && isChromeWithFetchCredentials()) {

    PDFFetchStream = require(""./display/fetch_stream.js"").PDFFetchStream;

  }

  setPDFNetworkStreamFactory(params => {

    if (PDFFetchStream && isValidFetchUrl(params.url)) {

      return new PDFFetchStream(params);

    }

    return new PDFNetworkStream(params);

  });
","

  setPDFNetworkStreamFactory(async params => {

    const [{ PDFNetworkStream }, { PDFFetchStream }] = await streamsPromise;

    if (isValidFetchUrl(params.url)) {

      return new PDFFetchStream(params);

    }

    return new PDFNetworkStream(params);

} else if (PDFJSDev.test(""GENERIC || CHROME"")) {

  if (PDFJSDev.test(""GENERIC"") && isNodeJS) {

    const { PDFNodeStream } = require(""./display/node_stream.js"");



    const { PDFNetworkStream } = require(""./display/network.js"");

    const { PDFFetchStream } = require(""./display/fetch_stream.js"");



      if (isValidFetchUrl(params.url)) {
",2021-06-11 22:53:09+02:00
edc38de37ac7a1ba659b59598a254c38ac1fcf33,Jonas Jenwald,"Convert `PartialEvaluator.buildToUnicode` to an `async` method

This removes the need to *manually* wrap all return values in a Promise.",src/core/evaluator.js,https://github.com/mozilla/pdf.js/commit/edc38de37ac7a1ba659b59598a254c38ac1fcf33,"      const registry = properties.cidSystemInfo.registry;

      const ordering = properties.cidSystemInfo.ordering;

      const ucs2CMapName = Name.get(registry + ""-"" + ordering + ""-UCS2"");

      return CMapFactory.create({

      }).then(function (ucs2CMap) {

        const cMap = properties.cMap;

        const toUnicode = [];

        cMap.forEach(function (charcode, cid) {

          if (cid > 0xffff) {

            throw new FormatError(""Max size of CID is 65,535"");

          }

          // e) Map the CID obtained in step (a) according to the CMap

          // obtained in step (d), producing a Unicode value.

          const ucs2 = ucs2CMap.lookup(cid);

          if (ucs2) {

            toUnicode[charcode] = String.fromCharCode(

              (ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1)

            );

          }

        });

        return new ToUnicodeMap(toUnicode);

    return Promise.resolve(

      new IdentityToUnicodeMap(properties.firstChar, properties.lastChar)

    );
","      const { registry, ordering } = properties.cidSystemInfo;

      const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);

      const ucs2CMap = await CMapFactory.create({

      const toUnicode = [];

      properties.cMap.forEach(function (charcode, cid) {

        if (cid > 0xffff) {

          throw new FormatError(""Max size of CID is 65,535"");

        }

        // e) Map the CID obtained in step (a) according to the CMap

        // obtained in step (d), producing a Unicode value.

        const ucs2 = ucs2CMap.lookup(cid);

        if (ucs2) {

          toUnicode[charcode] = String.fromCharCode(

            (ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1)

          );

        }

      });

      return new ToUnicodeMap(toUnicode);

    return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
",2021-05-17 15:40:23+02:00
bc8787b04939715816722769dfa309d909d0063d,Jonas Jenwald,"Re-factor `loadAndEnablePDFBug` and `PDFBug.init`

The `loadAndEnablePDFBug` helper function, in `web/app.js`, can be simplified a little bit by making it `async`. Furthermore, given how `PDFBug` is being used, we can also (slightly) re-factor `PDFBug.init` such that the `PDFBug.enable`-call is done internally rather than having to handle that manually at the call-site.

(Finally, utilize `await` more in the `loadFakeWorker` helper function.)",web/app.js,https://github.com/mozilla/pdf.js/commit/bc8787b04939715816722769dfa309d909d0063d,"    return undefined;

  return loadScript(PDFWorker.workerSrc);

function loadAndEnablePDFBug(enabledTabs) {

  const appConfig = PDFViewerApplication.appConfig;

  return loadScript(appConfig.debuggerScriptPath).then(function () {

    PDFBug.enable(enabledTabs);

    PDFBug.init({ OPS }, appConfig.mainContainer);

  });
","    return;

  await loadScript(PDFWorker.workerSrc);

async function initPDFBug(enabledTabs) {

  const { debuggerScriptPath, mainContainer } = PDFViewerApplication.appConfig;

  await loadScript(debuggerScriptPath);

  PDFBug.init({ OPS }, mainContainer, enabledTabs);
",2021-08-18 15:59:30+02:00
ce3f5ea2bf73ab9d4a3d86bc61576f5d14785ab0,Jonas Jenwald,"Use `async` a bit more in the API

This patch changes the `PDFDocumentLoadingTask.destroy`-method and the `_fetchDocument`-function to be `async`, which slightly simplifies the relevant code.

Furthermore, remove the catch-handler from the `WorkerTransport.getPageIndex`-method since it's no longer needed. Given that the `MessageHandler` is nowadays wrapping every possible Exception, it's no longer necessary to try and re-wrap the reason here.",src/display/api.js,https://github.com/mozilla/pdf.js/commit/ce3f5ea2bf73ab9d4a3d86bc61576f5d14785ab0,"  destroy() {

    const transportDestroyed = !this._transport

      ? Promise.resolve()

      : this._transport.destroy();

    return transportDestroyed.then(() => {

      this._transport = null;

      if (this._worker) {

        this._worker.destroy();

        this._worker = null;

      }

    });
","  async destroy() {

    await this._transport?.destroy();

    this._transport = null;

    if (this._worker) {

      this._worker.destroy();

      this._worker = null;

    }
",2021-08-29 12:11:36+02:00
6cba5509f26ede9986cbc4c100b037d3347d7c91,Jonas Jenwald,"Re-factor `document.getElementsByName` lookups in the AnnotationLayer (issue 14003)

This replaces direct `document.getElementsByName` lookups with a helper method which:
 - Lets the AnnotationLayer use the data returned by the `PDFDocumentProxy.getFieldObjects` API-method, such that we can directly lookup only the necessary DOM elements.
 - Fallback to using `document.getElementsByName` as before, such that e.g. the standalone viewer components still work.

Finally, to fix the problems reported in issue 14003, regardless of the code-path we now also enforce that the DOM elements found were actually created by the AnnotationLayer code.
With these changes we'll thus be able to update form elements on all visible pages just as before, but we'll additionally update the AnnotationStorage for not-yet-rendered elements thus fixing a pre-existing bug.",web/annotation_layer_builder.js,https://github.com/mozilla/pdf.js/commit/6cba5509f26ede9986cbc4c100b037d3347d7c91,"  render(viewport, intent = ""display"") {

    return Promise.all([

      this.pdfPage.getAnnotations({ intent }),

      this._hasJSActionsPromise,

    ]).then(([annotations, hasJSActions = false]) => {

      if (this._cancelled || annotations.length === 0) {

        return;

      }

      const parameters = {

        viewport: viewport.clone({ dontFlip: true }),

        div: this.div,

        annotations,

        page: this.pdfPage,

        imageResourcesPath: this.imageResourcesPath,

        renderForms: this.renderForms,

        linkService: this.linkService,

        downloadManager: this.downloadManager,

        annotationStorage: this.annotationStorage,

        enableScripting: this.enableScripting,

        hasJSActions,

        mouseState: this._mouseState,

      };

      if (this.div) {

        // If an annotationLayer already exists, refresh its children's

        // transformation matrices.

        AnnotationLayer.update(parameters);

      } else {

        // Create an annotation layer div and render the annotations

        // if there is at least one annotation.

        this.div = document.createElement(""div"");

        this.div.className = ""annotationLayer"";

        this.pageDiv.appendChild(this.div);

        parameters.div = this.div;

        AnnotationLayer.render(parameters);

        this.l10n.translate(this.div);

      }

    });
","  async render(viewport, intent = ""display"") {

    const [annotations, hasJSActions = false, fieldObjects = null] =

      await Promise.all([

        this.pdfPage.getAnnotations({ intent }),

        this._hasJSActionsPromise,

        this._fieldObjectsPromise,

      ]);

    if (this._cancelled || annotations.length === 0) {

      return;

    }

    const parameters = {

      viewport: viewport.clone({ dontFlip: true }),

      div: this.div,

      annotations,

      page: this.pdfPage,

      imageResourcesPath: this.imageResourcesPath,

      renderForms: this.renderForms,

      linkService: this.linkService,

      downloadManager: this.downloadManager,

      annotationStorage: this.annotationStorage,

      enableScripting: this.enableScripting,

      hasJSActions,

      fieldObjects,

      mouseState: this._mouseState,

    };

    if (this.div) {

      // If an annotationLayer already exists, refresh its children's

      // transformation matrices.

      AnnotationLayer.update(parameters);

    } else {

      // Create an annotation layer div and render the annotations

      // if there is at least one annotation.

      this.div = document.createElement(""div"");

      this.div.className = ""annotationLayer"";

      this.pageDiv.appendChild(this.div);

      parameters.div = this.div;



      AnnotationLayer.render(parameters);

      this.l10n.translate(this.div);

    }
",2021-09-14 12:06:28+02:00
37d90ec378f2ff74a9e5e150173e00517e63c4b4,Jane-Kotovich,Convert examples/node/pdf2png/pdf2png.js to await/async,examples/node/pdf2png/pdf2png.js,https://github.com/mozilla/pdf.js/commit/37d90ec378f2ff74a9e5e150173e00517e63c4b4,"loadingTask.promise

  .then(function (pdfDocument) {

    console.log(""# PDF document loaded."");

    pdfDocument.getPage(1).then(function (page) {

      // Render the page on a Node canvas with 100% scale.

      const viewport = page.getViewport({ scale: 1.0 });

      const canvasFactory = new NodeCanvasFactory();

      const canvasAndContext = canvasFactory.create(

        viewport.width,

        viewport.height

      );

      const renderContext = {

        canvasContext: canvasAndContext.context,

        viewport,

        canvasFactory,

      };

      const renderTask = page.render(renderContext);

      renderTask.promise.then(function () {

        // Convert the canvas to an image buffer.

        const image = canvasAndContext.canvas.toBuffer();

        fs.writeFile(""output.png"", image, function (error) {

          if (error) {

            console.error(""Error: "" + error);

          } else {

            console.log(

              ""Finished converting first page of PDF file to a PNG image.""

            );

          }

        });

      });

  })

  .catch(function (reason) {

  });
","(async function () {

  try {

    const pdfDocument = await loadingTask.promise;

    console.log(""# PDF document loaded."");

    const page = await pdfDocument.getPage(1);

    // Render the page on a Node canvas with 100% scale.

    const viewport = page.getViewport({ scale: 1.0 });

    const canvasFactory = new NodeCanvasFactory();

    const canvasAndContext = canvasFactory.create(

      viewport.width,

      viewport.height

    );

    const renderContext = {

      canvasContext: canvasAndContext.context,

      viewport,

      canvasFactory,

    };

    const renderTask = page.render(renderContext);

    await renderTask.promise;

    // Convert the canvas to an image buffer.

    const image = canvasAndContext.canvas.toBuffer();

    fs.writeFile(""output.png"", image, function (error) {

      if (error) {

        console.error(""Error: "" + error);

      } else {

        console.log(

          ""Finished converting first page of PDF file to a PNG image.""

        );

      }

  } catch (reason) {

  }

})();
",2021-10-14 13:26:10+10:00
fdf08ef3d26d7d1446ddb019668b6a71373163fc,adenicole,"converted examples/text-only/pdf2svg.js to await/async

Updated promise call back with await/async method",examples/text-only/pdf2svg.js,https://github.com/mozilla/pdf.js/commit/fdf08ef3d26d7d1446ddb019668b6a71373163fc,"function pageLoaded() {

  loadingTask.promise.then(function (pdfDocument) {

    pdfDocument.getPage(PAGE_NUMBER).then(function (page) {

      const viewport = page.getViewport({ scale: PAGE_SCALE });

      page.getTextContent().then(function (textContent) {

        // building SVG and adding that to the DOM

        const svg = buildSVG(viewport, textContent);

        document.getElementById(""pageContainer"").appendChild(svg);

      });

    });

  });
","async function pageLoaded() {

  const pdfDocument = await loadingTask.promise;

  const page = await pdfDocument.getPage(PAGE_NUMBER);

  const viewport = page.getViewport({ scale: PAGE_SCALE });

  const textContent = await page.getTextContent();

  // building SVG and adding that to the DOM

  const svg = buildSVG(viewport, textContent);

  document.getElementById(""pageContainer"").appendChild(svg);
",2021-10-14 14:44:00+01:00
0643ccb68b8c12e6734eaa02c9a2b11859096188,"Benson Imoh,ST",Convert examples/node/pdf2svg.js to await/async #14125,examples/node/pdf2svg.js,https://github.com/mozilla/pdf.js/commit/0643ccb68b8c12e6734eaa02c9a2b11859096188,"// Will be using promises to load document, pages and misc data instead of

// callback.

loadingTask.promise

  .then(function (doc) {

    const numPages = doc.numPages;

    console.log(""# Document Loaded"");

    console.log(""Number of Pages: "" + numPages);

    console.log();

    let lastPromise = Promise.resolve(); // will be used to chain promises

    const loadPage = function (pageNum) {

      return doc.getPage(pageNum).then(function (page) {

        console.log(""# Page "" + pageNum);

        const viewport = page.getViewport({ scale: 1.0 });

        console.log(""Size: "" + viewport.width + ""x"" + viewport.height);

        console.log();

        return page.getOperatorList().then(function (opList) {

          const svgGfx = new pdfjsLib.SVGGraphics(page.commonObjs, page.objs);

          svgGfx.embedFonts = true;

          return svgGfx.getSVG(opList, viewport).then(function (svg) {

            return writeSvgToFile(svg, getFilePathForPage(pageNum)).then(

              function () {

                console.log(""Page: "" + pageNum);

              },

              function (err) {

                console.log(""Error: "" + err);

              }

            );

          });

        });

      });

    };



    for (let i = 1; i <= numPages; i++) {

      lastPromise = lastPromise.then(loadPage.bind(null, i));

    }

    return lastPromise;

  })

  .then(

    function () {

      console.log(""# End of Document"");

    },

    function (err) {

      console.error(""Error: "" + err);

  );
","// Will be using async/await to load document, pages and misc data.

(async function () {

  const doc = await loadingTask.promise;

  const numPages = doc.numPages;

  console.log(""# Document Loaded"");

  console.log(`Number of Pages: ${numPages}`);

  console.log();

  for (let pageNum = 1; pageNum <= numPages; pageNum++) {

    try {

      const page = await doc.getPage(pageNum);

      console.log(`# Page ${pageNum}`);

      const viewport = page.getViewport({ scale: 1.0 });

      console.log(`Size: ${viewport.width}x${viewport.height}`);

      console.log();

      const opList = await page.getOperatorList();

      const svgGfx = new pdfjsLib.SVGGraphics(page.commonObjs, page.objs);

      svgGfx.embedFonts = true;

      const svg = await svgGfx.getSVG(opList, viewport);

      await writeSvgToFile(svg, getFilePathForPage(pageNum));

    } catch (err) {

      console.log(`Error: ${err}`);

  }

  console.log(""# End of Document"");

})();
",2021-10-18 19:22:06+01:00
4c463c6099cea8e195203278c9be7ac656192e64,PinRathod,Converted simpleviewer.js to await/async,examples/components/simpleviewer.js,https://github.com/mozilla/pdf.js/commit/4c463c6099cea8e195203278c9be7ac656192e64,"loadingTask.promise.then(function (pdfDocument) {

});
","(async function () {

  const pdfDocument = await loadingTask.promise;

})();
",2021-10-24 19:36:25+05:30
0ebac67a9fedbc655500f29285d1632a8bb09a70,Jonas Jenwald,"Remove the `{BaseViewer, PDFThumbnailViewer}._pagesRequests` caches

In the `BaseViewer` this cache is mostly relevant in the `disableAutoFetch = true` mode, since the pages are being initialized *lazily* in that case.
In the `PDFThumbnailViewer` this cache is mostly used for thumbnails that are actually being rendered, as opposed to those created directly from the ""regular"" pages.

Please note that I'm not suggesting that we remove these caches because they're only used in some situations, but rather because they're for all intents and purposes actually *redundant*. In the API itself, we're already caching both the page-promises and the actual pages themselves on the `WorkerTransport`-instance.
Hence these viewer-caches aren't really necessary in practice, and adds what to me mostly seems like an unnecessary level of indirection.[1]

Given that the viewer now relies on caching in the API itself, this patch also adds a new unit-test to ensure that page-caching works (and keep working) as expected.

---
[1] In the `WorkerTransport.getPage`-method the parameter is being validated on every call, but that's hardly enough code to warrant keeping the ""duplicate"" caches in the viewer in my opinion.",web/base_viewer.js,https://github.com/mozilla/pdf.js/commit/0ebac67a9fedbc655500f29285d1632a8bb09a70,"   * @returns {Promise} Returns a promise containing a {PDFPageProxy} object.

   * @private

  _ensurePdfPageLoaded(pageView) {

      return Promise.resolve(pageView.pdfPage);

    if (this._pagesRequests.has(pageView)) {

      return this._pagesRequests.get(pageView);

    const promise = this.pdfDocument

      .getPage(pageView.id)

      .then(pdfPage => {

        if (!pageView.pdfPage) {

          pageView.setPdfPage(pdfPage);

        }

        this._pagesRequests.delete(pageView);

        return pdfPage;

      })

      .catch(reason => {

        console.error(""Unable to get page for page view"", reason);

        // Page error -- there is nothing that can be done.

        this._pagesRequests.delete(pageView);

      });

    this._pagesRequests.set(pageView, promise);

    return promise;
","   * @returns {Promise<PDFPageProxy | null>}

  async #ensurePdfPageLoaded(pageView) {

      return pageView.pdfPage;

    try {

      const pdfPage = await this.pdfDocument.getPage(pageView.id);

      if (!pageView.pdfPage) {

        pageView.setPdfPage(pdfPage);

      }

      return pdfPage;

    } catch (reason) {

      console.error(""Unable to get page for page view"", reason);

      return null; // Page error -- there is nothing that can be done.
",2021-11-20 18:24:12+01:00
0ebac67a9fedbc655500f29285d1632a8bb09a70,Jonas Jenwald,"Remove the `{BaseViewer, PDFThumbnailViewer}._pagesRequests` caches

In the `BaseViewer` this cache is mostly relevant in the `disableAutoFetch = true` mode, since the pages are being initialized *lazily* in that case.
In the `PDFThumbnailViewer` this cache is mostly used for thumbnails that are actually being rendered, as opposed to those created directly from the ""regular"" pages.

Please note that I'm not suggesting that we remove these caches because they're only used in some situations, but rather because they're for all intents and purposes actually *redundant*. In the API itself, we're already caching both the page-promises and the actual pages themselves on the `WorkerTransport`-instance.
Hence these viewer-caches aren't really necessary in practice, and adds what to me mostly seems like an unnecessary level of indirection.[1]

Given that the viewer now relies on caching in the API itself, this patch also adds a new unit-test to ensure that page-caching works (and keep working) as expected.

---
[1] In the `WorkerTransport.getPage`-method the parameter is being validated on every call, but that's hardly enough code to warrant keeping the ""duplicate"" caches in the viewer in my opinion.",web/pdf_thumbnail_viewer.js,https://github.com/mozilla/pdf.js/commit/0ebac67a9fedbc655500f29285d1632a8bb09a70,"   * @returns {PDFPage}

   * @private

  _ensurePdfPageLoaded(thumbView) {

      return Promise.resolve(thumbView.pdfPage);

    if (this._pagesRequests.has(thumbView)) {

      return this._pagesRequests.get(thumbView);

    const promise = this.pdfDocument

      .getPage(thumbView.id)

      .then(pdfPage => {

        if (!thumbView.pdfPage) {

          thumbView.setPdfPage(pdfPage);

        }

        this._pagesRequests.delete(thumbView);

        return pdfPage;

      })

      .catch(reason => {

        console.error(""Unable to get page for thumb view"", reason);

        // Page error -- there is nothing that can be done.

        this._pagesRequests.delete(thumbView);

      });

    this._pagesRequests.set(thumbView, promise);

    return promise;
","   * @returns {Promise<PDFPageProxy | null>}

  async #ensurePdfPageLoaded(thumbView) {

      return thumbView.pdfPage;

    try {

      const pdfPage = await this.pdfDocument.getPage(thumbView.id);

      if (!thumbView.pdfPage) {

        thumbView.setPdfPage(pdfPage);

      }

      return pdfPage;

    } catch (reason) {

      console.error(""Unable to get page for thumb view"", reason);

      return null; // Page error -- there is nothing that can be done.
",2021-11-20 18:24:12+01:00
711fbe13763b208ee335c9fdff6c7c8ca27a293f,Sai Kiran Mukka,Convert examples/components/pageviewer.js to await/async (issue 14127),examples/components/pageviewer.js,https://github.com/mozilla/pdf.js/commit/711fbe13763b208ee335c9fdff6c7c8ca27a293f,"loadingTask.promise.then(function (pdfDocument) {

  return pdfDocument.getPage(PAGE_TO_VIEW).then(function (pdfPage) {

    // Creating the page view with default parameters.

    const pdfPageView = new pdfjsViewer.PDFPageView({

      container,

      id: PAGE_TO_VIEW,

      scale: SCALE,

      defaultViewport: pdfPage.getViewport({ scale: SCALE }),

      eventBus,

      // We can enable text/annotation/xfa/struct-layers, as needed.

      textLayerFactory: !pdfDocument.isPureXfa

        ? new pdfjsViewer.DefaultTextLayerFactory()

        : null,

      annotationLayerFactory: new pdfjsViewer.DefaultAnnotationLayerFactory(),

      xfaLayerFactory: pdfDocument.isPureXfa

        ? new pdfjsViewer.DefaultXfaLayerFactory()

        : null,

      structTreeLayerFactory: new pdfjsViewer.DefaultStructTreeLayerFactory(),

    });

    // Associate the actual page with the view, and draw it.

    pdfPageView.setPdfPage(pdfPage);

    return pdfPageView.draw();

});
","(async function () {

  const pdfDocument = await loadingTask.promise;

  const pdfPage = await pdfDocument.getPage(PAGE_TO_VIEW);

  // Creating the page view with default parameters.

  const pdfPageView = new pdfjsViewer.PDFPageView({

    container,

    id: PAGE_TO_VIEW,

    scale: SCALE,

    defaultViewport: pdfPage.getViewport({ scale: SCALE }),

    eventBus,

    // We can enable text/annotation/xfa/struct-layers, as needed.

    textLayerFactory: !pdfDocument.isPureXfa

      ? new pdfjsViewer.DefaultTextLayerFactory()

      : null,

    annotationLayerFactory: new pdfjsViewer.DefaultAnnotationLayerFactory(),

    xfaLayerFactory: pdfDocument.isPureXfa

      ? new pdfjsViewer.DefaultXfaLayerFactory()

      : null,

    structTreeLayerFactory: new pdfjsViewer.DefaultStructTreeLayerFactory(),

  // Associate the actual page with the view, and draw it.

  pdfPageView.setPdfPage(pdfPage);

  return pdfPageView.draw();

})();
",2021-11-24 13:25:36+05:30
4c56214ab48dc2b3b379c88ffd3952961526152a,Jonas Jenwald,"Convert `PDFDocument._getLinearizationPage` to an async method

This, ever so slightly, simplifies the code and reduces overall indentation.",src/core/document.js,https://github.com/mozilla/pdf.js/commit/4c56214ab48dc2b3b379c88ffd3952961526152a,"    return this.xref

      .fetchAsync(ref)

      .then(obj => {

        // Ensure that the object that was found is actually a Page dictionary.

        if (

          isDict(obj, ""Page"") ||

          (isDict(obj) && !obj.has(""Type"") && obj.has(""Contents""))

        ) {

          if (ref && !catalog.pageKidsCountCache.has(ref)) {

            catalog.pageKidsCountCache.put(ref, 1); // Cache the Page reference.

          }

          return [obj, ref];

        throw new FormatError(

          ""The Linearization dictionary doesn't point "" +

            ""to a valid Page dictionary.""

        );

      })

      .catch(reason => {

        info(reason);

        return catalog.getPageDict(pageIndex);

      });
","    try {

      const obj = await this.xref.fetchAsync(ref);

      // Ensure that the object that was found is actually a Page dictionary.

      if (

        isDict(obj, ""Page"") ||

        (isDict(obj) && !obj.has(""Type"") && obj.has(""Contents""))

      ) {

        if (ref && !catalog.pageKidsCountCache.has(ref)) {

          catalog.pageKidsCountCache.put(ref, 1); // Cache the Page reference.

        return [obj, ref];

      }

      throw new FormatError(

        ""The Linearization dictionary doesn't point to a valid Page dictionary.""

      );

    } catch (reason) {

      info(reason);

      return catalog.getPageDict(pageIndex);

    }
",2021-11-26 19:57:47+01:00
5fd4276dcf7d5d9acc3afd91f67bb0de9fe3e81f,Tim van der Meij,"Use async/await in the rasterization classes in `test/driver.js`

This is achieved by letting the `writeSVG` function return a promise so
we don't need callback passing anymore.",test/driver.js,https://github.com/mozilla/pdf.js/commit/5fd4276dcf7d5d9acc3afd91f67bb0de9fe3e81f,"  function rasterizeTextLayer(

    return new Promise(function (resolve, reject) {
","  async function rasterizeTextLayer(

    try {
",2021-12-05 14:04:23+01:00
b513c64d9da6cf050c1b5d3b0500e367b668789e,Jonas Jenwald,"[api-minor] Convert `Catalog.getPageDict` to an asynchronous method

Besides converting `Catalog.getPageDict` to an `async` method, thus simplifying the code, this patch also allows us to pro-actively fix a existing issue.
Note how we're looking up References in such a way that `MissingDataException`s won't cause trouble, however it's *technically possible* that the entries (i.e. /Count, /Kids, and /Type) in a /Pages Dictionary could actually be indirect objects as well. In the existing code this could lead to *some*, or even all, pages failing to load/render as intended.
In practice that doesn't *appear* to happen in real-world PDF documents, but given all the weird things that PDF software do I'd prefer to fix this pro-actively (rather than waiting for a bug report).
With `Catalog.getPageDict` being `async` this is now really simple to address, however I didn't want to introduce a bunch more *unconditional* asynchronicity in this method if it could be avoided (since that could slow things down). Hence we'll *synchronously* lookup the *raw* data in a /Pages Dictionary, and only fallback to asynchronous data lookup when a Reference was encountered.

In addition to the above, this patch also makes the following notable changes:
 - Let `Catalog.getPageDict` *consistently* reject with the actual error, regardless of what data we're fetching. Previously we'd ""swallow"" the actual errors except when looking up Dictionary entries, which is inconsistent and thus seem unfortunate. As can be seen from the updated unit-tests this change is API-observable, hence why the patch is tagged `[api-minor]`.

 - Improve the consistency of the Dictionary /Type-checks in both the `Catalog.getPageDict` and `Catalog.getAllPageDicts` methods.
   In `Catalog.getPageDict` there's a fallback code-path where we're *incorrectly* checking the /Page Dictionary for a /Contents-entry, which is wrong since a /Page Dictionary doesn't need to have a /Contents-entry in order to be valid.
   For consistency the `Catalog.getAllPageDicts` method is also updated to handle errors in the /Type-lookup correctly.

 - Reduce the `PagesCountLimit.PAUSE_EAGER_PAGE_INIT` viewer constant, to further improve loading/rendering performance of the *second* page during initialization of very long documents; PR 14359 follow-up.",src/core/catalog.js,https://github.com/mozilla/pdf.js/commit/b513c64d9da6cf050c1b5d3b0500e367b668789e,"    function next() {

      while (nodesToVisit.length) {

        const currentNode = nodesToVisit.pop();

        if (currentNode instanceof Ref) {

          const count = pageKidsCountCache.get(currentNode);

          // Skip nodes where the page can't be.

          if (count >= 0 && currentPageIndex + count <= pageIndex) {

            currentPageIndex += count;

            continue;

          }

          // Prevent circular references in the /Pages tree.

          if (visitedNodes.has(currentNode)) {

            capability.reject(

              new FormatError(""Pages tree contains circular reference."")

            );

            return;

          }

          visitedNodes.put(currentNode);



          xref.fetchAsync(currentNode).then(function (obj) {

            if (isDict(obj, ""Page"") || (isDict(obj) && !obj.has(""Kids""))) {

              // Cache the Page reference, since it can *greatly* improve

              // performance by reducing redundant lookups in long documents

              // where all nodes are found at *one* level of the tree.

              if (currentNode && !pageKidsCountCache.has(currentNode)) {

                pageKidsCountCache.put(currentNode, 1);

              }



              if (pageIndex === currentPageIndex) {

                capability.resolve([obj, currentNode]);

              } else {

                currentPageIndex++;

                next();

              }

              return;

            }

            nodesToVisit.push(obj);

            next();

          }, capability.reject);

          return;

        }



        // Must be a child page dictionary.

        if (!(currentNode instanceof Dict)) {

          capability.reject(

            new FormatError(

              ""Page dictionary kid reference points to wrong type of object.""

            )

          );

          return;

        }



        let count;

        try {

          count = currentNode.get(""Count"");

        } catch (ex) {

          if (ex instanceof MissingDataException) {

            throw ex;

          }

        if (Number.isInteger(count) && count >= 0) {

          // Cache the Kids count, since it can reduce redundant lookups in

          // documents where all nodes are found at *one* level of the tree.

          const objId = currentNode.objId;

          if (objId && !pageKidsCountCache.has(objId)) {

            pageKidsCountCache.put(objId, count);

          }

          // Skip nodes where the page can't be.

          if (currentPageIndex + count <= pageIndex) {

            currentPageIndex += count;

            continue;

          }

        let kids;

        try {

          kids = currentNode.get(""Kids"");

        } catch (ex) {

          if (ex instanceof MissingDataException) {

            throw ex;

        }

        if (!Array.isArray(kids)) {

          // Prevent errors in corrupt PDF documents that violate the

          // specification by *inlining* Page dicts directly in the Kids

          // array, rather than using indirect objects (fixes issue9540.pdf).

          let type;

          try {

            type = currentNode.get(""Type"");

          } catch (ex) {

            if (ex instanceof MissingDataException) {

              throw ex;

          }

          if (

            isName(type, ""Page"") ||

            (!currentNode.has(""Type"") && currentNode.has(""Contents""))

          ) {

              capability.resolve([currentNode, null]);

              return;

          capability.reject(

            new FormatError(""Page dictionary kids object is not an array."")

          );

          return;

        // Always check all `Kids` nodes, to avoid getting stuck in an empty

        // node further down in the tree (see issue5644.pdf, issue8088.pdf),

        // and to ensure that we actually find the correct `Page` dict.

        for (let last = kids.length - 1; last >= 0; last--) {

          nodesToVisit.push(kids[last]);

      capability.reject(new Error(`Page index ${pageIndex} not found.`));

    next();

    return capability.promise;
","    while (nodesToVisit.length) {

      const currentNode = nodesToVisit.pop();

      if (currentNode instanceof Ref) {

        const count = pageKidsCountCache.get(currentNode);

        // Skip nodes where the page can't be.

        if (count >= 0 && currentPageIndex + count <= pageIndex) {

          currentPageIndex += count;

          continue;

        // Prevent circular references in the /Pages tree.

        if (visitedNodes.has(currentNode)) {

          throw new FormatError(""Pages tree contains circular reference."");

        visitedNodes.put(currentNode);

        const obj = await xref.fetchAsync(currentNode);

        if (obj instanceof Dict) {

          let type = obj.getRaw(""Type"");

          if (type instanceof Ref) {

            type = await xref.fetchAsync(type);

          if (isName(type, ""Page"") || !obj.has(""Kids"")) {

            // Cache the Page reference, since it can *greatly* improve

            // performance by reducing redundant lookups in long documents

            // where all nodes are found at *one* level of the tree.

            if (currentNode && !pageKidsCountCache.has(currentNode)) {

              pageKidsCountCache.put(currentNode, 1);



              return [obj, currentNode];

        }

        nodesToVisit.push(obj);

        continue;

      }

      // Must be a child page dictionary.

      if (!(currentNode instanceof Dict)) {

        throw new FormatError(

          ""Page dictionary kid reference points to wrong type of object.""

        );

      }

      const { objId } = currentNode;



      let count = currentNode.getRaw(""Count"");

      if (count instanceof Ref) {

        count = await xref.fetchAsync(count);

      }

      if (Number.isInteger(count) && count >= 0) {

        // Cache the Kids count, since it can reduce redundant lookups in

        // documents where all nodes are found at *one* level of the tree.

        if (objId && !pageKidsCountCache.has(objId)) {

          pageKidsCountCache.put(objId, count);

        // Skip nodes where the page can't be.

        if (currentPageIndex + count <= pageIndex) {

          currentPageIndex += count;

          continue;

        }

      }



      let kids = currentNode.getRaw(""Kids"");

      if (kids instanceof Ref) {

        kids = await xref.fetchAsync(kids);

      }

      if (!Array.isArray(kids)) {

        // Prevent errors in corrupt PDF documents that violate the

        // specification by *inlining* Page dicts directly in the Kids

        // array, rather than using indirect objects (fixes issue9540.pdf).

        let type = currentNode.getRaw(""Type"");

        if (type instanceof Ref) {

          type = await xref.fetchAsync(type);

        }

        if (isName(type, ""Page"") || !currentNode.has(""Kids"")) {

          if (currentPageIndex === pageIndex) {

            return [currentNode, null];

          }

          currentPageIndex++;

          continue;



        throw new FormatError(""Page dictionary kids object is not an array."");

      }



      // Always check all `Kids` nodes, to avoid getting stuck in an empty

      // node further down in the tree (see issue5644.pdf, issue8088.pdf),

      // and to ensure that we actually find the correct `Page` dict.

      for (let last = kids.length - 1; last >= 0; last--) {

        nodesToVisit.push(kids[last]);



    throw new Error(`Page index ${pageIndex} not found.`);
",2021-12-24 13:46:35+01:00
996396a9144ac9deb3d7bcdc82ba4363a31e2c25,Jonas Jenwald,"Change `PasswordPrompt.close` to an `async` method

This is consistent with the `open` method, and it actually *ever so slightly* reduces the size of the file.",web/password_prompt.js,https://github.com/mozilla/pdf.js/commit/996396a9144ac9deb3d7bcdc82ba4363a31e2c25,"  close() {

    this.overlayManager.close(this.overlayName).then(() => {

      this.input.value = """";

    });
","  async close() {

    await this.overlayManager.close(this.overlayName);

    this.input.value = """";
",2022-02-14 12:13:30+01:00
c0736647f9c09fa3d582bd7bc635dd854164ea07,Jonas Jenwald,"Add general iteration support in the `RefSet` and `RefSetCache` classes

This patch removes the existing `forEach` methods, in favor of making the classes properly iterable instead. Given that the classes are using a `Set` respectively a `Map` internally, implementing this is very easy/efficient and allows us to simplify some existing code.",src/core/catalog.js,https://github.com/mozilla/pdf.js/commit/c0736647f9c09fa3d582bd7bc635dd854164ea07,"  fontFallback(id, handler) {

    const promises = [];

    this.fontCache.forEach(function (promise) {

      promises.push(promise);

    });

    return Promise.all(promises).then(translatedFonts => {

      for (const translatedFont of translatedFonts) {

        if (translatedFont.loadedName === id) {

          translatedFont.fallback(handler);

          return;

        }

    });

  cleanup(manuallyTriggered = false) {

    const promises = [];

    this.fontCache.forEach(function (promise) {

      promises.push(promise);

    });

    return Promise.all(promises).then(translatedFonts => {

      for (const { dict } of translatedFonts) {

        delete dict.cacheKey;

      }

      this.fontCache.clear();

      this.builtInCMapCache.clear();

      this.standardFontDataCache.clear();

    });
","  async fontFallback(id, handler) {

    const translatedFonts = await Promise.all(this.fontCache);

    for (const translatedFont of translatedFonts) {

      if (translatedFont.loadedName === id) {

        translatedFont.fallback(handler);

        return;

    }

  async cleanup(manuallyTriggered = false) {

    const translatedFonts = await Promise.all(this.fontCache);

    for (const { dict } of translatedFonts) {

      delete dict.cacheKey;

    }

    this.fontCache.clear();

    this.builtInCMapCache.clear();

    this.standardFontDataCache.clear();
",2022-03-18 14:18:03+01:00
c48dc251e07482973ab14036d971cb00a241571a,Jonas Jenwald,"Add (basic) support for Optional Content in Annotations

Given that Annotations can also have an `OC`-entry, we need to take that into account when generating their operatorLists.

Note that in order to simplify the patch the `getOperatorList`-methods, for the Annotation-classes, were converted to be `async`.",src/core/annotation.js,https://github.com/mozilla/pdf.js/commit/c48dc251e07482973ab14036d971cb00a241571a,"    return resourcesPromise.then(resources => {

      const opList = new OperatorList();

      opList.addOp(OPS.beginAnnotation, [

        data.id,

        data.rect,

        transform,

        matrix,

        isUsingOwnCanvas,

      ]);

      return evaluator

        .getOperatorList({

          stream: appearance,

          task,

          resources,

          operatorList: opList,

          fallbackFontDict: this._fallbackFontDict,

        })

        .then(() => {

          opList.addOp(OPS.endAnnotation, []);

          this.reset();

          return opList;

        });
","    const opList = new OperatorList();

    let optionalContent;

    if (this.oc) {

      optionalContent = await evaluator.parseMarkedContentProps(

        this.oc,

        /* resources = */ null

      );

    }

    if (optionalContent !== undefined) {

      opList.addOp(OPS.beginMarkedContentProps, [""OC"", optionalContent]);

    }



    opList.addOp(OPS.beginAnnotation, [

      data.id,

      data.rect,

      transform,

      matrix,

      isUsingOwnCanvas,

    ]);



    await evaluator.getOperatorList({

      stream: appearance,

      task,

      resources,

      operatorList: opList,

      fallbackFontDict: this._fallbackFontDict,

    opList.addOp(OPS.endAnnotation, []);



    if (optionalContent !== undefined) {

      opList.addOp(OPS.endMarkedContent, []);

    }

    this.reset();

    return opList;
",2022-06-24 14:39:08+02:00
c48dc251e07482973ab14036d971cb00a241571a,Jonas Jenwald,"Add (basic) support for Optional Content in Annotations

Given that Annotations can also have an `OC`-entry, we need to take that into account when generating their operatorLists.

Note that in order to simplify the patch the `getOperatorList`-methods, for the Annotation-classes, were converted to be `async`.",src/core/annotation.js,https://github.com/mozilla/pdf.js/commit/c48dc251e07482973ab14036d971cb00a241571a,"    return this._getAppearance(evaluator, task, annotationStorage).then(

      content => {

        if (this.appearance && content === null) {

          return super.getOperatorList(

            evaluator,

            task,

            intent,

            renderForms,

            annotationStorage

          );

        }

        const operatorList = new OperatorList();

        // Even if there is an appearance stream, ignore it. This is the

        // behaviour used by Adobe Reader.

        if (!this._defaultAppearance || content === null) {

          return operatorList;

        }

        const matrix = [1, 0, 0, 1, 0, 0];

        const bbox = [

          0,

          0,

          this.data.rect[2] - this.data.rect[0],

          this.data.rect[3] - this.data.rect[1],

        ];



        const transform = getTransformMatrix(this.data.rect, bbox, matrix);

        operatorList.addOp(OPS.beginAnnotation, [

          this.data.id,

          this.data.rect,

          transform,

          this.getRotationMatrix(annotationStorage),

        ]);



        const stream = new StringStream(content);

        return evaluator

          .getOperatorList({

            stream,

            task,

            resources: this._fieldResources.mergedResources,

            operatorList,

          })

          .then(function () {

            operatorList.addOp(OPS.endAnnotation, []);

            return operatorList;

          });

      }

    );
","    const content = await this._getAppearance(

      evaluator,

      task,

      annotationStorage

    );

    if (this.appearance && content === null) {

      return super.getOperatorList(

        evaluator,

        task,

        intent,

        renderForms,

        annotationStorage

      );

    }

    const operatorList = new OperatorList();

    // Even if there is an appearance stream, ignore it. This is the

    // behaviour used by Adobe Reader.

    if (!this._defaultAppearance || content === null) {

      return operatorList;

    }

    const matrix = [1, 0, 0, 1, 0, 0];

    const bbox = [

      0,

      0,

      this.data.rect[2] - this.data.rect[0],

      this.data.rect[3] - this.data.rect[1],

    ];

    const transform = getTransformMatrix(this.data.rect, bbox, matrix);



    let optionalContent;

    if (this.oc) {

      optionalContent = await evaluator.parseMarkedContentProps(

        this.oc,

        /* resources = */ null

      );

    }

    if (optionalContent !== undefined) {

      operatorList.addOp(OPS.beginMarkedContentProps, [""OC"", optionalContent]);

    }



    operatorList.addOp(OPS.beginAnnotation, [

      this.data.id,

      this.data.rect,

      transform,

      this.getRotationMatrix(annotationStorage),

    ]);



    const stream = new StringStream(content);

    await evaluator.getOperatorList({

      stream,

      task,

      resources: this._fieldResources.mergedResources,

      operatorList,

    });

    operatorList.addOp(OPS.endAnnotation, []);



    if (optionalContent !== undefined) {

      operatorList.addOp(OPS.endMarkedContent, []);

    }

    return operatorList;
",2022-06-24 14:39:08+02:00
31155740c35f5b270ff6222682b013f53351d427,Calixte Denizet,"[Annotation] Add a div containing the text of a FreeText annotation (bug 1780375)

An annotation doesn't have to be in the text flow, hence it's likely a bad idea
to insert its text in the text layer. But the text must be visible from a screen
reader point of view so it must somewhere in the DOM.
So with this patch, the text from a FreeText annotation is extracted and added in
a div in its HTML counterpart, and with the patch #15237 the text should be visible
and positioned relatively to the text flow.",src/core/document.js,https://github.com/mozilla/pdf.js/commit/31155740c35f5b270ff6222682b013f53351d427,"  getAnnotationsData(intent) {

    return this._parsedAnnotations.then(function (annotations) {

      const annotationsData = [];



      if (annotations.length === 0) {

        return annotationsData;

      const intentAny = !!(intent & RenderingIntentFlag.ANY),

        intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),

        intentPrint = !!(intent & RenderingIntentFlag.PRINT);

      for (const annotation of annotations) {

        // Get the annotation even if it's hidden because

        // JS can change its display.

        if (

          intentAny ||

          (intentDisplay && annotation.viewable) ||

          (intentPrint && annotation.printable)

        ) {

          annotationsData.push(annotation.data);

      return annotationsData;

    });
","  async getAnnotationsData(handler, task, intent) {

    const annotations = await this._parsedAnnotations;

    if (annotations.length === 0) {

      return [];

    }



    const textContentPromises = [];

    const annotationsData = [];

    let partialEvaluator;



    const intentAny = !!(intent & RenderingIntentFlag.ANY),

      intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),

      intentPrint = !!(intent & RenderingIntentFlag.PRINT);



    for (const annotation of annotations) {

      // Get the annotation even if it's hidden because

      // JS can change its display.

      const isVisible = intentAny || (intentDisplay && annotation.viewable);

      if (isVisible || (intentPrint && annotation.printable)) {

        annotationsData.push(annotation.data);

      if (annotation.hasTextContent && isVisible) {

        if (!partialEvaluator) {

          partialEvaluator = new PartialEvaluator({

            xref: this.xref,

            handler,

            pageIndex: this.pageIndex,

            idFactory: this._localIdFactory,

            fontCache: this.fontCache,

            builtInCMapCache: this.builtInCMapCache,

            standardFontDataCache: this.standardFontDataCache,

            globalImageCache: this.globalImageCache,

            options: this.evaluatorOptions,

          });

        textContentPromises.push(

          annotation

            .extractTextContent(partialEvaluator, task, this.view)

            .catch(function (reason) {

              warn(

                `getAnnotationsData - ignoring textContent during ""${task.name}"" task: ""${reason}"".`

              );

            })

        );

    }



    await Promise.all(textContentPromises);

    return annotationsData;
",2022-08-03 12:03:49+02:00
eed9bf71c5ee16268986a743a992c61bdbcc89da,Calixte Denizet,"Refactor the text layer code in order to avoid to recompute it on each draw

The idea is just to resuse what we got on the first draw.
Now, we only update the scaleX of the different spans and the other values
are dependant of --scale-factor.
Move some properties in the CSS in order to avoid any updates in JS.",web/text_layer_builder.js,https://github.com/mozilla/pdf.js/commit/eed9bf71c5ee16268986a743a992c61bdbcc89da,"    this.textLayerDiv.append(endOfContent);

    this.eventBus.dispatch(""textlayerrendered"", {

      source: this,

      pageNumber: this.pageNumber,

      numTextDivs: this.textDivs.length,

    });

  render() {

    if (!(this.textContent || this.textContentStream) || this.renderingDone) {

    this.cancel();

    this.textDivs.length = 0;

    const textLayerFrag = document.createDocumentFragment();

      container: textLayerFrag,

      viewport: this.viewport,

    this.textLayerRenderTask.promise.then(

      () => {

        this.textLayerDiv.append(textLayerFrag);

        this.#finishRendering();

        this.highlighter?.enable();

        this.accessibilityManager?.enable();

      },

      function (reason) {

        // Cancelled or failed to render text layer; skipping errors.

      }

    );
","    this.div.append(endOfContent);

    this.#bindMouse();

  }



  get numTextDivs() {

    return this.textDivs.length;

  async render(viewport) {

    if (!(this.textContent || this.textContentStream)) {

      throw new Error(

        `Neither ""textContent"" nor ""textContentStream"" specified.`

      );

    }



    const scale = viewport.scale * (globalThis.devicePixelRatio || 1);

    if (this.renderingDone) {

      const { rotation } = viewport;

      const mustRotate = rotation !== this.#rotation;

      const mustRescale = scale !== this.#scale;

      if (mustRotate || mustRescale) {

        this.hide();

        updateTextLayer({

          container: this.div,

          viewport,

          textDivs: this.textDivs,

          textDivProperties: this.textDivProperties,

          isOffscreenCanvasSupported: this.isOffscreenCanvasSupported,

          mustRescale,

          mustRotate,

        });

        this.show();

        this.#scale = scale;

        this.#rotation = rotation;

      }

    this.cancel();

      container: this.div,

      viewport,

      textDivProperties: this.textDivProperties,

      isOffscreenCanvasSupported: this.isOffscreenCanvasSupported,



    await this.textLayerRenderTask.promise;

    this.#finishRendering();

    this.#scale = scale;

    this.accessibilityManager?.enable();

    this.show();

  }



  hide() {

    // We turn off the highlighter in order to avoid to scroll into view an

    // element of the text layer which could be hidden.

    this.highlighter?.disable();

    this.div.hidden = true;

  }



  show() {

    this.div.hidden = false;

    this.highlighter?.enable();
",2022-11-21 17:15:39+01:00
828efd9d000ab868369ac19cbc2ed0f8cc09c92f,Jonas Jenwald,"Change the `XfaLayerBuilder.render` method to be asynchronous

This is consistent with the `render` methods of the other layers, and reduces overall indentation in the method.
Furthermore, don't ""swallow"" errors since the `PDFPageView._renderXfaLayer` method is already able to deal with that.",web/xfa_layer_builder.js,https://github.com/mozilla/pdf.js/commit/828efd9d000ab868369ac19cbc2ed0f8cc09c92f,"      const result = XfaLayer.render(parameters);

      return Promise.resolve(result);

    return this.pdfPage

      .getXfa()

      .then(xfaHtml => {

        if (this._cancelled || !xfaHtml) {

          return { textDivs: [] };

        }

        const parameters = {

          viewport: viewport.clone({ dontFlip: true }),

          div: this.div,

          xfaHtml,

          annotationStorage: this.annotationStorage,

          linkService: this.linkService,

          intent,

        };

        if (this.div) {

          return XfaLayer.update(parameters);

        }

        // Create an xfa layer div and render the form

        this.div = document.createElement(""div"");

        this.pageDiv.append(this.div);

        parameters.div = this.div;

        return XfaLayer.render(parameters);

      })

      .catch(error => {

        console.error(error);

      });
","      return XfaLayer.render(parameters);

    const xfaHtml = await this.pdfPage.getXfa();

    if (this._cancelled || !xfaHtml) {

      return { textDivs: [] };

    }



    const parameters = {

      viewport: viewport.clone({ dontFlip: true }),

      div: this.div,

      xfaHtml,

      annotationStorage: this.annotationStorage,

      linkService: this.linkService,

      intent,

    };

    if (this.div) {

      return XfaLayer.update(parameters);

    }

    // Create an xfa layer div and render the form

    this.div = document.createElement(""div"");

    this.pageDiv.append(this.div);

    parameters.div = this.div;

    return XfaLayer.render(parameters);
",2022-12-11 13:07:44+01:00
32357e3d172a552e0408b3e1ed743e87fe7d5a21,Jonas Jenwald,"Update `rimraf` to version 4

The primary change is that the `rimraf` function now returns a Promise instead of taking a callback; please see https://github.com/isaacs/rimraf#major-changes-from-v3-to-v4",gulpfile.js,https://github.com/mozilla/pdf.js/commit/32357e3d172a552e0408b3e1ed743e87fe7d5a21,"gulp.task(""jsdoc"", function (done) {

  rimraf(JSDOC_BUILD_DIR, function () {

    mkdirp(JSDOC_BUILD_DIR).then(function () {

      const command =

        '""node_modules/.bin/jsdoc"" -d ' +

        JSDOC_BUILD_DIR +

        "" "" +

        JSDOC_FILES.join("" "");

      exec(command, done);

    });

  });
","gulp.task(""jsdoc"", async function (done) {

  await rimraf(JSDOC_BUILD_DIR);

  await mkdirp(JSDOC_BUILD_DIR);



  const command = `""node_modules/.bin/jsdoc"" -d ${JSDOC_BUILD_DIR} ${JSDOC_FILES.join(

    "" ""

  )}`;

  exec(command, done);
",2023-01-15 11:37:53+01:00
df9cce39c09cde3a4fa5f523c1115e83280a163f,Jonas Jenwald,"Slightly reduce asynchronicity when parsing Annotations

Over time the amount of ""document level"" data potentially needed during parsing of Annotations have increased a fair bit, which means that we currently need to ensure that a bunch of data is available for each individual Annotation.
Given that this data is ""constant"" for a PDF document we can instead create (and cache) it lazily, only when needed, *before* starting to parse the Annotations on a page. This way the parsing of individual Annotations should become slightly less asynchronous, which really cannot hurt.

An additional benefit of these changes is that we can reduce the number of parameters that need to be explicitly passed around in the annotation-code, which helps overall readability in my opinion.

One potential drawback of these changes is that the `AnnotationFactory.create` method no longer handles ""everything"" on its own, however given how few call-sites there are I don't think that's too much of a problem.",src/core/annotation.js,https://github.com/mozilla/pdf.js/commit/df9cce39c09cde3a4fa5f523c1115e83280a163f,"   * @param {PDFManager} pdfManager

   * @param {boolean} collectFields

  static create(xref, ref, pdfManager, idFactory, collectFields, pageRef) {

    return Promise.all([

      pdfManager.ensureCatalog(""acroForm""),

      // Only necessary to prevent the `pdfManager.docBaseUrl`-getter, used

      // with certain Annotations, from throwing and thus breaking parsing:

      pdfManager.ensureCatalog(""baseUrl""),

      // Only necessary in the `Catalog.parseDestDictionary`-method,

      // when parsing ""GoToE"" actions:

      pdfManager.ensureCatalog(""attachments""),

      pdfManager.ensureDoc(""xfaDatasets""),

      collectFields ? this._getPageIndex(xref, ref, pdfManager) : -1,

      pageRef ? pdfManager.ensureCatalog(""structTreeRoot"") : null,

    ]).then(

      ([

        acroForm,

        baseUrl,

        attachments,

        xfaDatasets,

        pageIndex,

        structTreeRoot,

      ]) =>

        pdfManager.ensure(this, ""_create"", [

          xref,

          ref,

          pdfManager,

          idFactory,

          acroForm,

          attachments,

          xfaDatasets,

          collectFields,

          pageIndex,

          structTreeRoot,

          pageRef,

        ])

    );
","   * @params {Object} annotationGlobals

   * @param {boolean} [collectFields]

  static async create(

    xref,

    ref,

    annotationGlobals,

    idFactory,

    collectFields,

    pageRef

  ) {

    const pageIndex = collectFields

      ? await this._getPageIndex(xref, ref, annotationGlobals.pdfManager)

      : null;



    return annotationGlobals.pdfManager.ensure(this, ""_create"", [

      xref,

      ref,

      annotationGlobals,

      idFactory,

      pageIndex,

      pageRef,

    ]);
",2023-09-07 14:14:35+02:00
df9cce39c09cde3a4fa5f523c1115e83280a163f,Jonas Jenwald,"Slightly reduce asynchronicity when parsing Annotations

Over time the amount of ""document level"" data potentially needed during parsing of Annotations have increased a fair bit, which means that we currently need to ensure that a bunch of data is available for each individual Annotation.
Given that this data is ""constant"" for a PDF document we can instead create (and cache) it lazily, only when needed, *before* starting to parse the Annotations on a page. This way the parsing of individual Annotations should become slightly less asynchronous, which really cannot hurt.

An additional benefit of these changes is that we can reduce the number of parameters that need to be explicitly passed around in the annotation-code, which helps overall readability in my opinion.

One potential drawback of these changes is that the `AnnotationFactory.create` method no longer handles ""everything"" on its own, however given how few call-sites there are I don't think that's too much of a problem.",src/core/document.js,https://github.com/mozilla/pdf.js/commit/df9cce39c09cde3a4fa5f523c1115e83280a163f,"        return Promise.all(annotationPromises).then(function (annotations) {

          if (annotations.length === 0) {

            return annotations;

          }



          const sortedAnnotations = [];

          let popupAnnotations;

          // Ensure that PopupAnnotations are handled last, since they depend on

          // their parent Annotation in the display layer; fixes issue 11362.

          for (const annotation of annotations) {

            if (!annotation) {

              continue;

            }

            if (annotation instanceof PopupAnnotation) {

              (popupAnnotations ||= []).push(annotation);

              continue;

            }

            sortedAnnotations.push(annotation);

          if (popupAnnotations) {

            sortedAnnotations.push(...popupAnnotations);

          return sortedAnnotations;

        });

    return shadow(this, ""_parsedAnnotations"", parsedAnnotations);
","        const sortedAnnotations = [];

        let popupAnnotations;

        // Ensure that PopupAnnotations are handled last, since they depend on

        // their parent Annotation in the display layer; fixes issue 11362.

        for (const annotation of await Promise.all(annotationPromises)) {

          if (!annotation) {

            continue;

          if (annotation instanceof PopupAnnotation) {

            (popupAnnotations ||= []).push(annotation);

            continue;

          sortedAnnotations.push(annotation);

        }

        if (popupAnnotations) {

          sortedAnnotations.push(...popupAnnotations);

        }

        return sortedAnnotations;

    return shadow(this, ""_parsedAnnotations"", promise);
",2023-09-07 14:14:35+02:00
ff96c413d3efdc3ec08ff6c7596d57b555c1af99,Jonas Jenwald,"Use `await` even more in the ""SaveDocument"" worker-thread handler

Given that the function is already asynchronous we can make use of `await` even more and reduce the amount of indentation a little bit.",src/core/worker.js,https://github.com/mozilla/pdf.js/commit/ff96c413d3efdc3ec08ff6c7596d57b555c1af99,"        return Promise.all(promises).then(refs => {

          let newRefs = [];

          let xfaData = null;

          if (isPureXfa) {

            xfaData = refs[0];

            if (!xfaData) {

              return stream.bytes;

            }

          } else {

            newRefs = refs.flat(2);



            if (newRefs.length === 0) {

              // No new refs so just return the initial bytes

              return stream.bytes;

            }

          const needAppearances =

            acroFormRef &&

            acroForm instanceof Dict &&

            newRefs.some(ref => ref.needAppearances);



          const xfa = (acroForm instanceof Dict && acroForm.get(""XFA"")) || null;

          let xfaDatasetsRef = null;

          let hasXfaDatasetsEntry = false;

          if (Array.isArray(xfa)) {

            for (let i = 0, ii = xfa.length; i < ii; i += 2) {

              if (xfa[i] === ""datasets"") {

                xfaDatasetsRef = xfa[i + 1];

                hasXfaDatasetsEntry = true;

              }

            }

            if (xfaDatasetsRef === null) {

              xfaDatasetsRef = xref.getNewTemporaryRef();

            }

          } else if (xfa) {

            // TODO: Support XFA streams.

            warn(""Unsupported XFA type."");

          let newXrefInfo = Object.create(null);

          if (xref.trailer) {

            // Get string info from Info in order to compute fileId.

            const infoObj = Object.create(null);

            const xrefInfo = xref.trailer.get(""Info"") || null;

            if (xrefInfo instanceof Dict) {

              xrefInfo.forEach((key, value) => {

                if (typeof value === ""string"") {

                  infoObj[key] = stringToPDFString(value);

                }

              });

            newXrefInfo = {

              rootRef: xref.trailer.getRaw(""Root"") || null,

              encryptRef: xref.trailer.getRaw(""Encrypt"") || null,

              newRef: xref.getNewTemporaryRef(),

              infoRef: xref.trailer.getRaw(""Info"") || null,

              info: infoObj,

              fileIds: xref.trailer.get(""ID"") || null,

              startXRef: linearization

                ? startXRef

                : xref.lastXRefStreamPos ?? startXRef,

              filename,

            };

          return incrementalUpdate({

            originalData: stream.bytes,

            xrefInfo: newXrefInfo,

            newRefs,

            xref,

            hasXfa: !!xfa,

            xfaDatasetsRef,

            hasXfaDatasetsEntry,

            needAppearances,

            acroFormRef,

            acroForm,

            xfaData,

          }).finally(() => {

            xref.resetNewTemporaryRef();

          });
","        const refs = await Promise.all(promises);

        let newRefs = [];

        let xfaData = null;

        if (isPureXfa) {

          xfaData = refs[0];

          if (!xfaData) {

            return stream.bytes;

        } else {

          newRefs = refs.flat(2);

          if (newRefs.length === 0) {

            // No new refs so just return the initial bytes

            return stream.bytes;

        }

        const needAppearances =

          acroFormRef &&

          acroForm instanceof Dict &&

          newRefs.some(ref => ref.needAppearances);



        const xfa = (acroForm instanceof Dict && acroForm.get(""XFA"")) || null;

        let xfaDatasetsRef = null;

        let hasXfaDatasetsEntry = false;

        if (Array.isArray(xfa)) {

          for (let i = 0, ii = xfa.length; i < ii; i += 2) {

            if (xfa[i] === ""datasets"") {

              xfaDatasetsRef = xfa[i + 1];

              hasXfaDatasetsEntry = true;

          }

          if (xfaDatasetsRef === null) {

            xfaDatasetsRef = xref.getNewTemporaryRef();

          }

        } else if (xfa) {

          // TODO: Support XFA streams.

          warn(""Unsupported XFA type."");

        }

        let newXrefInfo = Object.create(null);

        if (xref.trailer) {

          // Get string info from Info in order to compute fileId.

          const infoObj = Object.create(null);

          const xrefInfo = xref.trailer.get(""Info"") || null;

          if (xrefInfo instanceof Dict) {

            xrefInfo.forEach((key, value) => {

              if (typeof value === ""string"") {

                infoObj[key] = stringToPDFString(value);

              }

            });

          newXrefInfo = {

            rootRef: xref.trailer.getRaw(""Root"") || null,

            encryptRef: xref.trailer.getRaw(""Encrypt"") || null,

            newRef: xref.getNewTemporaryRef(),

            infoRef: xref.trailer.getRaw(""Info"") || null,

            info: infoObj,

            fileIds: xref.trailer.get(""ID"") || null,

            startXRef: linearization

              ? startXRef

              : xref.lastXRefStreamPos ?? startXRef,

            filename,

          };

        }



        return incrementalUpdate({

          originalData: stream.bytes,

          xrefInfo: newXrefInfo,

          newRefs,

          xref,

          hasXfa: !!xfa,

          xfaDatasetsRef,

          hasXfaDatasetsEntry,

          needAppearances,

          acroFormRef,

          acroForm,

          xfaData,

        }).finally(() => {

          xref.resetNewTemporaryRef();
",2023-09-16 13:06:48+02:00
050093c9f519154f26f3d5757ffc7290fd98ba8f,Calixte Denizet,"[Editor] Tweak the save flow in the alt-text dialog

When the user edit an existing alt-text and remove it, we want to be able
to save this state and consequently remove the done state from the
alt-text button.
Remove the button from its parent when the editor is removed: it should
help to save few Kb of memory.",src/display/editor/editor.js,https://github.com/mozilla/pdf.js/commit/050093c9f519154f26f3d5757ffc7290fd98ba8f,"  addAltTextButton() {

    AnnotationEditor._l10nPromise

      .get(""editor_alt_text_button_label"")

      .then(msg => {

        altText.textContent = msg;

        altText.setAttribute(""aria-label"", msg);

      });
","  async addAltTextButton() {

    const msg = await AnnotationEditor._l10nPromise.get(

      ""editor_alt_text_button_label""

    );

    altText.textContent = msg;

    altText.setAttribute(""aria-label"", msg);
",2023-09-22 09:43:19+02:00
fc62eec9017721af1dae51336a1190223ba37008,Jonas Jenwald,"Convert the `handleSetFont` methods, in `src/core/evaluator.js`, to be async",src/core/evaluator.js,https://github.com/mozilla/pdf.js/commit/fc62eec9017721af1dae51336a1190223ba37008,"    return this.loadFont(

    )

      .then(translated => {

        if (!translated.font.isType3Font) {

          return translated;

        }

        return translated

          .loadType3Data(this, resources, task)

          .then(function () {

            // Add the dependencies to the parent operatorList so they are

            // resolved before Type3 operatorLists are executed synchronously.

            operatorList.addDependencies(translated.type3Dependencies);



            return translated;

          })

          .catch(

            reason =>

              new TranslatedFont({

                loadedName: ""g_font_error"",

                font: new ErrorFont(`Type3 font load error: ${reason}`),

                dict: translated.font,

                evaluatorOptions: this.options,

              })

          );

      })

      .then(translated => {

        state.font = translated.font;

        translated.send(this.handler);

        return translated.loadedName;

      });
","    let translated = await this.loadFont(

    );



    if (translated.font.isType3Font) {

      try {

        await translated.loadType3Data(this, resources, task);

        // Add the dependencies to the parent operatorList so they are

        // resolved before Type3 operatorLists are executed synchronously.

        operatorList.addDependencies(translated.type3Dependencies);

      } catch (reason) {

        translated = new TranslatedFont({

          loadedName: ""g_font_error"",

          font: new ErrorFont(`Type3 font load error: ${reason}`),

          dict: translated.font,

          evaluatorOptions: this.options,

        });

      }

    }



    state.font = translated.font;

    translated.send(this.handler);

    return translated.loadedName;
",2024-01-21 17:32:05+01:00
fc62eec9017721af1dae51336a1190223ba37008,Jonas Jenwald,"Convert the `handleSetFont` methods, in `src/core/evaluator.js`, to be async",src/core/evaluator.js,https://github.com/mozilla/pdf.js/commit/fc62eec9017721af1dae51336a1190223ba37008,"    function handleSetFont(fontName, fontRef) {

      return self

        .loadFont(fontName, fontRef, resources)

        .then(function (translated) {

          if (!translated.font.isType3Font) {

            return translated;

          }

          return translated

            .loadType3Data(self, resources, task)

            .catch(function () {

              // Ignore Type3-parsing errors, since we only use `loadType3Data`

              // here to ensure that we'll always obtain a useful /FontBBox.

            })

            .then(function () {

              return translated;

            });

        })

        .then(function (translated) {

          textState.loadedName = translated.loadedName;

          textState.font = translated.font;

          textState.fontMatrix =

            translated.font.fontMatrix || FONT_IDENTITY_MATRIX;

        });
","    async function handleSetFont(fontName, fontRef) {

      const translated = await self.loadFont(fontName, fontRef, resources);



      if (translated.font.isType3Font) {

        try {

          await translated.loadType3Data(self, resources, task);

        } catch {

          // Ignore Type3-parsing errors, since we only use `loadType3Data`

          // here to ensure that we'll always obtain a useful /FontBBox.

        }

      }



      textState.loadedName = translated.loadedName;

      textState.font = translated.font;

      textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
",2024-01-21 17:32:05+01:00
d1bef8cb8660a5da1e250ed4888c3b8f7779bd4a,Jonas Jenwald,Use `await` consistently in the `PartialEvaluator.translateFont` method,src/core/evaluator.js,https://github.com/mozilla/pdf.js/commit/d1bef8cb8660a5da1e250ed4888c3b8f7779bd4a,"        return this.extractDataStructures(dict, dict, properties).then(

          newProperties => {

            if (widths) {

              const glyphWidths = [];

              let j = firstChar;

              for (const width of widths) {

                glyphWidths[j++] = this.xref.fetchIfRef(width);

              }

              newProperties.widths = glyphWidths;

            } else {

              newProperties.widths = this.buildCharCodeToWidth(

                metrics.widths,

                newProperties

              );

            }

            return new Font(baseFontName, file, newProperties);

          }
","

        const newProperties = await this.extractDataStructures(

          dict,

          dict,

          properties

        if (widths) {

          const glyphWidths = [];

          let j = firstChar;

          for (const width of widths) {

            glyphWidths[j++] = this.xref.fetchIfRef(width);

          }

          newProperties.widths = glyphWidths;

        } else {

          newProperties.widths = this.buildCharCodeToWidth(

            metrics.widths,

            newProperties

          );

        }

        return new Font(baseFontName, file, newProperties);
",2024-01-21 17:36:50+01:00
d1bef8cb8660a5da1e250ed4888c3b8f7779bd4a,Jonas Jenwald,Use `await` consistently in the `PartialEvaluator.translateFont` method,src/core/evaluator.js,https://github.com/mozilla/pdf.js/commit/d1bef8cb8660a5da1e250ed4888c3b8f7779bd4a,"    return this.extractDataStructures(dict, baseDict, properties).then(

      newProperties => {

        this.extractWidths(dict, descriptor, newProperties);



        return new Font(fontName.name, fontFile, newProperties);

      }
","    const newProperties = await this.extractDataStructures(

      dict,

      baseDict,

      properties

    this.extractWidths(dict, descriptor, newProperties);



    return new Font(fontName.name, fontFile, newProperties);
",2024-01-21 17:36:50+01:00
1cc83c4fdc614c41cf314296cf0160693c9b60da,Jonas Jenwald,Use `await` consistently in the `PartialEvaluator.buildFormXObject` method,src/core/evaluator.js,https://github.com/mozilla/pdf.js/commit/1cc83c4fdc614c41cf314296cf0160693c9b60da,"    return this.getOperatorList({

    }).then(function () {

      operatorList.addOp(OPS.paintFormXObjectEnd, []);

      if (group) {

        operatorList.addOp(OPS.endGroup, [groupOptions]);

      }

      if (optionalContent !== undefined) {

        operatorList.addOp(OPS.endMarkedContent, []);

      }

    });
","    await this.getOperatorList({

    });

    operatorList.addOp(OPS.paintFormXObjectEnd, []);

    if (group) {

      operatorList.addOp(OPS.endGroup, [groupOptions]);

    }

    if (optionalContent !== undefined) {

      operatorList.addOp(OPS.endMarkedContent, []);

    }
",2024-01-22 12:14:30+01:00
cf0797dfbd7fe1f7dcd9f1d4e60848a3a2a5de19,Jonas Jenwald,Use `await` consistently in the `PartialEvaluator.setGState` method,src/core/evaluator.js,https://github.com/mozilla/pdf.js/commit/cf0797dfbd7fe1f7dcd9f1d4e60848a3a2a5de19,"    return promise.then(function () {

      if (gStateObj.length > 0) {

        operatorList.addOp(OPS.setGState, [gStateObj]);

      }

      if (isSimpleGState) {

        localGStateCache.set(cacheKey, gStateRef, gStateObj);

      }

    });
","    await promise;

    if (gStateObj.length > 0) {

      operatorList.addOp(OPS.setGState, [gStateObj]);

    }



    if (isSimpleGState) {

      localGStateCache.set(cacheKey, gStateRef, gStateObj);

    }
",2024-01-22 12:17:20+01:00
f5c01188dc8fbb586664bf68ef492c26813d5253,Jonas Jenwald,Convert the `PartialEvaluator.extractDataStructures` method to be async,src/core/evaluator.js,https://github.com/mozilla/pdf.js/commit/f5c01188dc8fbb586664bf68ef492c26813d5253,"    return toUnicodePromise

      .then(readToUnicode => {

        properties.toUnicode = readToUnicode;

        return this.buildToUnicode(properties);

      })

      .then(builtToUnicode => {

        properties.toUnicode = builtToUnicode;

        if (cidToGidBytes) {

          properties.cidToGidMap = this.readCidToGidMap(

            cidToGidBytes,

            builtToUnicode

          );

        }

        return properties;

      });
","

    properties.toUnicode = await toUnicodePromise;



    const builtToUnicode = await this.buildToUnicode(properties);

    properties.toUnicode = builtToUnicode;



    if (cidToGidBytes) {

      properties.cidToGidMap = this.readCidToGidMap(

        cidToGidBytes,

        builtToUnicode

      );

    }

    return properties;
",2024-01-22 12:22:48+01:00
f21a30dfb4c7812e4b31acbb15206f24611ae58b,Jonas Jenwald,Convert the `PartialEvaluator.readToUnicode` method to be async,src/core/evaluator.js,https://github.com/mozilla/pdf.js/commit/f21a30dfb4c7812e4b31acbb15206f24611ae58b,"  readToUnicode(cmapObj) {

      return Promise.resolve(null);

      return CMapFactory.create({

      }).then(function (cmap) {

        return new ToUnicodeMap(cmap.getMap());

      });

    } else if (cmapObj instanceof BaseStream) {

      return CMapFactory.create({

        encoding: cmapObj,

        fetchBuiltInCMap: this._fetchBuiltInCMapBound,

        useCMap: null,

      }).then(

        function (cmap) {

          if (cmap instanceof IdentityCMap) {

            return new IdentityToUnicodeMap(0, 0xffff);

          const map = new Array(cmap.length);

          // Convert UTF-16BE

          // NOTE: cmap can be a sparse array, so use forEach instead of

          // `for(;;)` to iterate over all keys.

          cmap.forEach(function (charCode, token) {

            // Some cmaps contain *only* CID characters (fixes issue9367.pdf).

            if (typeof token === ""number"") {

              map[charCode] = String.fromCodePoint(token);

              return;

            }

            const str = [];

            for (let k = 0; k < token.length; k += 2) {

              const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);

              if ((w1 & 0xf800) !== 0xd800) {

                // w1 < 0xD800 || w1 > 0xDFFF

                str.push(w1);

                continue;

              }

              k += 2;

              const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);

              str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);

            map[charCode] = String.fromCodePoint(...str);

          });

          return new ToUnicodeMap(map);

        },

        reason => {

          if (reason instanceof AbortException) {

            return null;

          }

          if (this.options.ignoreErrors) {

            warn(`readToUnicode - ignoring ToUnicode data: ""${reason}"".`);

            return null;

          throw reason;

      );

    return Promise.resolve(null);
","  async readToUnicode(cmapObj) {

      return null;

      const cmap = await CMapFactory.create({

      });



      if (cmap instanceof IdentityCMap) {

        return new IdentityToUnicodeMap(0, 0xffff);

      }

      return new ToUnicodeMap(cmap.getMap());

    }

    if (cmapObj instanceof BaseStream) {

      try {

        const cmap = await CMapFactory.create({

          encoding: cmapObj,

          fetchBuiltInCMap: this._fetchBuiltInCMapBound,

          useCMap: null,

        });



        const map = new Array(cmap.length);

        // Convert UTF-16BE

        // NOTE: cmap can be a sparse array, so use forEach instead of

        // `for(;;)` to iterate over all keys.

        cmap.forEach(function (charCode, token) {

          // Some cmaps contain *only* CID characters (fixes issue9367.pdf).

          if (typeof token === ""number"") {

            map[charCode] = String.fromCodePoint(token);

            return;

          const str = [];

          for (let k = 0; k < token.length; k += 2) {

            const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);

            if ((w1 & 0xf800) !== 0xd800) {

              // w1 < 0xD800 || w1 > 0xDFFF

              str.push(w1);

              continue;

            k += 2;

            const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);

            str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);

          map[charCode] = String.fromCodePoint(...str);

        });

        return new ToUnicodeMap(map);

      } catch (reason) {

        if (reason instanceof AbortException) {

          return null;

        if (this.options.ignoreErrors) {

          warn(`readToUnicode - ignoring ToUnicode data: ""${reason}"".`);

          return null;

        }

        throw reason;

      }

    return null;
",2024-01-22 12:44:32+01:00
e4d0e84802098251bd72ffa6ef28907d1ce50f2a,Jonas Jenwald,"[api-minor] Replace the `PromiseCapability` with `Promise.withResolvers()`

This replaces our custom `PromiseCapability`-class with the new native `Promise.withResolvers()` functionality, which does *almost* the same thing[1]; please see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers

The only difference is that `PromiseCapability` also had a `settled`-getter, which was however not widely used and the call-sites can either be removed or re-factored to avoid it. In particular:
 - In `src/display/api.js` we can tweak the `PDFObjects`-class to use a ""special"" initial data-value and just compare against that, in order to replace the `settled`-state.
 - In `web/app.js` we change the only case to manually track the `settled`-state, which should hopefully be OK given how this is being used.
 - In `web/pdf_outline_viewer.js` we can remove the `settled`-checks, since the code should work just fine without it. The only thing that could potentially happen is that we try to `resolve` a Promise multiple times, which is however *not* a problem since the value of a Promise cannot be changed once fulfilled or rejected.
 - In `web/pdf_viewer.js` we can remove the `settled`-checks, since the code should work fine without them:
     - For the `_onePageRenderedCapability` case the `settled`-check is used in a `EventBus`-listener which is *removed* on its first (valid) invocation.
     - For the `_pagesCapability` case the `settled`-check is used in a print-related helper that works just fine with ""only"" the other checks.
 - In `test/unit/api_spec.js` we can change the few relevant cases to manually track the `settled`-state, since this is both simple and *test-only* code.

---
[1] In browsers/environments that lack native support, note [the compatibility data](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers#browser_compatibility), it'll be polyfilled via the `core-js` library (but only in `legacy` builds).",web/event_utils.js,https://github.com/mozilla/pdf.js/commit/e4d0e84802098251bd72ffa6ef28907d1ce50f2a,"function waitOnEventOrTimeout({ target, name, delay = 0 }) {

  return new Promise(function (resolve, reject) {

    if (

      typeof target !== ""object"" ||

      !(name && typeof name === ""string"") ||

      !(Number.isInteger(delay) && delay >= 0)

    ) {

      throw new Error(""waitOnEventOrTimeout - invalid parameters."");

    }



    function handler(type) {

      if (target instanceof EventBus) {

        target._off(name, eventHandler);

      } else {

        target.removeEventListener(name, eventHandler);

      }



      if (timeout) {

        clearTimeout(timeout);

      }

      resolve(type);

    }

    const eventHandler = handler.bind(null, WaitOnType.EVENT);

      target._on(name, eventHandler);

      target.addEventListener(name, eventHandler);

    const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);

    const timeout = setTimeout(timeoutHandler, delay);

  });
","async function waitOnEventOrTimeout({ target, name, delay = 0 }) {

  if (

    typeof target !== ""object"" ||

    !(name && typeof name === ""string"") ||

    !(Number.isInteger(delay) && delay >= 0)

  ) {

    throw new Error(""waitOnEventOrTimeout - invalid parameters."");

  }

  const { promise, resolve } = Promise.withResolvers();

  function handler(type) {

      target._off(name, eventHandler);

      target.removeEventListener(name, eventHandler);

    if (timeout) {

      clearTimeout(timeout);

    }

    resolve(type);

  }



  const eventHandler = handler.bind(null, WaitOnType.EVENT);

  if (target instanceof EventBus) {

    target._on(name, eventHandler);

  } else {

    target.addEventListener(name, eventHandler);

  }



  const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);

  const timeout = setTimeout(timeoutHandler, delay);



  return promise;
",2024-03-28 16:42:37+01:00
fa69d9a3bce242bc4ee3eed44a0c6eed5ce17d74,Jonas Jenwald,"Inline the helper method in `PDFLinkService.goToDestination`

We no longer need the helper method to *potentially* call itself once data is available, and can instead take full advantage of async/await by inlining the code.",web/pdf_link_service.js,https://github.com/mozilla/pdf.js/commit/fa69d9a3bce242bc4ee3eed44a0c6eed5ce17d74,"        this.pdfDocument

          .getPageIndex(destRef)

          .then(pageIndex => {

            this.cachePageRef(pageIndex + 1, destRef);

            this.#goToDestinationHelper(rawDest, namedDest, explicitDest);

          })

          .catch(() => {

            console.error(

              `PDFLinkService.#goToDestinationHelper: ""${destRef}"" is not ` +

                `a valid page reference, for dest=""${rawDest}"".`

            );

          });

        return;

        `PDFLinkService.#goToDestinationHelper: ""${destRef}"" is not ` +

          `a valid destination reference, for dest=""${rawDest}"".`

        `PDFLinkService.#goToDestinationHelper: ""${pageNumber}"" is not ` +

          `a valid page number, for dest=""${rawDest}"".`
","        try {

          pageNumber = (await this.pdfDocument.getPageIndex(destRef)) + 1;

          this.cachePageRef(pageNumber, destRef);

        } catch {

          console.error(

            `goToDestination: ""${destRef}"" is not a valid page reference, for dest=""${dest}"".`

          );

          return;

        }

        `goToDestination: ""${destRef}"" is not a valid destination reference, for dest=""${dest}"".`

        `goToDestination: ""${pageNumber}"" is not a valid page number, for dest=""${dest}"".`
",2024-04-24 21:39:10+02:00
6d523c316cf5d2c47d5e0cf0adfe3e0a57875b97,Jonas Jenwald,"[api-minor] Include the document /Lang attribute in the textContent-data

 - These changes will allow a simpler way of implementing PR 17770.

 - The /Lang attribute is fetched lazily, with the first `getTextContent` invocation. Given the existing worker-thread caching, this will thus only need to be done *once* per PDF document (and most PDFs don't included this data).

 - This makes the /Lang attribute *directly available* in the `textLayer`, which has the following advantages:
    - We don't need to block, and thus delay, overall viewer initialization on fetching it (nor pass it around throughout the viewer).

    - Third-party users of the `textLayer` will automatically benefit from this, once we start actually using the /Lang attribute in PR 17770.
      *Please note:* This also, importantly, means that the `text` reference-tests will then cover this code (which wouldn't otherwise have been the case).",src/core/document.js,https://github.com/mozilla/pdf.js/commit/6d523c316cf5d2c47d5e0cf0adfe3e0a57875b97,"    const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);

    return dataPromises.then(([contentStream]) => {

      const partialEvaluator = new PartialEvaluator({

        xref: this.xref,

        handler,

        pageIndex: this.pageIndex,

        idFactory: this._localIdFactory,

        fontCache: this.fontCache,

        builtInCMapCache: this.builtInCMapCache,

        standardFontDataCache: this.standardFontDataCache,

        globalImageCache: this.globalImageCache,

        systemFontCache: this.systemFontCache,

        options: this.evaluatorOptions,

      });

      return partialEvaluator.getTextContent({

        stream: contentStream,

        task,

        resources: this.resources,

        includeMarkedContent,

        disableNormalization,

        sink,

        viewBox: this.view,

      });
","    const langPromise = this.pdfManager.ensureCatalog(""lang"");

    const [contentStream, , lang] = await Promise.all([

      contentStreamPromise,

      resourcesPromise,

      langPromise,

    ]);

    const partialEvaluator = new PartialEvaluator({

      xref: this.xref,

      handler,

      pageIndex: this.pageIndex,

      idFactory: this._localIdFactory,

      fontCache: this.fontCache,

      builtInCMapCache: this.builtInCMapCache,

      standardFontDataCache: this.standardFontDataCache,

      globalImageCache: this.globalImageCache,

      systemFontCache: this.systemFontCache,

      options: this.evaluatorOptions,

    });

    return partialEvaluator.getTextContent({

      stream: contentStream,

      task,

      resources: this.resources,

      includeMarkedContent,

      disableNormalization,

      sink,

      viewBox: this.view,

      lang,
",2024-04-15 12:30:09+02:00
0a621ba73a974d1052fc9a6f796632be3c9b975e,Jonas Jenwald,"Use `fs/promises` in the Node.js unit-tests (PR 17714 follow-up)

This is available in all Node.js versions that we currently support, and using it allows us to remove callback-functions; please see https://nodejs.org/docs/latest-v18.x/api/fs.html#promises-api",test/unit/test_utils.js,https://github.com/mozilla/pdf.js/commit/0a621ba73a974d1052fc9a6f796632be3c9b975e,"    return new Promise((resolve, reject) => {

      fs.readFile(params.path, (error, data) => {

        if (error || !data) {

          reject(error || new Error(`Empty file for: ${params.path}`));

          return;

        }

        resolve(new Uint8Array(data));

      });

    });
","    const data = await fs.promises.readFile(params.path);

    return new Uint8Array(data);
",2024-09-22 12:57:23+02:00
df696063b95ef45ec9cfca077787f91c04ea8c4e,Jonas Jenwald,"Change the `BaseCMapReaderFactory` fetch-helper to return a `Uint8Array`

This moves more functionality into the base-class, rather than having to duplicate that in the extending classes.
For consistency, also updates the `BaseStandardFontDataFactory` and introduces more `async`/`await` in various relevant code.",src/display/display_utils.js,https://github.com/mozilla/pdf.js/commit/df696063b95ef45ec9cfca077787f91c04ea8c4e,"  _fetchData(url, compressionType) {

    return fetchData(

    ).then(data => ({

      cMapData:

        data instanceof ArrayBuffer

          ? new Uint8Array(data)

          : stringToBytes(data),

      compressionType,

    }));
","  async _fetch(url) {

    const data = await fetchData(

    );

    return data instanceof ArrayBuffer

      ? new Uint8Array(data)

      : stringToBytes(data);
",2024-10-20 17:54:04+02:00
df696063b95ef45ec9cfca077787f91c04ea8c4e,Jonas Jenwald,"Change the `BaseCMapReaderFactory` fetch-helper to return a `Uint8Array`

This moves more functionality into the base-class, rather than having to duplicate that in the extending classes.
For consistency, also updates the `BaseStandardFontDataFactory` and introduces more `async`/`await` in various relevant code.",src/display/display_utils.js,https://github.com/mozilla/pdf.js/commit/df696063b95ef45ec9cfca077787f91c04ea8c4e,"  _fetchData(url) {

    return fetchData(url, /* type = */ ""arraybuffer"").then(

      data => new Uint8Array(data)

    );
","  async _fetch(url) {

    const data = await fetchData(url, /* type = */ ""arraybuffer"");

    return new Uint8Array(data);
",2024-10-20 17:54:04+02:00
df696063b95ef45ec9cfca077787f91c04ea8c4e,Jonas Jenwald,"Change the `BaseCMapReaderFactory` fetch-helper to return a `Uint8Array`

This moves more functionality into the base-class, rather than having to duplicate that in the extending classes.
For consistency, also updates the `BaseStandardFontDataFactory` and introduces more `async`/`await` in various relevant code.",src/display/node_utils.js,https://github.com/mozilla/pdf.js/commit/df696063b95ef45ec9cfca077787f91c04ea8c4e,"const fetchData = function (url) {

  return fs.promises.readFile(url).then(data => new Uint8Array(data));

};
","async function fetchData(url) {

  const data = await fs.promises.readFile(url);

  return new Uint8Array(data);

}
",2024-10-20 17:54:04+02:00
df696063b95ef45ec9cfca077787f91c04ea8c4e,Jonas Jenwald,"Change the `BaseCMapReaderFactory` fetch-helper to return a `Uint8Array`

This moves more functionality into the base-class, rather than having to duplicate that in the extending classes.
For consistency, also updates the `BaseStandardFontDataFactory` and introduces more `async`/`await` in various relevant code.",src/display/node_utils.js,https://github.com/mozilla/pdf.js/commit/df696063b95ef45ec9cfca077787f91c04ea8c4e,"  _fetchData(url, compressionType) {

    return fetchData(url).then(data => ({ cMapData: data, compressionType }));
","  async _fetch(url) {

    return fetchData(url);
",2024-10-20 17:54:04+02:00
afb4813d1c4288011c93383d28c4445e9af28596,Jonas Jenwald,"Simplify the ""ReaderHeadersReady"" message-handler in the API

We can convert the handler to an `async` function, which removes the need to create a temporary Promise here.
Given the age of this code it shouldn't hurt to simplify it a little bit.",src/display/api.js,https://github.com/mozilla/pdf.js/commit/afb4813d1c4288011c93383d28c4445e9af28596,"    messageHandler.on(""ReaderHeadersReady"", data => {

      const headersCapability = Promise.withResolvers();

      const fullReader = this._fullReader;

      fullReader.headersReady.then(() => {

        // If stream or range are disabled, it's our only way to report

        // loading progress.

        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {

          if (this._lastProgress) {

            loadingTask.onProgress?.(this._lastProgress);

          }

          fullReader.onProgress = evt => {

            loadingTask.onProgress?.({

              loaded: evt.loaded,

              total: evt.total,

            });

          };

        }

        headersCapability.resolve({

          isStreamingSupported: fullReader.isStreamingSupported,

          isRangeSupported: fullReader.isRangeSupported,

          contentLength: fullReader.contentLength,

        });

      }, headersCapability.reject);

      return headersCapability.promise;
","    messageHandler.on(""ReaderHeadersReady"", async data => {

      await this._fullReader.headersReady;

      const { isStreamingSupported, isRangeSupported, contentLength } =

        this._fullReader;



      // If stream or range are disabled, it's our only way to report

      // loading progress.

      if (!isStreamingSupported || !isRangeSupported) {

        if (this._lastProgress) {

          loadingTask.onProgress?.(this._lastProgress);

        }

        this._fullReader.onProgress = evt => {

          loadingTask.onProgress?.({

            loaded: evt.loaded,

            total: evt.total,

          });

        };

      }

      return { isStreamingSupported, isRangeSupported, contentLength };
",2024-10-29 13:21:25+01:00
7b5cd9cddd4977f0d28894c4bbf1cd869c8bf0a8,Jonas Jenwald,"Use arrow functions with some `Promise.then` calls

A lot of this is fairly old code, which we can shorten slightly by using arrow functions instead of ""regular"" functions.",test/unit/api_spec.js,https://github.com/mozilla/pdf.js/commit/7b5cd9cddd4977f0d28894c4bbf1cd869c8bf0a8,"        function (pdfDoc) {

          return pdfDoc.getPage(1).then(function (pdfPage) {

            return pdfPage.getAnnotations();

          });
","        async pdfDoc => {

          const pdfPage = await pdfDoc.getPage(1);

          return pdfPage.getAnnotations();
",2025-03-02 18:58:52+01:00
6548c9f1f61dd4f85e9081409de2db279dd7ce68,Jonas Jenwald,"Inline the `PDFThumbnailView.prototype.#finishRenderTask` helper method

Given that the `draw` method is already asynchronous we can easily inline this old helper method, which shortens the code and improves consistency in the code-base (note the `BasePDFPageView`-implementation).",web/pdf_thumbnail_view.js,https://github.com/mozilla/pdf.js/commit/6548c9f1f61dd4f85e9081409de2db279dd7ce68,"      pageColors: this.pageColors,

    const resultPromise = renderTask.promise.then(

      () => this.#finishRenderTask(renderTask, canvas),

      error => this.#finishRenderTask(renderTask, canvas, error)

    );

    resultPromise.finally(() => {

      zeroCanvas(canvas);



      this.eventBus.dispatch(""thumbnailrendered"", {

        source: this,

        pageNumber: this.id,

        pdfPage: this.pdfPage,

      });

    return resultPromise;
","      pageColors,

    let error = null;

    try {

      await renderTask.promise;

    } catch (e) {

      if (e instanceof RenderingCancelledException) {

        zeroCanvas(canvas);

        return;

      }

      error = e;

    } finally {

      // The renderTask may have been replaced by a new one, so only remove

      // the reference to the renderTask if it matches the one that is

      // triggering this callback.

      if (renderTask === this.renderTask) {

        this.renderTask = null;

      }

    }

    this.renderingState = RenderingStates.FINISHED;



    this.#convertCanvasToImage(canvas);

    zeroCanvas(canvas);



    this.eventBus.dispatch(""thumbnailrendered"", {

      source: this,

      pageNumber: this.id,

      pdfPage,

    if (error) {

      throw error;

    }
",2025-03-15 13:57:15+01:00
d00482380af454d544324d927ec1af9e17ccb4a8,Jonas Jenwald,Introduce more `async` code in the `src/core/document.js` file,src/core/document.js,https://github.com/mozilla/pdf.js/commit/d00482380af454d544324d927ec1af9e17ccb4a8,"  getContentStream() {

    return this.pdfManager.ensure(this, ""content"").then(content => {

      if (content instanceof BaseStream) {

        return content;

      }

      if (Array.isArray(content)) {

        return new StreamsSequenceStream(

          content,

          this._onSubStreamError.bind(this)

        );

      }

      // Replace non-existent page content with empty content.

      return new NullStream();

    });
","  async getContentStream() {

    const content = await this.pdfManager.ensure(this, ""content"");



    if (content instanceof BaseStream) {

      return content;

    }

    if (Array.isArray(content)) {

      return new StreamsSequenceStream(

        content,

        this._onSubStreamError.bind(this)

      );

    }

    // Replace non-existent page content with empty content.

    return new NullStream();
",2025-03-17 13:20:51+01:00
d00482380af454d544324d927ec1af9e17ccb4a8,Jonas Jenwald,Introduce more `async` code in the `src/core/document.js` file,src/core/document.js,https://github.com/mozilla/pdf.js/commit/d00482380af454d544324d927ec1af9e17ccb4a8,"    return this._parsedAnnotations.then(function (annotations) {

      const promises = [];

      for (const annotation of annotations) {

        promises.push(

          annotation

            .save(partialEvaluator, task, annotationStorage, changes)

            .catch(function (reason) {

              warn(

                ""save - ignoring annotation data during "" +

                  `""${task.name}"" task: ""${reason}"".`

              );

              return null;

            })

        );

      }

      return Promise.all(promises);

    });

  loadResources(keys) {

    this.resourcesPromise ||= this.pdfManager.ensure(this, ""resources"");

    return this.resourcesPromise.then(() => {

      const objectLoader = new ObjectLoader(this.resources, keys, this.xref);

      return objectLoader.load();

    });

  getOperatorList({
","    const annotations = await this._parsedAnnotations;

    const promises = [];

    for (const annotation of annotations) {

      promises.push(

        annotation

          .save(partialEvaluator, task, annotationStorage, changes)

          .catch(function (reason) {

            warn(

              ""save - ignoring annotation data during "" +

                `""${task.name}"" task: ""${reason}"".`

            );

            return null;

          })

      );

    }

    return Promise.all(promises);

  async loadResources(keys) {

    await (this.resourcesPromise ??= this.pdfManager.ensure(this, ""resources""));

    const objectLoader = new ObjectLoader(this.resources, keys, this.xref);

    await objectLoader.load();

  async getOperatorList({
",2025-03-17 13:20:51+01:00
d00482380af454d544324d927ec1af9e17ccb4a8,Jonas Jenwald,Introduce more `async` code in the `src/core/document.js` file,src/core/document.js,https://github.com/mozilla/pdf.js/commit/d00482380af454d544324d927ec1af9e17ccb4a8,"      return partialEvaluator

        .getOperatorList({

          stream: contentStream,

          task,

          resources: this.resources,

          operatorList: opList,

        })

        .then(() => opList);

    return Promise.all([

    ]).then(function ([pageOpList, annotations, newAnnotations]) {

      if (newAnnotations) {

        // Some annotations can already exist (if it has the refToReplace

        // property). In this case, we replace the old annotation by the new

        // one.

        annotations = annotations.filter(

          a => !(a.ref && deletedAnnotations.has(a.ref))

        );

        for (let i = 0, ii = newAnnotations.length; i < ii; i++) {

          const newAnnotation = newAnnotations[i];

          if (newAnnotation.refToReplace) {

            const j = annotations.findIndex(

              a => a.ref && isRefsEqual(a.ref, newAnnotation.refToReplace)

            );

            if (j >= 0) {

              annotations.splice(j, 1, newAnnotation);

              newAnnotations.splice(i--, 1);

              ii--;

            }

        annotations = annotations.concat(newAnnotations);

        annotations.length === 0 ||

        intent & RenderingIntentFlag.ANNOTATIONS_DISABLE

        pageOpList.flush(/* lastChunk = */ true);

        return { length: pageOpList.totalLength };

      }

      const renderForms = !!(intent & RenderingIntentFlag.ANNOTATIONS_FORMS),

        isEditing = !!(intent & RenderingIntentFlag.IS_EDITING),

        intentAny = !!(intent & RenderingIntentFlag.ANY),

        intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),

        intentPrint = !!(intent & RenderingIntentFlag.PRINT);



      // Collect the operator list promises for the annotations. Each promise

      // is resolved with the complete operator list for a single annotation.

      const opListPromises = [];

      for (const annotation of annotations) {

        if (

          intentAny ||

          (intentDisplay &&

            annotation.mustBeViewed(annotationStorage, renderForms) &&

            annotation.mustBeViewedWhenEditing(isEditing, modifiedIds)) ||

          (intentPrint && annotation.mustBePrinted(annotationStorage))

        ) {

          opListPromises.push(

            annotation

              .getOperatorList(

                partialEvaluator,

                task,

                intent,

                annotationStorage

              )

              .catch(function (reason) {

                warn(

                  ""getOperatorList - ignoring annotation data during "" +

                    `""${task.name}"" task: ""${reason}"".`

                );

                return {

                  opList: null,

                  separateForm: false,

                  separateCanvas: false,

                };

              })

          );

        }

      return Promise.all(opListPromises).then(function (opLists) {

        let form = false,

          canvas = false;

        for (const { opList, separateForm, separateCanvas } of opLists) {

          pageOpList.addOpList(opList);

          form ||= separateForm;

          canvas ||= separateCanvas;

        }

        pageOpList.flush(

          /* lastChunk = */ true,

          /* separateAnnots = */ { form, canvas }

        );

        return { length: pageOpList.totalLength };

      });

    });
","      await partialEvaluator.getOperatorList({

        stream: contentStream,

        task,

        resources: this.resources,

        operatorList: opList,

      });

      return opList;

    // eslint-disable-next-line prefer-const

    let [pageOpList, annotations, newAnnotations] = await Promise.all([

    ]);



    if (newAnnotations) {

      // Some annotations can already exist (if it has the refToReplace

      // property). In this case, we replace the old annotation by the new one.

      annotations = annotations.filter(

        a => !(a.ref && deletedAnnotations.has(a.ref))

      );

      for (let i = 0, ii = newAnnotations.length; i < ii; i++) {

        const newAnnotation = newAnnotations[i];

        if (newAnnotation.refToReplace) {

          const j = annotations.findIndex(

            a => a.ref && isRefsEqual(a.ref, newAnnotation.refToReplace)

          );

          if (j >= 0) {

            annotations.splice(j, 1, newAnnotation);

            newAnnotations.splice(i--, 1);

            ii--;

      annotations = annotations.concat(newAnnotations);

    }

    if (

      annotations.length === 0 ||

      intent & RenderingIntentFlag.ANNOTATIONS_DISABLE

    ) {

      pageOpList.flush(/* lastChunk = */ true);

      return { length: pageOpList.totalLength };

    }

    const renderForms = !!(intent & RenderingIntentFlag.ANNOTATIONS_FORMS),

      isEditing = !!(intent & RenderingIntentFlag.IS_EDITING),

      intentAny = !!(intent & RenderingIntentFlag.ANY),

      intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),

      intentPrint = !!(intent & RenderingIntentFlag.PRINT);



    // Collect the operator list promises for the annotations. Each promise

    // is resolved with the complete operator list for a single annotation.

    const opListPromises = [];

    for (const annotation of annotations) {

        intentAny ||

        (intentDisplay &&

          annotation.mustBeViewed(annotationStorage, renderForms) &&

          annotation.mustBeViewedWhenEditing(isEditing, modifiedIds)) ||

        (intentPrint && annotation.mustBePrinted(annotationStorage))

        opListPromises.push(

          annotation

            .getOperatorList(partialEvaluator, task, intent, annotationStorage)

            .catch(function (reason) {

              warn(

                ""getOperatorList - ignoring annotation data during "" +

                  `""${task.name}"" task: ""${reason}"".`

              );

              return {

                opList: null,

                separateForm: false,

                separateCanvas: false,

              };

            })

        );

    }

    const opLists = await Promise.all(opListPromises);

    let form = false,

      canvas = false;

    for (const { opList, separateForm, separateCanvas } of opLists) {

      pageOpList.addOpList(opList);

      form ||= separateForm;

      canvas ||= separateCanvas;

    }

    pageOpList.flush(

      /* lastChunk = */ true,

      /* separateAnnots = */ { form, canvas }

    );

    return { length: pageOpList.totalLength };
",2025-03-17 13:20:51+01:00
62009ffa701a69f2ff179682169dae53d1d336b8,Jonas Jenwald,"Simplify how the `ObjectLoader` is used

The `ObjectLoader.prototype.load` method has a fast-path, which avoids any lookup/parsing if the entire PDF document is already loaded.
However, we still need to create an `ObjectLoader`-instance which seems unnecessary in that case.

Hence we introduce a *static* `ObjectLoader.load` method, which will help avoid creating `ObjectLoader`-instances needlessly and also (slightly) shortens the call-sites.
To ensure that the new method will be used, we extend the `no-restricted-syntax` ESLint rule to ""forbid"" direct usage of `new ObjectLoader()`.",src/core/annotation.js,https://github.com/mozilla/pdf.js/commit/62009ffa701a69f2ff179682169dae53d1d336b8,"  loadResources(keys, appearance) {

    return appearance.dict.getAsync(""Resources"").then(resources => {

      if (!resources) {

        return undefined;

      }



      const objectLoader = new ObjectLoader(resources, keys, resources.xref);

      return objectLoader.load().then(() => resources);

    });
","  async loadResources(keys, appearance) {

    const resources = await appearance.dict.getAsync(""Resources"");

    if (resources) {

      await ObjectLoader.load(resources, keys, resources.xref);

    }

    return resources;
",2025-05-06 15:28:36+02:00
